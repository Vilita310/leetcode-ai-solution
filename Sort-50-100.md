# 1370. Increasing Decreasing String

### Problem Description 
Given a string `s`. You should re-order the string using the following algorithm:
Pick the smallest character from `s` and append it to the result.

Pick the smallest character from `s` which is greater than the last appended character to the result and append it.

Repeat step 2 until you cannot pick more characters.

Pick the largest character from `s` and append it to the result.

Pick the largest character from `s` which is smaller than the last appended character to the result and append it.

Repeat step 5 until you cannot pick more characters.

Repeat the steps from 1 to 6 until you pick all characters from `s`.

In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.

Return the result string after sorting `s` with this algorithm.


Example 1:
Input: s = "aaaabbbbcccc"
Output: "abccbaabccba"
Explanation: After steps 1, 2 and 3 of the first iteration, result = "abc"
After steps 4, 5 and 6 of the first iteration, result = "abccba"
First iteration is done. Now s = "aabbcc" and we go back to step 1
After steps 1, 2 and 3 of the second iteration, result = "abccbaabc"
After steps 4, 5 and 6 of the second iteration, result = "abccbaabccba"

Example 2:
Input: s = "rat"
Output: "art"
Explanation: The word "rat" becomes "art" after re-ordering it with the mentioned algorithm.


Example 3:
Input: s = "leetcode"
Output: "cdelotee"

Example 4:
Input: s = "ggggggg"
Output: "ggggggg"

Example 5:
Input: s = "spo"
Output: "ops"

Constraints:
`1 <= s.length <= 500`
`s` contains only lower-case English letters.

### Solution 
 To solve the problem of reordering the string `s` according to the specified algorithm, we will follow these steps:

1. **Count Characters**: We'll use `collections.Counter` to count the frequency of each character in the input string.
2. **Arrange Characters**: We will work with a sorted list of unique characters to systematically pick the smallest and largest characters as required by the algorithm.
3. **Build the Result**: We will append characters to a result string in the specified order until all characters from the input string have been included.

Here's how we'll implement the algorithm in Python:



```python
from collections import Counter

class Solution:
    def sortString(self, s: str) -> str:
        # Count the frequency of each character in the string
        count = Counter(s)
        result = []
        
        # Keep processing until all characters are used
        while count:
            # Step 1: Append smallest characters in ascending order
            for char in sorted(count.keys()):
                result.append(char)
                count[char] -= 1
                if count[char] == 0:
                    del count[char]  # Remove character from count if it's used up
            
            # Step 2: Append largest characters in descending order
            for char in sorted(count.keys(), reverse=True):
                result.append(char)
                count[char] -= 1
                if count[char] == 0:
                    del count[char]  # Remove character from count if it's used up
        
        return ''.join(result)

# Example usage
solution = Solution()
print(solution.sortString("aaaabbbbcccc"))  # Output: "abccbaabccba"
print(solution.sortString("rat"))            # Output: "art"
print(solution.sortString("leetcode"))        # Output: "cdelotee"
print(solution.sortString("ggggggg"))         # Output: "ggggggg"
print(solution.sortString("spo"))             # Output: "ops"

```

### Explanation:

- **Counter**: We use `Counter` to count occurrences of each character in the string `s`. This allows us to keep track of how many of each character we have available for selection.
- **Outer Loop**: The outer `while count:` loop continues as long as there are characters left to process in the count dictionary. Each full iteration consists of picking characters in both ascending and descending order.
- **Ascending Order**: We sort the keys of the `count` dictionary to get characters in ascending order and append them to the result. After appending a character, we decrement its count, and if the count reaches zero, we remove it from the dictionary.
- **Descending Order**: Similarly, we sort the keys in reverse order and append characters in descending order, following the same decrement and removal logic.
- **Final Step**: Once all characters have been appended, we join the `result` list into a single string and return it.

This approach is efficient and ensures that we adhere to the algorithm specified in the problem statement.

# 1383. Maximum Performance of a Team

### Problem Description 
There are `n` engineers numbered from 1 to `n` and two arrays: `speed` and `efficiency`, where `speed[i]` and `efficiency[i]` represent the speed and efficiency for the i-th engineer respectively. Return the maximum performance of a team composed of at most `k` engineers, since the answer can be a huge number, return this modulo 10^9 + 7.

The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers. 

Example 1:
Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
Output: 60
Explanation: 
We have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) * min(4, 7) = 60.


Example 2:
Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
Output: 68
Explanation:
This is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68.


Example 3:
Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
Output: 72

Constraints:
`1 <= n <= 10^5`
`speed.length == n`
`efficiency.length == n`
`1 <= speed[i] <= 10^5`
`1 <= efficiency[i] <= 10^8`
`1 <= k <= n`

### Solution 
 To solve the problem of maximizing the performance of a team of engineers given their speeds and efficiencies, we need to strategically select the engineers based on the rules provided. The approach involves selecting the top engineers based on their efficiencies and speeds and ensuring the combination yields the highest performance.

### Detailed Explanation:

1. **Understanding Performance**:
   - The performance of a team is calculated using the formula:
     \[
     \text{Performance} = (\text{Sum of speeds of selected engineers}) \times (\text{Minimum efficiency of selected engineers})
     \]
   - To maximize performance, we need to select engineers in a way that not only maximizes the speed but also ensures that the minimum efficiency is as high as possible.

2. **Greedy Strategy**:
   - Sort engineers by their efficiency in descending order. This allows us to take advantage of the strongest efficiencies first.
   - As we consider each engineer (starting with the highest efficiency), we can maintain a running total of speeds of the selected engineers. We add engineers to our team until we either reach the limit `k` or exhaust our list.

3. **Using a Min-Heap (Priority Queue)**:
   - To efficiently manage the sum of the top `k` speeds, we can use a min-heap. This gives us the ability to keep track of the lowest speed in our selection and evict the smallest speed if we exceed `k` engineers.
   - By maintaining the total of speeds in a variable and adjusting it as we push new speeds into the heap, we can compute the maximum performance on-the-fly.

4. **Modulo Operation**:
   - Since the result can be quite large, we'll use modulo \(10^9 + 7\) at each step to prevent overflow.

### Python Code Implementation:
Here's the implementation designed to run in the LeetCode environment:



```python
import heapq

class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        engineers = sorted(zip(efficiency, speed), reverse=True)  # Sort by efficiency descending
        speed_heap = []  # Min-heap to maintain top speeds
        speed_sum = 0
        max_perf = 0
        mod = 10**9 + 7
        
        for eff, spd in engineers:
            # Add current engineer's speed to total speed sum and heap
            heapq.heappush(speed_heap, spd)
            speed_sum += spd
            
            # If we exceed the number of engineers, pop the lowest speed
            if len(speed_heap) > k:
                speed_sum -= heapq.heappop(speed_heap)
            
            # Calculate performance with current engineer's efficiency
            max_perf = max(max_perf, speed_sum * eff)
        
        return max_perf % mod

```

### Explanation of the Code:
1. **Sorting**: We first sort the engineers by their efficiency in descending order so that we can always try to use the highest efficiency available.
2. **Heap Management**: For each engineer, we add their speed to a min-heap and update the total speed. If the size of the heap exceeds `k`, we pop the smallest speed, ensuring we keep only the top `k` speeds.
3. **Performance Calculation**: After updating the total speed, we compute the performance using the current efficiency and update `max_perf` if the current performance is higher.
4. **Result**: Finally, we return the maximum performance modulo \(10^9 + 7\).

This approach is efficient and runs in `O(n log k)` due to the sorting and the heap operations, which is suitable given the constraints.

# 1387. Sort Integers by The Power Value

### Problem Description 
The power of an integer `x` is defined as the number of steps needed to transform `x` into `1` using the following steps:
if `x` is even then `x = x / 2`
if `x` is odd then `x = 3 * x + 1`
For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1).

Given three integers `lo`, `hi` and `k`. The task is to sort all integers in the interval `[lo, hi]` by the power value in ascending order, if two or more integers have the same power value sort them by ascending order.

Return the `k-th` integer in the range `[lo, hi]` sorted by the power value.

Notice that for any integer `x` `(lo <= x <= hi)` it is guaranteed that `x` will transform into `1` using these steps and that the power of `x` is will fit in 32 bit signed integer.


Example 1:
Input: lo = 12, hi = 15, k = 2
Output: 13
Explanation: The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1)
The power of 13 is 9
The power of 14 is 17
The power of 15 is 17
The interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13.

Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15.


Example 2:
Input: lo = 1, hi = 1, k = 1
Output: 1

Example 3:
Input: lo = 7, hi = 11, k = 4
Output: 7
Explanation: The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14].

The interval sorted by power is [8, 10, 11, 7, 9].

The fourth number in the sorted array is 7.


Example 4:
Input: lo = 10, hi = 20, k = 5
Output: 13

Example 5:
Input: lo = 1, hi = 1000, k = 777
Output: 570

Constraints:
`1 <= lo <= hi <= 1000`
`1 <= k <= hi - lo + 1`

### Solution 
 To solve the problem, we need to compute the power of each integer in the range `[lo, hi]` and then sort these integers based on their power values. Finally, we will return the `k-th` integer from this sorted list.

Here's how we can break down the solution:

1. **Compute the Power of an Integer:** We will create a function `power(x)` that follows the rules described in the problem to compute the power of `x`. Specifically, we will use a loop to apply the transformation rules until `x` becomes `1`, counting the number of steps in the process.

2. **Build a List of Tuples:** For each integer in the range `[lo, hi]`, we will calculate its power and store each integer along with its power in a list of tuples: `(power_value, number)`. 

3. **Sort the List:** We will sort this list of tuples first by the power value and then by the integer itself. In Python, tuples are sorted lexicographically, so we can simply sort on the first element and then the second.

4. **Return the k-th Integer:** After sorting, we will access the `k-th` integer (considering 1-indexing) from the sorted list and return its value.

Here's the Python implementation that follows the LeetCode format:



```python
class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:
        def power(x: int) -> int:
            steps = 0
            while x != 1:
                if x % 2 == 0:
                    x //= 2
                else:
                    x = 3 * x + 1
                steps += 1
            return steps
            
        # Create a list of tuples (power_value, number)
        power_values = [(power(x), x) for x in range(lo, hi + 1)]
        
        # Sort the list by (power_value, number)
        power_values.sort()
        
        # Return the k-th number in the sorted list (1-indexed)
        return power_values[k - 1][1]

# Example usage:
# sol = Solution()
# print(sol.getKth(12, 15, 2))  # Output: 13

```

### Explanation of the Code:
1. **Method Definition:** We define a method `getKth` that takes in the parameters `lo`, `hi`, and `k`.

2. **Power Calculation Function:** Inside this method, we define a nested function `power(x)` that calculates the power of the integer `x`. It iteratively transforms `x` until it reaches `1`, counting the steps taken.

3. **List Comprehension for Power Values:** We generate a list of tuples by calculating the power for each integer `x` in the range `[lo, hi]`. Each tuple contains the computed power value and the corresponding number.

4. **Sorting the List:** We sort the list of tuples. The default sort behavior will first sort by power value and then by the second element of the tuple in case of a tie.

5. **Retrieving the k-th Element:** Finally, we return the second element of the tuple at index `k-1`, which corresponds to the `k-th` smallest power. 

This solution is efficient and leverages Python's built-in functionalities seamlessly while adhering to the required constraints.

# 1403. Minimum Subsequence in Non-Increasing Order

### Problem Description 
Given the array `nums`, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. 
If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. 
Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.


Example 1:
Input: nums = [4,3,10,9,8]
Output: [10,9] 
Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included, however, the subsequence [10,9] has the maximum total sum of its elements. 

Example 2:
Input: nums = [4,4,7,6,7]
Output: [7,7,6] 
Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to returned in non-decreasing order.  

Example 3:
Input: nums = [6]
Output: [6]

Constraints:
`1 <= nums.length <= 500`
`1 <= nums[i] <= 100`

### Solution 
 To solve the problem of finding a subsequence from the given array `nums` such that the sum of this subsequence is strictly greater than the sum of the elements not included in it, we can follow these steps:

1. **Calculate the Total Sum**: First, we need to compute the total sum of the elements in the array. This will help us establish a target for the subsequence sum.

2. **Sort and Select Candidates**: To find the minimal subsequence that meets the conditions, we should sort the array in non-increasing order. This way, we can maximize the sum of the elements we include in the subsequence while keeping its size as small as possible.

3. **Build the Subsequence**: Starting from the largest elements, we will keep adding numbers from the sorted array to our subsequence until the sum of the included elements becomes strictly greater than the sum of the excluded elements.

4. **Return the Result**: Finally, we return the resulting subsequence, sorted in non-increasing order.

Now, let's implement this approach in Python according to the LeetCode format:



```python
class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        # Step 1: Calculate the total sum of the array
        total_sum = sum(nums)
        
        # Step 2: Sort the array in non-increasing order
        nums.sort(reverse=True)
        
        subsequence_sum = 0
        subsequence = []
        
        # Step 3: Build the subsequence
        for num in nums:
            subsequence.append(num)
            subsequence_sum += num
            
            # Check if the sum of the subsequence is strictly greater
            if subsequence_sum > (total_sum - subsequence_sum):
                break
        
        # The result is already in non-increasing order due to the sorting
        return subsequence

```

### Explanation of the Code

1. **Input Type**: We define the function within a class `Solution` and specify that it takes a list of integers `nums` as an argument.
  
2. **Calculate Total Sum**: We compute the total sum of the `nums` using Python's built-in `sum()` function. This total sum will help us compare the sums of included vs excluded elements.

3. **Sorting**: We sort the list `nums` in reverse order (largest first) using the `sort()` method with the `reverse=True` argument. This helps in easily accessing the largest elements which are crucial for maximizing our subsequence sum while minimizing its size.

4. **Building the Subsequence**: We loop through the sorted `nums`, appending each number to `subsequence` and updating `subsequence_sum`. As soon as we find that the sum of our included elements is greater than the sum of the excluded elements (which can be derived from `total_sum - subsequence_sum`), we break out of the loop.

5. **Return the Result**: Finally, we return the built subsequence, which is already in the required non-increasing order.

The code follows the constraints and handles all edge cases effectively, yielding the desired subsequence. This solution runs in \( O(n \log n) \) time due to sorting and \( O(n) \) for iterating through the list, making it efficient for the given problem constraints.

# 1424. Diagonal Traverse II

### Problem Description 
Given a list of lists of integers, `nums`, return all elements of `nums` in diagonal order as shown in the below images.


Example 1:
Input: nums = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,4,2,7,5,3,8,6,9]

Example 2:
Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]

Example 3:
Input: nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]
Output: [1,4,2,5,3,8,6,9,7,10,11]

Example 4:
Input: nums = [[1,2,3,4,5,6]]
Output: [1,2,3,4,5,6]

Constraints:
`1 <= nums.length <= 10^5`
`1 <= nums[i].length <= 10^5`
`1 <= nums[i][j] <= 10^9`
There at most `10^5` elements in `nums`.

### Solution 
 To solve the problem of returning all elements of a list of lists of integers in diagonal order, we need to understand how to traverse these lists diagonally. The traversal starts from the top-left cell (the first element of the first list) and moves to the bottom-left, then to the top-right, in a zigzag manner.

### Explanation of the Approach

1. **Define Indices**: We need to keep track of the indices while traversing. For each element located at `(i, j)`, the diagonal index can be determined by the sum `d = i + j`.

2. **Store in Result List**: We can use a result list where we append elements based on their diagonal index `d`. Each diagonal will be stored in a temporary list, and once we've collected all elements belonging to that diagonal, we'll merge them into the final result.

3. **Iteration**: We iterate through each row and each element of the row, appending elements to their respective diagonals.

4. **Reverse Order**: While collecting the elements of each diagonal, we need to note that we traverse from the bottommost element to the topmost for each diagonal. Therefore, we need to reverse the order when concatenating.

### Code Implementation

Here is the implementation following the LeetCode solution format:



```python
class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        # Create a dictionary to hold lists for diagonals
        diagonal_map = {}
        
        # Fill diagonal_map with elements from nums
        for i in range(len(nums)):
            for j in range(len(nums[i])):
                diagonal_index = i + j
                if diagonal_index not in diagonal_map:
                    diagonal_map[diagonal_index] = []
                diagonal_map[diagonal_index].append(nums[i][j])
        
        result = []
        
        # Gather elements in diagonal order
        for d in range(len(diagonal_map)):
            if d % 2 == 0:  # For even diagonals, reverse the order
                result.extend(reversed(diagonal_map[d]))
            else:           # For odd diagonals, maintain the order
                result.extend(diagonal_map[d])
        
        return result

```

### Detailed Breakdown of the Code

1. **Dictionary for Diagonals**: We create a dictionary `diagonal_map` where each key corresponds to the diagonal index, and its value is a list of integers that fall under that diagonal.

2. **Nested Loop**: We loop through each list `nums[i]` and then through each element `nums[i][j]` in that list, calculating its diagonal index `i + j`. We append the elements into their corresponding diagonal list.

3. **Constructing Result**: After populating the `diagonal_map`, we iterate through the diagonals. For even indexed diagonals, we append the reversed list of elements to the result. For odd diagonals, we append as is.

4. **Return Statement**: Finally, the constructed `result` list is returned.

### Complexity Analysis

- **Time Complexity**: O(N), where N is the total number of elements in `nums`. We visit each element once.
- **Space Complexity**: O(N), used for storing the diagonal elements and the result.

This structure allows us to efficiently compute and return the elements in diagonal order as specified in the problem statement.

# 1451. Rearrange Words in a Sentence

### Problem Description 
Given a sentence `text` (A sentence is a string of space-separated words) in the following format:
First letter is in upper case.

Each word in `text` are separated by a single space.

Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.

Return the new text following the format shown above.


Example 1:
Input: text = "Leetcode is cool"
Output: "Is cool leetcode"
Explanation: There are 3 words, "Leetcode" of length 8, "is" of length 2 and "cool" of length 4.

Output is ordered by length and the new first word starts with capital letter.

Example 2:
Input: text = "Keep calm and code on"
Output: "On and keep calm code"
Explanation: Output is ordered as follows:
"On" 2 letters.

"and" 3 letters.

"keep" 4 letters in case of tie order by position in original text.

"calm" 4 letters.

"code" 4 letters.


Example 3:
Input: text = "To be or not to be"
Output: "To be or to be not"

Constraints:
`text` begins with a capital letter and then contains lowercase letters and single space between words.

`1 <= text.length <= 10^5`

### Solution 
 To solve the problem of rearranging the words in a given sentence based on their lengths while maintaining the original order for words of the same length, we can approach the solution as follows:

### Step-by-step Explanation:

1. **Input and Output**:
   - The input is a string `text` where the first letter is capitalized and words are separated by single spaces.
   - The output should be a rearranged string where words are ordered by their lengths and the first word in the output is also capitalized.

2. **Breaking Down the Problem**:
   - Split the input string into individual words.
   - Sort the words based on their lengths while maintaining the original order for words with the same length. We can achieve this using Python's built-in sorting features.
   - Join the sorted words back into a single string.
   - Ensure the first word in the output is capitalized.

3. **Algorithm**:
   - Use the `split()` method to create a list of words from the string.
   - Utilize the `sorted()` function with a custom sorting key based on the length of the words.
   - Handle the capitalization of the first word.
   - Join the list of sorted words back into a single string with spaces.

### Implementation:

Below is the Python code implementing the above steps formatted suitably for submission on LeetCode:



```python
class Solution:
    def rearrangeWords(self, text: str) -> str:
        # Step 1: Split the text into words
        words = text.split()
        
        # Step 2: Sort words based on length (stable sort maintains original order)
        sorted_words = sorted(words, key=len)
        
        # Step 3: Capitalize the first word and lowercase the rest
        sorted_words[0] = sorted_words[0].capitalize()  # Capitalize first word
        for i in range(1, len(sorted_words)):
            sorted_words[i] = sorted_words[i].lower()  # Ensure rest are lower case
        
        # Step 4: Join the sorted words into a single string with spaces
        result = ' '.join(sorted_words)
        return result

# Example usage:
# sol = Solution()
# print(sol.rearrangeWords("Leetcode is cool")) # Output: "Is cool leetcode"

```

### Explanation of the Code:

- **Class and Method**: We define a class `Solution` with a method `rearrangeWords` which takes a string parameter `text`.
- **Splitting**: We split the input string into a list of words using `split()`, which handles the spaces between words.
- **Sorting**: We sort the list of words based on their length using `sorted()`. The `key=len` argument ensures that words are sorted by their lengths, and because `sorted()` is stable, it preserves the original order for words of the same length.
- **Capitalization**: We capitalize the first word of the sorted list and make sure the subsequent words are in lowercase to match the expected output format.
- **Joining**: Finally, we use `' '.join(sorted_words)` to concatenate the words back into a single string, separated by spaces.

### Complexity:
- The time complexity here is O(n log n) due to the sorting step, where n is the number of words in the input string. This is efficient enough given the constraints provided (up to 10^5 characters).
- The space complexity is O(n) for storing the list of words.

This solution effectively handles the requirements of the problem and adheres to the format expected by LeetCode.

# 1452. People Whose List of Favorite Companies Is Not a Subset of Another List

### Problem Description 
Given the array `favoriteCompanies` where `favoriteCompanies[i]` is the list of favorites companies for the `ith` person (indexed from 0).

Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.


Example 1:
Input: favoriteCompanies = [["leetcode","google","facebook"],["google","microsoft"],["google","facebook"],["google"],["amazon"]]
Output: [0,1,4] 
Explanation: 
Person with index=2 has favoriteCompanies[2]=["google","facebook"] which is a subset of favoriteCompanies[0]=["leetcode","google","facebook"] corresponding to the person with index 0. 
Person with index=3 has favoriteCompanies[3]=["google"] which is a subset of favoriteCompanies[0]=["leetcode","google","facebook"] and favoriteCompanies[1]=["google","microsoft"]. 
Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4].


Example 2:
Input: favoriteCompanies = [["leetcode","google","facebook"],["leetcode","amazon"],["facebook","google"]]
Output: [0,1] 
Explanation: In this case favoriteCompanies[2]=["facebook","google"] is a subset of favoriteCompanies[0]=["leetcode","google","facebook"], therefore, the answer is [0,1].


Example 3:
Input: favoriteCompanies = [["leetcode"],["google"],["facebook"],["amazon"]]
Output: [0,1,2,3]

Constraints:
`1 <= favoriteCompanies.length <= 100`
`1 <= favoriteCompanies[i].length <= 500`
`1 <= favoriteCompanies[i][j].length <= 20`
All strings in `favoriteCompanies[i]` are distinct.

All lists of favorite companies are distinct, that is, If we sort alphabetically each list then `favoriteCompanies[i] != favoriteCompanies[j].`
All strings consist of lowercase English letters only.

### Solution 
 To solve the problem, we need to determine which people's lists of favorite companies are not subsets of any other person's list. This means we need to check each person's list against all other lists and see if one is fully contained within another.

Here's a structured approach on how to tackle this problem:

### Steps:
1. Iterate through each person's list of favorite companies.
2. For each person's list, check it against all other lists.
3. A person's list is considered a subset of another if all companies in that person's list are also in the other person's list.
4. If a person's list is not a subset of any other list, we record their index.
5. Finally, return the indices of the people whose lists are not subsets of any other lists, sorted in increasing order.

### Implementation:
We will use Python sets to make subset checks efficient. The check for subsets can be done using set operations in Python.

Here is the code:



```python
def peopleIndexes(favoriteCompanies):
    n = len(favoriteCompanies)
    # Convert lists to sets for faster subset checks
    favorite_sets = [set(companies) for companies in favoriteCompanies]
    
    non_subset_indices = []
    
    for i in range(n):
        is_subset = False
        for j in range(n):
            if i != j:  # Don't compare with itself
                # Check if favoriteCompanies[i] is a subset of favoriteCompanies[j]
                if favorite_sets[i].issubset(favorite_sets[j]):
                    is_subset = True
                    break
        if not is_subset:
            non_subset_indices.append(i)
    
    return non_subset_indices

# Sample Inputs
print(peopleIndexes([["leetcode","google","facebook"],
                     ["google","microsoft"],
                     ["google","facebook"],
                     ["google"],
                     ["amazon"]]))  # Output: [0, 1, 4]

print(peopleIndexes([["leetcode","google","facebook"],
                     ["leetcode","amazon"],
                     ["facebook","google"]]))  # Output: [0, 1]

print(peopleIndexes([["leetcode"], ["google"], ["facebook"], ["amazon"]]))  # Output: [0, 1, 2, 3]

```

### Explanation of the Code:
1. **Initialization**: We first convert each person's list of favorite companies into a set to facilitate fast membership checking.
2. **Outer Loop**: For each person's index `i`, we start with a flag `is_subset` set to `False`.
3. **Inner Loop**: We loop through every other index `j` to check if their favorite companies at `favoriteCompanies[i]` is a subset of `favoriteCompanies[j]`.
4. **Subset Check**: If `favorite_sets[i].issubset(favorite_sets[j])`, it confirms that `i` is a subset of `j`, and we can set `is_subset = True` and break out of the inner loop.
5. **Storing Results**: If after checking all other people (`j`), `is_subset` remains `False`, we add the index `i` to our result list `non_subset_indices`.
6. **Final Output**: The function returns the list of indices which are not subsets of any other list.

### Complexity Analysis:
- The time complexity is O(n^2 * m) where `n` is the number of people and `m` is the average number of favorite companies. The space complexity is O(n * m) for storing the sets.

This code adheres to the LeetCode format, wherein it can be easily tested directly on the platform. Simply copy and paste the function into the LeetCode editor with the appropriate input formatting and test cases.

# 1471. The k Strongest Values in an Array

### Problem Description 
Given an array of integers `arr` and an integer `k`.

A value `arr[i]` is said to be stronger than a value `arr[j]` if `|arr[i] - m| > |arr[j] - m|` where `m` is the median of the array.

If `|arr[i] - m| == |arr[j] - m|`, then `arr[i]` is said to be stronger than `arr[j]` if `arr[i] > arr[j]`.

Return a list of the strongest `k` values in the array. return the answer in any arbitrary order.

Median is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position `((n - 1) / 2)` in the sorted list (0-indexed).

For `arr = [6, -3, 7, 2, 11]`, `n = 5` and the median is obtained by sorting the array `arr = [-3, 2, 6, 7, 11]` and the median is `arr[m]` where `m = ((5 - 1) / 2) = 2`. The median is `6`.

For `arr = [-7, 22, 17, 3]`, `n = 4` and the median is obtained by sorting the array `arr = [-7, 3, 17, 22]` and the median is `arr[m]` where `m = ((4 - 1) / 2) = 1`. The median is `3`.


Example 1:
Input: arr = [1,2,3,4,5], k = 2
Output: [5,1]
Explanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer.

Please note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1.


Example 2:
Input: arr = [1,1,3,5,5], k = 2
Output: [5,5]
Explanation: Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5].


Example 3:
Input: arr = [6,7,11,7,6,8], k = 5
Output: [11,8,6,6,7]
Explanation: Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7].

Any permutation of [11,8,6,6,7] is accepted.


Example 4:
Input: arr = [6,-3,7,2,11], k = 3
Output: [-3,11,2]

Example 5:
Input: arr = [-7,22,17,3], k = 2
Output: [22,17]

Constraints:
`1 <= arr.length <= 10^5`
`-10^5 <= arr[i] <= 10^5`
`1 <= k <= arr.length`

### Solution 
 To solve the problem of finding the strongest `k` values in an array with respect to its median, we can follow these steps:

1. **Calculate the Median**: First, we need to find the median of the input array. The median is defined as the middle value in a sorted list. If the list has an odd number of elements, it is the middle element. For an even number of elements, it is defined as the element at the position `((n - 1) / 2)`.

2. **Determine Strength**: For each element in the array, we need to define its strength based on its distance from the median. Specifically:
   - We compute the absolute difference from the median: `|arr[i] - m|`
   - If the distances are the same, we then compare the elements' values directly.

3. **Sort by Strength**: We will sort the elements of the array based on their strengths, using the criteria specified: first by the absolute difference to the median in descending order, and if those are the same, by the element values in descending order.

4. **Select Top `k` Elements**: After sorting, we can simply take the first `k` elements from the sorted list to get the strongest values.

Here's how we can implement this in Python:



```python
class Solution:
    def getStrongest(self, arr: List[int], k: int) -> List[int]:
        # Step 1: Sort the array to find the median
        arr.sort()
        n = len(arr)
        
        # Step 2: Get the median, which is the middle element
        median = arr[(n - 1) // 2]
        
        # Step 3: Define a custom sorting key
        # We want to sort by strength first, and by value secondarily
        # The sort key is a tuple of (-strength, -value)
        arr_sorted = sorted(arr, key=lambda x: (abs(x - median), x), reverse=True)
        
        # Step 4: Return the first k elements
        return arr_sorted[:k]

# Example usage:
solution = Solution()
print(solution.getStrongest([1,2,3,4,5], 2))  # Example 1
print(solution.getStrongest([1,1,3,5,5], 2))  # Example 2
print(solution.getStrongest([6,7,11,7,6,8], 5))  # Example 3
print(solution.getStrongest([6,-3,7,2,11], 3))  # Example 4
print(solution.getStrongest([-7,22,17,3], 2))  # Example 5

```

### Explanation of the Code:
1. **Sorting the Array**: `arr.sort()` sorts the array to help find the median.
2. **Finding the Median**: The median is found using integer division to correctly access the middle element based on the array's length.
3. **Custom Sorting**: We use Python's `sorted()` function with a custom lambda function to create the sorting key based on:
   - The absolute distance from the median (for strength)
   - The element's value (to resolve ties)
   - We negate both components of the tuple because we want to sort in descending order.
4. **Return the Result**: Finally, we take the first `k` elements from the sorted list, which gives us the strongest values as required.

This implementation runs efficiently with a time complexity of O(n log n) due to the sorting step, which is manageable given the constraints.

# 1481. Least Number of Unique Integers after K Removals

### Problem Description 
Given an array of integers `arr` and an integer `k`. Find the least number of unique integers after removing exactly `k` elements.


Example 1:
Input: arr = [5,5,4], k = 1
Output: 1
Explanation: Remove the single 4, only 5 is left.


Example 2:
Input: arr = [4,3,1,1,3,3,2], k = 3
Output: 2
Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.


Constraints:
`1 <= arr.length <= 10^5`
`1 <= arr[i] <= 10^9`
`0 <= k <= arr.length`

### Solution 
 To solve the problem of determining the least number of unique integers left in an array after removing exactly `k` elements, we need to carefully choose which elements to remove in such a way that minimizes the count of unique integers remaining.

### Solution Explanation:

1. **Count Frequencies**: First, we utilize a frequency dictionary to count how many times each integer appears in the array. This helps us understand which numbers can be removed most efficiently.

2. **Heap or Sorting**: We can store the frequencies in a list and sort it. By sorting the frequencies, we can easily determine which integers to remove first, starting with those that have the least occurrences. This is helpful because if we remove integers with a lower frequency, we can reduce the total number of unique integers more effectively.

3. **Removing Elements**: We then iterate through the sorted frequency list and keep removing elements until we reach `k` removals. If an integer's frequency is less than or equal to the remaining `k`, we can remove that integer entirely and decrease the unique count. If `k` is still remaining after removing some integers, it means we can only partially remove the next integer.

4. **Count Remaining Uniques**: Finally, after having removed `k` elements, we can count how many unique numbers remain based on how many frequencies were completely removed.

Here’s how we can implement this solution in Python:



```python
from collections import Counter

class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
        # Count frequency of each integer in arr
        frequency = Counter(arr)
        
        # Get the frequencies sorted in ascending order
        freq_list = sorted(frequency.values())
        
        # Initialize the number of unique integers
        unique_count = len(freq_list)
        
        # Remove integers starting from the least frequent
        for f in freq_list:
            if k >= f:
                k -= f  # Reduce k by the frequency of the current element
                unique_count -= 1  # This unique integer is fully removed
            else:
                break  # There are more elements to remove than the current frequency

        return unique_count

```

### Key Points:
- We use `Counter` from the `collections` module to get a frequency map of the array elements.
- By sorting this frequency list, we ensure we are attempting to remove the least frequent integers first.
- The loop allows us to decrease `k` until we have removed the required number of elements or exhausted the list of unique integers.

### Complexity:
- **Time Complexity**: O(n log n) due to the sorting step and O(n) for counting the frequencies, where n is the length of the input array `arr`.
- **Space Complexity**: O(n) for storing the frequency counts.

This approach ensures that we efficiently minimize the number of unique integers left in the array after exactly `k` removals.

# 1491. Average Salary Excluding the Minimum and Maximum Salary

### Problem Description 
Given an array of unique integers `salary` where `salary[i]` is the salary of the employee `i`.

Return the average salary of employees excluding the minimum and maximum salary.


Example 1:
Input: salary = [4000,3000,1000,2000]
Output: 2500.00000
Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.

Average salary excluding minimum and maximum salary is (2000+3000)/2= 2500

Example 2:
Input: salary = [1000,2000,3000]
Output: 2000.00000
Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.

Average salary excluding minimum and maximum salary is (2000)/1= 2000

Example 3:
Input: salary = [6000,5000,4000,3000,2000,1000]
Output: 3500.00000

Example 4:
Input: salary = [8000,9000,2000,3000,6000,1000]
Output: 4750.00000

Constraints:
`3 <= salary.length <= 100`
`10^3 <= salary[i] <= 10^6`
`salary[i]` is unique.

Answers within `10^-5` of the actual value will be accepted as correct.

### Solution 
 Here's how you can solve the problem of finding the average salary of employees while excluding the minimum and maximum salaries in Python. Below is a detailed explanation, followed by the actual code formatted for submission on LeetCode.

### Explanation

1. **Problem Understanding**:
   - We need to calculate the average salary, excluding the lowest and highest salary from a salary list of unique integers.
   - The average should be calculated from the remaining salaries after removing the minimum and maximum values.

2. **Steps to Solve**:
   - **Find Minimum and Maximum Salaries**: We can use Python's built-in `min()` and `max()` functions to identify the lowest and highest salary.
   - **Compute the Sum of Remaining Salaries**: Subtract the minimum and maximum from the total sum of the salaries.
   - **Count Remaining Salaries**: After excluding the min and max, the count of remaining salaries will be the total count of salaries minus 2 (one for min and one for max).
   - **Calculate the Average**: Finally, the average is computed by dividing the sum of the remaining salaries by their count.

3. **Constraints Handling**: 
   - Given the constraints (`3 <= salary.length <= 100`), this algorithm runs efficiently within these bounds.

Here's how we can implement this in the LeetCode format:



```python
class Solution:
    def average(self, salary: List[int]) -> float:
        # Step 1: Find the minimum and maximum salary
        min_salary = min(salary)
        max_salary = max(salary)
        
        # Step 2: Calculate the sum of all salaries
        total_sum = sum(salary)
        
        # Step 3: Calculate the new sum by excluding min and max salaries
        adjusted_sum = total_sum - min_salary - max_salary
        
        # Step 4: Calculate the number of remaining salaries
        num_remaining = len(salary) - 2  # exclude min and max
        
        # Step 5: Calculate the average
        average_salary = adjusted_sum / num_remaining
        
        # Return the average salary
        return average_salary

```

### Code Explanation:
- We define a class `Solution` with a method `average` that takes a list of integers, `salary`.
- We calculate `min_salary` and `max_salary` using `min()` and `max()`.
- We then compute the total sum of the list with `sum()`.
- We adjust the total sum by subtracting both the `min_salary` and `max_salary`.
- We determine the number of salaries considered for the average by subtracting 2 from the total count of salaries.
- Finally, we return the average salary by dividing the adjusted sum by the count of remaining salaries.

### Conclusion
- This solution is efficient with a time complexity of O(n), where n is the number of salaries, and it efficiently meets the problem constraints.
- The returned result is in the required format and should pass all test cases within the provided tolerance on LeetCode.

# 1498. Number of Subsequences That Satisfy the Given Sum Condition

### Problem Description 
Given an array of integers `nums` and an integer `target`.

Return the number of non-empty subsequences of `nums` such that the sum of the minimum and maximum element on it is less or equal to `target`. Since the answer may be too large, return it modulo `109 + 7`.


Example 1:
Input: nums = [3,5,6,7], target = 9
Output: 4
Explanation: There are 4 subsequences that satisfy the condition.

[3] -> Min value + max value <= target (3 + 3 <= 9)
[3,5] -> (3 + 5 <= 9)
[3,5,6] -> (3 + 6 <= 9)
[3,6] -> (3 + 6 <= 9)

Example 2:
Input: nums = [3,3,6,8], target = 10
Output: 6
Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).

[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]

Example 3:
Input: nums = [2,3,3,4,6,7], target = 12
Output: 61
Explanation: There are 63 non-empty subsequences, two of them don't satisfy the condition ([6,7], [7]).

Number of valid subsequences (63 - 2 = 61).


Example 4:
Input: nums = [5,2,4,1,7,6,8], target = 16
Output: 127
Explanation: All non-empty subset satisfy the condition (2^7 - 1) = 127

Constraints:
`1 <= nums.length <= 105`
`1 <= nums[i] <= 106`
`1 <= target <= 106`

### Solution 
 To solve the problem of finding the number of non-empty subsequences of an array such that the sum of the minimum and maximum elements in the subsequence does not exceed a given target, we can employ a combination of sorting, the two-pointer technique, and the properties of powers of 2.

Here’s how to approach the problem step-by-step:

### Explanation

1. **Sorting the array**: By sorting the array `nums`, we can easily access the minimum (`nums[left]`) and maximum (`nums[right]`) elements of any subsequence formed between two indices.

2. **Using Two Pointers**: We initialize two pointers, `left` starting from the beginning (0) and `right` starting from the end of the array (length of `nums` - 1). We will check the sum of the elements at these pointers:
    - If `nums[left] + nums[right]` is less than or equal to `target`, it means all subsequences starting with elements from `left` to `right` are valid since the smallest is `nums[left]` and the largest is `nums[right]`. The number of such subsequences can be calculated as `2^(right - left)`.
    - If the condition is not satisfied, we need to move the right pointer to the left.

3. **Calculating Powers of Two**: To efficiently compute powers of two, especially for large numbers, we can use modular arithmetic with precomputed powers of 2 up to the maximum possible number of elements in the subsequence (which is at most `nums.length`).

4. **Result Calculation**: While iterating through the sorted array with the two pointers, we accumulate the count of valid subsequences and apply the modulo operation as necessary to manage large numbers.

### Code

Here’s the complete Python code that implements the above plan:



```python
class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        MOD = 10**9 + 7

        # Step 1: Sort the array
        nums.sort()
        
        # Step 2: Precompute powers of 2
        n = len(nums)
        pow2 = [1] * n
        for i in range(1, n):
            pow2[i] = (pow2[i - 1] * 2) % MOD
        
        # Step 3: Use two pointers
        left, right = 0, n - 1
        count = 0
        
        while left <= right:
            if nums[left] + nums[right] <= target:
                # Valid subsequences from nums[left] to nums[right]
                count = (count + pow2[right - left]) % MOD
                left += 1
            else:
                right -= 1
        
        return count

```

### Key Points

- **Complexity**: The sorting step takes `O(n log n)`, and the two-pointer traversal takes linear time `O(n)`. Thus, the overall time complexity is `O(n log n)`.
- **Space Complexity**: The space complexity is `O(n)` for storing the power of two calculations.
- **Modular Arithmetic**: We ensure that all arithmetic operations involving count are performed under modulo \(10^9 + 7\) to prevent overflow and abide by the problem's requirements.

The above solution effectively counts the valid subsequences by leveraging sorted order and the properties of combinations, making it efficient enough to handle the upper limits of the constraints given in the problem.

# 1502. Can Make Arithmetic Progression From Sequence

### Problem Description 
Given an array of numbers `arr`. A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.

Return `true` if the array can be rearranged to form an arithmetic progression, otherwise, return `false`.


Example 1:
Input: arr = [3,5,1]
Output: true
Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.


Example 2:
Input: arr = [1,2,4]
Output: false
Explanation: There is no way to reorder the elements to obtain an arithmetic progression.


Constraints:
`2 <= arr.length <= 1000`
`-10^6 <= arr[i] <= 10^6`

### Solution 
 To solve the problem of checking whether an array can be rearranged into an arithmetic progression, we need to follow these key steps:

1. **Sort the Array**: An arithmetic progression is characterized by having a constant difference between consecutive elements. Sorting the array allows us to easily compare these differences.

2. **Calculate the Common Difference**: Once sorted, calculate the difference between the first two elements, which will be the common difference for the arithmetic progression.

3. **Check Consecutive Differences**: Iterate through the sorted array and verify that each consecutive pair of elements has the same difference as the one calculated in the previous step.

4. **Return Result**: If all checks are passed, return `true`. Otherwise, return `false`.

Here's the Python code that implements this approach, formatted to run directly on LeetCode:



```python
class Solution:
    def canMakeArithmeticProgression(self, arr):
        # Step 1: Sort the array
        arr.sort()
        
        # Step 2: Calculate the common difference
        common_difference = arr[1] - arr[0]
        
        # Step 3: Check consecutive differences
        for i in range(1, len(arr) - 1):
            if arr[i + 1] - arr[i] != common_difference:
                return False  # If the difference is not equal, return false
        
        # Step 4: If all checks passed, return true
        return True

# Example Usage
# sol = Solution()
# print(sol.canMakeArithmeticProgression([3, 5, 1]))  # Output: True
# print(sol.canMakeArithmeticProgression([1, 2, 4]))  # Output: False

```

### Detailed Explanation:

- **Sorting**: The method `arr.sort()` arranges the elements in non-decreasing order. This process is essential as it ensures that we can directly calculate the difference between consecutive numbers.

- **Common Difference Calculation**: We store the difference between the first two sorted elements in `common_difference`. This will act as our benchmark for other differences.

- **Looping through the Array**: We use a `for` loop starting from index 1 up to `len(arr) - 1`. For each element, we check if the difference with the next element is equal to `common_difference`.

- **Returning the Result**: If we find any discrepancy in the differences, we immediately return `False`. If we successfully check all consecutive differences without issue, we return `True`.

### Time Complexity:
The sorting operation takes \(O(n \log n)\), and the subsequent loop takes \(O(n)\). Thus, the overall time complexity is dominated by the sorting step, which is \(O(n \log n)\).

### Space Complexity:
The sorting operation is done in-place, so the space complexity is \(O(1)\) if we do not count the input storage, but if we're considering the space taken by the sorting algorithm, it may vary depending on the Python implementation.

This code can be copied and directly tested on LeetCode to verify its correctness with the provided examples and additional test cases.

# 1508. Range Sum of Sorted Subarray Sums

### Problem Description 
Given the array `nums` consisting of `n` positive integers. You computed the sum of all non-empty continous subarrays from the array and then sort them in non-decreasing order, creating a new array of `n * (n + 1) / 2` numbers.

Return the sum of the numbers from index `left` to index `right` (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 10^9 + 7.


Example 1:
Input: nums = [1,2,3,4], n = 4, left = 1, right = 5
Output: 13 
Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. 

Example 2:
Input: nums = [1,2,3,4], n = 4, left = 3, right = 4
Output: 6
Explanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.


Example 3:
Input: nums = [1,2,3,4], n = 4, left = 1, right = 10
Output: 50

Constraints:
`1 <= nums.length <= 10^3`
`nums.length == n`
`1 <= nums[i] <= 100`
`1 <= left <= right <= n * (n + 1) / 2`

### Solution 
 To solve the problem of finding the sum of specific ranges in the sorted list of non-empty subarray sums, we can break down the solution into the following key steps:

1. **Calculate All Subarray Sums**: We need to compute the sum of all possible contiguous subarrays in the given `nums` array.
2. **Sort the Subarray Sums**: Once we have the subarray sums, we need to sort them to create a new array.
3. **Return the Sum of Specified Range**: Finally, we will sum the subarray sums from the specified indices (`left` to `right`).

### Implementation

Here is the python code that adheres to the LeetCode solution format:



```python
class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        MOD = 10**9 + 7
        
        # Step 1: Calculate all subarray sums
        subarray_sums = []
        
        for i in range(n):
            current_sum = 0
            for j in range(i, n):
                current_sum += nums[j]
                subarray_sums.append(current_sum)
        
        # Step 2: Sort the subarray sums
        subarray_sums.sort()
        
        # Step 3: Compute the sum from left to right (1-indexed)
        # Adjust indices since Python uses 0-indexing
        result_sum = sum(subarray_sums[left - 1:right]) % MOD
        
        return result_sum

```

### Detailed Explanation

1. **Initialization**:
   - We define a constant `MOD` as \(10^9 + 7\) to handle large numbers and avoid overflow.

2. **Finding All Subarray Sums**:
   - We iterate over the `nums` array using two nested loops. 
   - The outer loop (`i`) selects the starting index of the subarray, and the inner loop (`j`) iterates from the current starting index to the end of the list.
   - Inside the inner loop, we maintain a running total (`current_sum`) of the subarray starting at index `i` and ending at index `j`. This way, we compute and store all subarray sums in the list `subarray_sums`.

3. **Sorting the Subarray Sums**:
   - After collecting all subarray sums, we sort this list to arrange the sums in non-decreasing order.

4. **Calculating the Result**:
   - Since the problem specifies the indices as 1-based, we convert `left` and `right` to 0-based by subtracting 1 from each.
   - We then use the `sum()` function over the sliced part of the sorted subarray sums, and take the result modulo `MOD`.

5. **Return the Result**:
   - Finally, we return the computed sum.

### Complexity Analysis
- The overall time complexity is \(O(n^2 + k \log k)\), where \(O(n^2)\) is due to calculating the subarray sums (as there are \(\frac{n(n+1)}{2}\) subarrays) and \(O(k \log k)\) is for sorting the subarray sums (where \(k\) is the number of subarrays).
- The space complexity is \(O(k)\) as we store all the subarray sums.

This implementation is efficient for the given constraints. You can directly use this code on LeetCode to solve the specified problem.

# 1509. Minimum Difference Between Largest and Smallest Value in Three Moves

### Problem Description 
Given an array `nums`, you are allowed to choose one element of `nums` and change it by any value in one move.

Return the minimum difference between the largest and smallest value of `nums` after perfoming at most 3 moves.


Example 1:
Input: nums = [5,3,2,4]
Output: 0
Explanation: Change the array [5,3,2,4] to [2,2,2,2].

The difference between the maximum and minimum is 2-2 = 0.


Example 2:
Input: nums = [1,5,0,10,14]
Output: 1
Explanation: Change the array [1,5,0,10,14] to [1,1,0,1,1]. 
The difference between the maximum and minimum is 1-0 = 1.


Example 3:
Input: nums = [6,6,0,1,1,4,6]
Output: 2

Example 4:
Input: nums = [1,5,6,14,15]
Output: 1

Constraints:
`1 <= nums.length <= 10^5`
`-10^9 <= nums[i] <= 10^9`

### Solution 
 To solve the problem of finding the minimum difference between the largest and smallest values in an array after changing at most three elements, we can use the following approach:

### Explanation:

1. **Understanding the Problem**: 
   We can change up to three elements in the array `nums` to any value. Our goal is to minimize the difference between the maximum and minimum values in the modified array.

2. **Insight**: 
   To minimize the difference between the maximum and minimum after making changes, we can either:
   - Decrease the three largest values (if there are at least three elements).
   - Increase the three smallest values (if there are at least three elements).
   - A combination of both strategies, where we can change one from the top and two from the bottom, etc.

3. **Sort the Array**: 
   By sorting the array, we can easily access the smallest and largest values. This allows us to consider the different combinations of changing up to three values.

4. **Different Cases**: 
   Since we can change at most three values, we can evaluate the sorted array in the following ways:
   - Change no elements (not allowed by the problem specification but useful for boundary consideration).
   - Change the three largest elements.
   - Change two largest and one smallest.
   - Change one largest and two smallest.
   - Change the three smallest elements.

5. **Calculate Minimum Difference**: 
   After determining the possible cases based on the size of the array and the sorted values, we can compute the difference and keep track of the minimum.

### Implementation:

Here is the Python code implementing the outlined approach:



```python
class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        # Sort the array
        nums.sort()
        n = len(nums)

        # If there are 4 or fewer elements, we can make them all the same
        if n <= 4:
            return 0

        # Calculate possible differences after allowed changes
        # We consider changing the largest three, two largest + one smallest,
        # one largest + two smallest, or all three smallest
        return min(
            nums[n - 1 - 3] - nums[0],          # Change 3 largest
            nums[n - 1 - 2] - nums[1],          # Change 2 largest + 1 smallest
            nums[n - 1 - 1] - nums[2],          # Change 1 largest + 2 smallest
            nums[n - 1] - nums[3]               # Change 3 smallest
        )


```

### Key Points:
- We begin by sorting the array to easily access minimum and maximum values.
- We handle edge cases where the number of elements is less than or equal to 4 directly.
- We derive the minimum difference by considering the possible combinations of changing the largest and smallest elements.
- By examining these cases, we derive the required minimum difference.

### Complexity:
- The time complexity is \(O(n \log n)\) due to the sorting step, and the space complexity is \(O(1)\) (in terms of extra space used). This ensures the solution is efficient even for larger input sizes.

# 1528. Shuffle String

### Problem Description 
Given a string `s` and an integer array `indices` of the same length.

The string `s` will be shuffled such that the character at the `ith` position moves to `indices[i]` in the shuffled string.

Return the shuffled string.


Example 1:
Input: s = "codeleet", `indices` = [4,5,6,7,0,2,1,3]
Output: "leetcode"
Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.


Example 2:
Input: s = "abc", `indices` = [0,1,2]
Output: "abc"
Explanation: After shuffling, each character remains in its position.


Example 3:
Input: s = "aiohn", `indices` = [3,1,4,2,0]
Output: "nihao"

Example 4:
Input: s = "aaiougrt", `indices` = [4,0,2,6,7,3,1,5]
Output: "arigatou"

Example 5:
Input: s = "art", `indices` = [1,0,2]
Output: "rat"

Constraints:
`s.length == indices.length == n`
`1 <= n <= 100`
`s` contains only lower-case English letters.

`0 <= indices[i] < n`
All values of `indices` are unique (i.e. `indices` is a permutation of the integers from `0` to `n - 1`).

### Solution 
 To solve the problem of shuffling the string `s` according to the `indices` array, we can leverage a straightforward approach where we create a new list to hold the shuffled characters. This way, we can directly place each character of `s` at its new position specified by `indices`.

### Steps:
1. Initialize a list called `shuffled` with the same length as `s`, filled with placeholders (e.g., empty strings).
2. Iterate through each character in the string `s` along with its corresponding index from the `indices` array.
3. For each character `s[i]`, place it at the position specified by `indices[i]` in the `shuffled` list.
4. Finally, join the list into a string and return it.

### Python Code:
Here is the Python solution following the LeetCode format:



```python
class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        # Initialize a list with the same length as the string `s`
        shuffled = [''] * len(s)
        
        # Place each character at its new position
        for i in range(len(s)):
            shuffled[indices[i]] = s[i]
        
        # Join the list to create the final shuffled string
        return ''.join(shuffled)

```

### Explanation:
1. **Initialization**: We create a list called `shuffled` that has the same length as `s`, and we initialize it with empty strings. This will serve as the output list to hold characters in their new positions.
  
2. **Filling the shuffled list**:
   - We use a for loop that goes through each character of the string `s`. The `range(len(s))` function gives us indices from `0` to `n-1`.
   - For each index `i`, we set `shuffled[indices[i]]` to `s[i]`. Here `indices[i]` tells us the position where the character `s[i]` should go in the shuffled result.

3. **Creating the output**: After all characters are placed in their respective positions, we use `''.join(shuffled)` to combine the elements of the list into a single string, which is then returned.

### Complexity Analysis:
- **Time Complexity**: The time complexity is O(n), where n is the length of the string `s`. This is because we are iterating through the string and the indices once.
- **Space Complexity**: The space complexity is O(n) as well, due to the additional list `shuffled` that we are using to store the rearranged characters.

This implementation follows the constraints provided and ensures that the string is shuffled as required efficiently.

# 1630. Arithmetic Subarrays

### Problem Description 
A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence `s` is arithmetic if and only if `s[i+1] - s[i] == s[1] - s[0] `for all valid `i`.

For example, these are arithmetic sequences:
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic:
1, 1, 2, 5, 7
You are given an array of `n` integers, `nums`, and two arrays of `m` integers each, `l` and `r`, representing the `m` range queries, where the `ith` query is the range `[l[i], r[i]]`. All the arrays are 0-indexed.

Return a list of `boolean` elements `answer`, where `answer[i]` is `true` if the subarray `nums[l[i]], nums[l[i]+1], ... , nums[r[i]]` can be rearranged to form an arithmetic sequence, and `false` otherwise.


Example 1:
Input: nums = `[4,6,5,9,3,7]`, l = `[0,0,2]`, r = `[2,3,5]`
Output: `[true,false,true]`
Explanation:
In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.

In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.

In the 2nd query, the subarray is `[5,9,3,7]. This` can be rearranged as `[3,5,7,9]`, which is an arithmetic sequence.


Example 2:
Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
Output: [false,true,false,false,true,true]

Constraints:
`n == nums.length`
`m == l.length`
`m == r.length`
`2 <= n <= 500`
`1 <= m <= 500`
`0 <= l[i] < r[i] < n`
`-105 <= nums[i] <= 105`

### Solution 
 To solve the given problem of determining if subarrays can be rearranged to form arithmetic sequences, we can follow these steps:

1. **Understanding Arithmetic Sequence**: An arithmetic sequence is defined by the property that the difference between consecutive elements is constant. For instance, the differences `d` between the adjacent sorted elements should be the same.

2. **Using Sorting**: Since any rearrangement is allowed, if we sort the subarray, we can easily check the differences between its consecutive elements.

3. **Implementation Steps**:
   - For each query defined by indices `l[i]` and `r[i]`, extract the relevant subarray from `nums`.
   - Sort this subarray.
   - Calculate the difference between the first two elements and check that this difference remains the same as we check subsequent pairs.

4. **Return Results**: Store the results of whether each subarray can form an arithmetic sequence and return this list.

Let's implement this in Python following the LeetCode solution format:



```python
class Solution:
    def canMakeArithmeticProgression(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:
        answer = []
        
        # Process each query
        for i in range(len(l)):
            start_index = l[i]
            end_index = r[i] + 1  # r[i] is inclusive
            
            # Extract the relevant subarray and sort it
            subarray = sorted(nums[start_index:end_index])
            
            # Check if the sorted subarray can form an arithmetic sequence
            if len(subarray) < 2:
                answer.append(False)
                continue
            
            common_difference = subarray[1] - subarray[0]
            is_arithmetic = True
            
            for j in range(1, len(subarray) - 1):
                if subarray[j + 1] - subarray[j] != common_difference:
                    is_arithmetic = False
                    break
            
            answer.append(is_arithmetic)
        
        return answer

```

### Explanation of the Code:
- The `Solution` class contains the method `canMakeArithmeticProgression` which takes three parameters:
  - `nums`: The original list of integers.
  - `l`: List containing the start indices of the ranges.
  - `r`: List containing the end indices of the ranges.

- We initialize an empty list `answer` to keep track of the results for each query.

- We loop through each range defined by `l[i]` and `r[i]`, extracting the corresponding subarray:
  - The subarray is extracted using slicing (`nums[start_index:end_index]`). Note that `end_index` is inclusive.

- We sort the extracted subarray to ensure that we can easily compare consecutive elements.

- We check if the sorted subarray forms an arithmetic sequence:
  - We set the common difference using the first two elements and check it against all subsequent pairs.
  - If any pair does not match the common difference, we note that it cannot form an arithmetic sequence.

- Finally, we append the results (`True` or `False`) to the `answer` list and return it.

This approach ensures that we handle each query efficiently within the provided constraints. The code can be directly copied into the LeetCode environment and should run successfully.

# 1636. Sort Array by Increasing Frequency

### Problem Description 
Given an array of integers `nums`, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.

Return the sorted array.


Example 1:
Input: nums = [1,1,2,2,2,3]
Output: [3,1,1,2,2,2]
Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.


Example 2:
Input: nums = [2,3,1,3,2]
Output: [1,3,3,2,2]
Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.


Example 3:
Input: nums = [-1,1,-6,4,5,-6,1,4,1]
Output: [5,-1,4,4,-6,-6,1,1,1]

Constraints:
`1 <= nums.length <= 100`
`-100 <= nums[i] <= 100`

### Solution 
 To solve the problem of sorting an array of integers based on their frequency, we need to implement a specific approach. The steps include counting the frequency of each number, sorting them based on the custom criteria (frequency and then value), and finally assembling the result. Let's break this down step-by-step:

### Steps to Solve the Problem:
1. **Count Frequency**: Use the `collections.Counter` from Python's standard library to count the frequency of each element in the array `nums`.
2. **Sort Elements**: We will sort the elements based on two criteria:
   - First, by frequency (ascending order).
   - Second, by the number itself (in descending order) if frequencies are the same.
3. **Reconstruct the Result**: With the sorted elements, we will create a new sorted list based on the frequency and return it.

### Implementation:
Here’s the implementation of the above logic in Python, formatted to run on LeetCode:



```python
from collections import Counter

class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        # Count the frequency of each number in nums
        frequency = Counter(nums)
        
        # Sort the numbers based on frequency and then by the number itself in descending order
        sorted_nums = sorted(nums, key=lambda x: (frequency[x], -x))
        
        return sorted_nums

```

### Explanation:
1. **Counter**: We create a counter from the `nums` list, which counts how many times each element appears.
    - For example, for `nums = [1,1,2,2,2,3]`, `Counter(nums)` will give us `{1: 2, 2: 3, 3: 1}`.
  
2. **Sorting**: We use the `sorted()` function to sort the `nums`. The key for sorting is a tuple:
   - `frequency[x]`: This sorts the elements based on their frequency (ascending order).
   - `-x`: This sorts the elements based on their value in descending order whenever the frequencies are the same.
   - Thus, for `sorted([1,1,2,2,2,3], key=lambda x: (frequency[x], -x))`, it will result in `[3, 1, 1, 2, 2, 2]`.

3. **Return Result**: Finally, we return the newly sorted list.

### Complexity Analysis:
- **Time Complexity**: The time complexity for counting the frequency is O(n) where n is the number of elements in `nums`. Sorting takes O(n log n). Thus, the overall time complexity is O(n log n).
- **Space Complexity**: The space complexity is O(n) for storing the frequency count.

This solution efficiently follows the requirements provided and should work correctly for the constraints specified in the problem.

# 1637. Widest Vertical Area Between Two Points Containing No Points

### Problem Description 
Given `n` `points` on a 2D plane where `points[i] = [xi, yi]`, Return the widest vertical area between two points such that no points are inside the area.

A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.

Note that points on the edge of a vertical area are not considered included in the area.


Example 1:
​
Input: points = [[8,7],[9,9],[7,4],[9,7]]
Output: 1
Explanation: Both the red and the blue area are optimal.


Example 2:
Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]
Output: 3

Constraints:
`n == points.length`
`2 <= n <= 105`
`points[i].length == 2`
`0 <= xi, yi <= 109`

### Solution 
 To solve the problem of finding the widest vertical area between points on a 2D plane, we can follow a systematic approach. The goal is to determine the maximal width between two points such that no other points exist within that area.

Here’s a step-by-step breakdown of how we can achieve this:

### Explanation

1. **Vertical Area Definition**: A vertical area is defined by two x-coordinates. To have a vertical area between two points, we need to ensure that there is no point located between these two x-coordinates.

2. **Sorting Points**: To find the widest gap between points, we can simply sort the given points based on their x-coordinates. This allows us to directly look for gaps between consecutive points.

3. **Compute Gaps**: Once sorted, we compute the gap between every two consecutive points. The gap between two points \( p[i] \) and \( p[i+1] \) is \( p[i+1][0] - p[i][0] \).

4. **Find the Maximum Gap**: We maintain a variable to keep track of the maximum gap as we iterate through the sorted points.

5. **Output the Result**: The result will be the maximum gap we found during our iteration.

### Implementation

Now, let's put this logic into the required format for LeetCode:



```python
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        # Step 1: Sort the array of points based on their x-coordinates
        points.sort(key=lambda x: x[0])
        
        # Step 2: Initialize the maximum width variable
        max_width = 0
        
        # Step 3: Iterate through sorted points and calculate the gaps
        for i in range(1, len(points)):
            # The width is the difference of x-coordinates of consecutive points
            width = points[i][0] - points[i - 1][0]
            # Update max width if the current width is larger
            max_width = max(max_width, width)
        
        # Step 4: Return the maximum width found
        return max_width

```

### Run Directly on LeetCode

This code can be copied and pasted directly into the LeetCode coding platform. The class `Solution` and the method `maxWidthOfVerticalArea` follow the expected structure of LeetCode problems. The input `points` is expected to be a list of lists in the format described in the problem statement, and the code calculates the maximum width of vertical areas based on these points.

### Complexity Analysis

- **Time Complexity**: The time complexity is dominated by the sorting step, which is \( O(n \log n) \), where \( n \) is the number of points. The subsequent pass to compute the widths takes \( O(n) \).
- **Space Complexity**: The space complexity is \( O(1) \) if we disregard the space used for input storage, since we are only using a few additional variables.

This approach is efficient and suitable for the problem constraints.

# 1640. Check Array Formation Through Concatenation

### Problem Description 
You are given an array of distinct integers `arr` and an array of integer arrays `pieces`, where the integers in `pieces` are distinct. Your goal is to form `arr` by concatenating the arrays in `pieces` in any order. However, you are not allowed to reorder the integers in each array `pieces[i]`.

Return `true` if it is possible to form the array `arr` from `pieces`. Otherwise, return `false`.


Example 1:
Input: arr = [85], pieces = [[85]]
Output: true

Example 2:
Input: arr = [15,88], pieces = [[88],[15]]
Output: true
Explanation: Concatenate `[15]` then `[88]`

Example 3:
Input: arr = [49,18,16], pieces = [[16,18,49]]
Output: false
Explanation: Even though the numbers match, we cannot reorder pieces[0].


Example 4:
Input: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]
Output: true
Explanation: Concatenate `[91]` then `[4,64]` then `[78]`

Example 5:
Input: arr = [1,3,5,7], pieces = [[2,4,6,8]]
Output: false

Constraints:
`1 <= pieces.length <= arr.length <= 100`
`sum(pieces[i].length) == arr.length`
`1 <= pieces[i].length <= arr.length`
`1 <= arr[i], pieces[i][j] <= 100`
The integers in `arr` are distinct.

The integers in `pieces` are distinct (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).

### Solution 
 To solve the problem of determining if the array `arr` can be formed by concatenating parts from the `pieces` array, we need to ensure that we can find the elements of `arr` in the same order, using the groups defined in `pieces` without reordering those groups. 

Here's a breakdown of how to approach this problem:

1. **Create a Mapping**: First, we will create a dictionary to map the first element of each piece in `pieces` to the respective piece. This will allow us to quickly locate the appropriate piece when we encounter the first element of each contiguous segment.

2. **Traverse the Original Array**: Loop through the elements in `arr`. For each element, check if it can be matched with a piece:
   - If the element exists as a key in the mapping, retrieve the corresponding piece.
   - Verify that the subsequent elements in `arr` match the elements in the selected piece in the same order.

3. **Index Tracking**: Track the current index in `arr` as you build segments from `pieces`. If you successfully match all the segments without any mismatches or skipping, return True. Otherwise, return False.

The steps translate into the following Python code:



```python
def canFormArray(arr, pieces):
    # Step 1: Create a mapping from the first element of each piece to the piece itself
    piece_map = {piece[0]: piece for piece in pieces}

    # Step 2: Traverse through arr to check if we can form it using pieces
    i = 0
    while i < len(arr):
        # If the current element of arr can find a corresponding piece
        if arr[i] in piece_map:
            current_piece = piece_map[arr[i]]
            # Check if the elements match in order
            for num in current_piece:
                # If all elements of the piece match in arr
                if i < len(arr) and arr[i] == num:
                    i += 1  # Move to the next element in arr
                else:
                    # If there's a mismatch
                    return False
        else:
            # If there's no piece starting with arr[i]
            return False
            
    return True  # If all elements matched correctly

# Example test cases
print(canFormArray([85], [[85]]))  # True
print(canFormArray([15, 88], [[88], [15]]))  # True
print(canFormArray([49, 18, 16], [[16, 18, 49]]))  # False
print(canFormArray([91, 4, 64, 78], [[78], [4, 64], [91]]))  # True
print(canFormArray([1, 3, 5, 7], [[2, 4, 6, 8]]))  # False

```

### Explanation of the Code:
- We start by mapping the first elements of each subarray (piece) to their respective arrays for quick access.
- Using a while loop, we traverse `arr` to match segments denoted by `pieces`.
- For each segment, we check if all integers match in the specified order. If any element does not match or we cannot find a corresponding piece starting with the current integer, we return False immediately.
- If the loop successfully processes all elements in `arr`, we return True.

### Complexity Analysis:
- Time Complexity: O(n), where n is the number of elements in `arr`, since we are iterating through it with a linear pass.
- Space Complexity: O(m), where m is the number of pieces, to store the mapping of first elements to pieces.

This code meets all the criteria and constraints specified in the problem statement, ensuring its correctness and efficiency.

# 1647. Minimum Deletions to Make Character Frequencies Unique

### Problem Description 
A string `s` is called good if there are no two different characters in `s` that have the same frequency.

Given a string `s`, return the minimum number of characters you need to delete to make `s` good.

The frequency of a character in a string is the number of times it appears in the string. For example, in the string `"aab"`, the frequency of `'a'` is `2`, while the frequency of `'b'` is `1`.


Example 1:
Input: s = "aab"
Output: 0
Explanation: `s` is already good.


Example 2:
Input: s = "aaabbbcc"
Output: 2
Explanation: You can delete two 'b's resulting in the good string "aaabcc".

Another way it to delete one 'b' and one 'c' resulting in the good string "aaabbc".


Example 3:
Input: s = "ceabaacb"
Output: 2
Explanation: You can delete both 'c's resulting in the good string "eabaab".

Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).


Constraints:
`1 <= s.length <= 105`
`s` contains only lowercase English letters.

### Solution 
 To solve the problem of making the string `s` good by ensuring no two different characters have the same frequency, we can follow a systematic approach. Below, I will provide a complete Python solution that follows the LeetCode format, along with step-by-step explanations.

### Problem Breakdown

1. **Understanding frequencies**: We need to count how many times each character appears in the string `s`.

2. **Identifying conflicts**: A conflict arises when two or more characters have the same frequency. Our goal is to eliminate these conflicts by removing some of the characters, which entails counting how many deletions are necessary.

3. **Managing frequencies**: We can use a frequency counter to keep track of how many occurrences each character has. Then, we can utilize a set to track which frequencies are already encountered, modifying them as needed until all frequencies are unique.

### Steps to Solve

1. **Count character frequencies** using Python's `collections.Counter`.
2. **Track frequencies** using a set to ensure uniqueness.
3. **Adjust duplicate frequencies** by decrementing them and counting the number of deletions until all frequencies are unique.
4. **Return the total deletions** needed to achieve this.

### Implementation

Here's the Python code that implements the above logic:



```python
from collections import Counter

class Solution:
    def minDeletions(self, s: str) -> int:
        # Step 1: Count frequencies of each character in s
        frequency = Counter(s)
        
        # Step 2: Initialize a set to track unique frequencies
        unique_frequencies = set()
        
        # Step 3: Initialize the number of deletions needed
        deletions = 0
        
        # Step 4: Iterate over the character frequencies
        for freq in frequency.values():
            # Continue to adjust the frequency until it's unique
            while freq > 0 and freq in unique_frequencies:
                freq -= 1  # Decrease frequency
                deletions += 1  # Count the deletion needed
            
            if freq > 0:
                unique_frequencies.add(freq)  # Add the new unique frequency
        
        return deletions

```

### Explanation of the Code

1. **Counting Frequencies**: We use `Counter` from the `collections` module to obtain a dictionary-like object where keys are characters and values are their counts.

2. **Unique Frequencies Management**: We initialize an empty set to keep track of frequencies we have encountered. When we find that a frequency already exists, we reduce it by one (simulating a deletion) until it either reaches zero (indicating that it can be ignored) or becomes unique.

3. **Counting Deletions**: Each time we decrement a frequency, we increment our `deletions` counter.

4. **Final Output**: Once all frequencies are processed, we return the total number of deletions required to make `s` good.

### Complexity Analysis
- The time complexity is O(n), where n is the length of the string, due to the linear pass to count frequencies and another linear pass to manage uniqueness.
- The space complexity is O(1) with respect to the character set since we are only dealing with a fixed set of lowercase English letters (at most 26 characters).

The above code can be directly run on the LeetCode website under the problem statement provided.

# 1648. Sell Diminishing-Valued Colored Balls

### Problem Description 
You have an `inventory` of different colored balls, and there is a customer that wants `orders` balls of any color.

The customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color you currently have in your `inventory`. For example, if you own `6` yellow balls, the customer would pay `6` for the first yellow ball. After the transaction, there are only `5` yellow balls left, so the next yellow ball is then valued at `5` (i.e., the value of the balls decreases as you sell more to the customer).

You are given an integer array, `inventory`, where `inventory[i]` represents the number of balls of the `ith` color that you initially own. You are also given an integer `orders`, which represents the total number of balls that the customer wants. You can sell the balls in any order.

Return the maximum total value that you can attain after selling `orders` colored balls. As the answer may be too large, return it modulo `109 + 7`.


Example 1:
Input: inventory = [2,5], orders = 4
Output: 14
Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).

The maximum total value is 2 + 5 + 4 + 3 = 14.


Example 2:
Input: inventory = [3,5], orders = 6
Output: 19
Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).

The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.


Example 3:
Input: inventory = [2,8,4,10,6], orders = 20
Output: 110

Example 4:
Input: inventory = [1000000000], orders = 1000000000
Output: 21
Explanation: Sell the 1st color 1000000000 times for a total value of 500000000500000000. 500000000500000000 modulo 109 + 7 = 21.


Constraints:
`1 <= inventory.length <= 105`
`1 <= inventory[i] <= 109`
`1 <= orders <= min(sum(inventory[i]), 109)`

### Solution 
 To solve the problem of maximizing the total value of sold colored balls, we need to follow a strategy that allows us to sell the highest valued balls first. The approach involves using a greedy algorithm combined with a max-heap (priority queue) to efficiently select the highest valued balls available in inventory.

### Step-by-Step Explanation:

1. **Understanding the Problem**: The value of each colored ball is determined by the current count of balls of that color in the inventory. When we sell a ball, the value decreases by 1 for the next ball of that color. The goal is to maximize the total value obtained from selling a specified number of balls (`orders`).

2. **Using a Max-Heap**: Since we want to always sell the ball with the highest current value, we can utilize a max-heap. This allows us to easily retrieve and manage the highest valued ball available.

3. **Processing the Sales**:
   - Each time we sell a ball, we take the highest value from the heap, add it to our total value, and decrement the count of that color.
   - If a color still has balls left after the sale, we push the new value back to the heap.

4. **Stopping Condition**: We continue selling until we fulfill the total `orders` or we run out of balls in the heap.

5. **Modulo Operation**: Since the total value can be very high, we will take the result modulo \(10^9 + 7\) to avoid overflow and meet the problem's requirements.

Below is the Python code that implements this logic:



```python
import heapq

class Solution:
    def maxProfit(self, inventory: list[int], orders: int) -> int:
        MOD = 10**9 + 7
        
        # Create a max-heap from the inventory (using negative values because heapq is a min-heap by default)
        max_heap = [-x for x in inventory]
        heapq.heapify(max_heap)
        
        total_value = 0
        
        # Continue to fulfill orders
        while orders > 0:
            # Get the color with the maximum number of balls available
            current_value = -heapq.heappop(max_heap)  # Negate to get original value
            
            # Calculate how many we can sell from this color
            next_value = -max_heap[0] if max_heap else 0  # Peek at the next highest color
            
            # How many balls we can sell at the current value before hitting the number of balls left or orders remaining
            count_to_sell = min(orders, current_value - next_value)
            
            # Calculate the total value of these balls
            total_value += count_to_sell * current_value
            total_value %= MOD  # Maintain result within MOD
            
            # Update the number of orders
            orders -= count_to_sell
            
            # If there are still balls left in the current color, push the updated count back to the heap
            if current_value - count_to_sell > 0:
                heapq.heappush(max_heap, -(current_value - count_to_sell))
        
        return total_value

```

### Explanation of Key Components:
- **Heap Initialization**: We initialize a max-heap by negating the values since Python's `heapq` only provides a min-heap.
- **Main Loop**: Inside the loop, we manage the selling of balls, checking the maximum value available and determining how many can be sold given the limits of `orders` and the current ball quantities.
- **Total Value Calculation**: The total is aggregated while taking care of the modulo constraint.
  
### Performance:
This approach effectively maximizes the total value in O(N log N) time, where N is the number of unique colors in the inventory. The shift between the heaps supports efficient retrieval and updates as the inventory changes.

This code can be directly run on LeetCode, and it adheres to the constraints and requirements provided in the problem statement.

# 1691. Maximum Height by Stacking Cuboids

### Problem Description 
Given `n` `cuboids` where the dimensions of the `ith` cuboid is `cuboids[i] = [widthi, lengthi, heighti]` (0-indexed). Choose a subset of `cuboids` and place them on each other.

You can place cuboid `i` on cuboid `j` if `widthi <= widthj` and `lengthi <= lengthj` and `heighti <= heightj`. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.

Return the maximum height of the stacked `cuboids`.


Example 1:
Input: cuboids = [[50,45,20],[95,37,53],[45,23,12]]
Output: 190
Explanation:
Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.

Cuboid 0 is placed next with the 45x20 side facing down with height 50.

Cuboid 2 is placed next with the 23x12 side facing down with height 45.

The total height is 95 + 50 + 45 = 190.


Example 2:
Input: cuboids = [[38,25,45],[76,35,3]]
Output: 76
Explanation:
You can't place any of the cuboids on the other.

We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.


Example 3:
Input: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]
Output: 102
Explanation:
After rearranging the cuboids, you can see that all cuboids have the same dimension.

You can place the 11x7 side down on all cuboids so their heights are 17.

The maximum height of stacked cuboids is 6 * 17 = 102.


Constraints:
`n == cuboids.length`
`1 <= n <= 100`
`1 <= widthi, lengthi, heighti <= 100`

### Solution 
 To solve the problem of finding the maximum achievable height by stacking cuboids, we can break down the solution into specific steps using a dynamic programming approach. 

Here's a comprehensive plan:

1. **Normalization**: We first normalize each cuboid. Since we can rotate the cuboids, we sort the dimensions of each cuboid. This can help simplify comparisons without worrying about their orientations.

2. **Sorting**: After normalization, we sort the cuboids based on their dimensions. This way, we can easily determine valid cuboids to stack on top of each other based on their width, length, and height.

3. **Dynamic Programming Setup**: We can use a dynamic programming array `dp` where `dp[i]` represents the maximum height achievable with cuboid `i` at the base. Initially, the maximum height when only using the `i`th cuboid is simply its height.

4. **Height Calculation**: For each cuboid, we check whether placing it on top of previously considered cuboids is valid. If cuboid `i` can be placed on top of cuboid `j`, we update `dp[i]` to be the maximum of its current height or the height of `j` plus the height of `i`.

5. **Result Extraction**: Finally, the answer will be the maximum value in the `dp` array, which represents the tallest stack of cuboids possible.

Here is the Python code implementing the above logic in a LeetCode-compatible format:



```python
from typing import List

class Solution:
    def maxHeight(self, cuboids: List[List[int]]) -> int:
        # Normalize the cuboids by sorting dimensions
        for cuboid in cuboids:
            cuboid.sort()
        
        # Sort the cuboids based on the width, then length, then height
        cuboids.sort()

        n = len(cuboids)
        dp = [0] * n
        
        # Fill the dp array with the height of each individual cuboid
        for i in range(n):
            dp[i] = cuboids[i][2]  # height of the cuboid i

        # Build the dp array in style of Longest Increasing Subsequence
        for i in range(n):
            for j in range(i):
                # If cuboid j can be placed on cuboid i
                if (cuboids[i][0] >= cuboids[j][0] and
                    cuboids[i][1] >= cuboids[j][1] and
                    cuboids[i][2] >= cuboids[j][2]):
                    dp[i] = max(dp[i], dp[j] + cuboids[i][2])
        
        # The maximum height will be the maximum value in the dp array
        return max(dp)

# Example Usage:
# sol = Solution()
# print(sol.maxHeight([[50,45,20],[95,37,53],[45,23,12]]))  # Output: 190

```

### Explanation of the Code:
- **Cuboid Normalization**: For each cuboid, we sort the dimensions to facilitate easy comparisons.
- **Sorting**: We sort the list of cuboids so that we can apply the DP logic seamlessly.
- **Dynamic Programming Logic**: We initialize a `dp` array where each entry starts with the individual height of the cuboid. Then, we iterate over all pairs of cuboids to update the maximum heights based on stacking conditions.
- **Final Result**: The result is the highest value found in the `dp` array, which signifies the maximum height of stacked cuboids that can be formed.

This code adheres to the constraints and operates efficiently within the provided limits, guaranteeing optimal performance.

# 1697. Checking Existence of Edge Length Limited Paths

### Problem Description 
An undirected graph of `n` nodes is defined by `edgeList`, where `edgeList[i] = [ui, vi, disi]` denotes an edge between nodes `ui` and `vi` with distance `disi`. Note that there may be multiple edges between two nodes.

Given an array `queries`, where `queries[j] = [pj, qj, limitj]`, your task is to determine for each `queries[j]` whether there is a path between `pj` and `qj` such that each edge on the path has a distance strictly less than `limitj` .

Return a boolean array `answer`, where `answer.length == queries.length` and the `jth` value of `answer` is `true` if there is a path for `queries[j]` is `true`, and `false` otherwise.


Example 1:
Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
Output: [false,true]
Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.

For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.

For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.


Example 2:
Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
Output: [true,false]
Exaplanation: The above figure shows the given graph.


Constraints:
`2 <= n <= 105`
`1 <= edgeList.length, queries.length <= 105`
`edgeList[i].length == 3`
`queries[j].length == 3`
`0 <= ui, vi, pj, qj <= n - 1`
`ui != vi`
`pj != qj`
`1 <= disi, limitj <= 109`
There may be multiple edges between two nodes.

### Solution 
 To solve the problem of determining whether there exists a path between two nodes in an undirected graph such that all edges in the path have a weight strictly less than a given limit, we can use a union-find (disjoint-set union, DSU) data structure. This approach is efficient and works well for the limits provided.

### Explanation of the Approach:

1. **Sorting**: We first sort the `edgeList` by the weights of the edges. This allows us to efficiently manage the edges we add to the union-find structure.

2. **Union-Find Structure**: We will use a union-find data structure to keep track of connected components of the graph. This allows us to efficiently unify nodes and determine if two nodes are connected.

3. **Processing Queries**: We sort the queries based on the limit. For each query, we add all edges with weights less than the given limit to our union-find structure. After adding the appropriate edges, we check if the two nodes in the query are connected.

4. **Output**: For each query, we store the result (True or False) in an output array.

### Implementation:

Here’s how you can implement this solution in Python:



```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [1] * n
        
    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])  # Path compression
        return self.parent[u]
    
    def union(self, u, v):
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u != root_v:
            # Union by rank
            if self.rank[root_u] > self.rank[root_v]:
                self.parent[root_v] = root_u
            elif self.rank[root_u] < self.rank[root_v]:
                self.parent[root_u] = root_v
            else:
                self.parent[root_v] = root_u
                self.rank[root_u] += 1

def distanceLimitedPathsExist(n, edgeList, queries):
    # Step 1: Sort edges and queries
    edgeList.sort(key=lambda x: x[2])  # Sort edges by distance
    queries = [(p, q, limit, i) for i, (p, q, limit) in enumerate(queries)]
    queries.sort(key=lambda x: x[2])  # Sort queries by limit
    
    uf = UnionFind(n)
    answer = [False] * len(queries)
    edge_index = 0
    
    # Step 2: Process each query
    for p, q, limit, index in queries:
        # Union edges with distance < limit
        while edge_index < len(edgeList) and edgeList[edge_index][2] < limit:
            u, v, dis = edgeList[edge_index]
            uf.union(u, v)
            edge_index += 1
        
        # Step 3: Check if p and q are connected
        if uf.find(p) == uf.find(q):
            answer[index] = True
            
    return answer

```

### Explanation of the Code:

1. **UnionFind Class**: This class implements the union-find data structure with path compression and union by rank methods.

2. **distanceLimitedPathsExist Function**: This function handles the main logic:
   - We first sort the `edgeList` and `queries`.
   - For each query, we add all edges that have a weight less than the query's limit to our union-find structure by calling `union`.
   - Finally, we check if the nodes in the query belong to the same connected component by comparing their root parents using `find`, and we store the result.

### Complexity:
- Sorting the edge list takes \(O(E \log E)\).
- Sorting the queries takes \(O(Q \log Q)\).
- Each union or find operation is nearly constant time, \(O(\alpha(N))\), with \(\alpha\) being the inverse Ackermann function, which grows extremely slowly.

This implementation handles the constraints specified efficiently, and it can be run directly on the LeetCode platform.

# 1710. Maximum Units on a Truck

### Problem Description 
You are assigned to put some amount of boxes onto one truck. You are given a 2D array `boxTypes`, where `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]`:
`numberOfBoxesi` is the number of boxes of type `i`.

`numberOfUnitsPerBoxi` is the number of units in each box of the type `i`.

You are also given an integer `truckSize`, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed `truckSize`.

Return the maximum total number of units that can be put on the truck.


Example 1:
Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
Output: 8
Explanation: There are:
- 1 box of the first type that contains 3 units.

- 2 boxes of the second type that contain 2 units each.

- 3 boxes of the third type that contain 1 unit each.

You can take all the boxes of the first and second types, and one box of the third type.

The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.


Example 2:
Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
Output: 91

Constraints:
`1 <= boxTypes.length <= 1000`
`1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000`
`1 <= truckSize <= 106`

### Solution 
 To solve the problem of maximizing the number of units that can be loaded onto a truck given the constraints of box types and truck size, we can follow a greedy approach. 

### Problem Breakdown:
1. **Input Structure**: We are given a list of box types where each type specifies the number of boxes and units per box (`boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]`) and an integer that specifies the truck size (`truckSize`).
2. **Output Requirement**: We need to return the maximum total number of units that can be loaded onto the truck.
3. **Strategy**: Since we want to maximize the number of units, we should prioritize loading the boxes with more units per box first. This can be achieved by sorting the box types in descending order based on the units per box. Then, we can iterate through the sorted list and add boxes to the truck until we reach its maximum capacity.

### Implementation Steps:
1. Sort `boxTypes` based on the `numberOfUnitsPerBox` in descending order.
2. Initialize variables to keep track of the total units and the remaining capacity of the truck.
3. Loop through the sorted box types:
   - For each box type, determine how many boxes can be loaded onto the truck without exceeding its capacity.
   - Update the total units accordingly.
   - Deduct the number of boxes used from the truck's capacity.
4. Stop the process when the truck is full or we have considered all box types.

Here's the Python code to achieve this:



```python
class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        # Sort the boxTypes based on number of units per box in descending order
        boxTypes.sort(key=lambda x: x[1], reverse=True)

        total_units = 0
        
        for numberOfBoxes, numberOfUnitsPerBox in boxTypes:
            if truckSize <= 0:  # No capacity left in the truck
                break
            
            boxes_to_take = min(numberOfBoxes, truckSize)  # Take as many boxes as we can
            total_units += boxes_to_take * numberOfUnitsPerBox  # Calculate total units
            truckSize -= boxes_to_take  # Decrease the remaining capacity of the truck
        
        return total_units

```

### Explanation of the Code:
1. **Sorting**: We sort `boxTypes` using a custom key that orders the box types by `numberOfUnitsPerBox` in descending order. This allows us to prioritize which boxes to load based on the units they contribute.
2. **Looping through box types**: We iterate through each box type, checking how many boxes we can load depending on our remaining truck capacity and the available boxes of that type.
3. **Calculating total units**: For every box we decide to take, we calculate how many units that contributes by multiplying by the `numberOfUnitsPerBox`.
4. **Updating truck size**: After deciding how many boxes to load for that type, we adjust the `truckSize`.
5. **Return value**: Once the loop is complete, we return the `total_units` which represents the maximum units that can fit on the truck.

### Time Complexity:
The overall time complexity is O(n log n) due to the sorting process, where n is the number of different box types. The subsequent loop through the box types runs in O(n).

### Space Complexity:
The space complexity is O(1) if we exclude the input storage since no additional data structures that grow with input size are maintained.

# 1727. Largest Submatrix With Rearrangements

### Problem Description 
You are given a binary matrix `matrix` of size `m x n`, and you are allowed to rearrange the columns of the `matrix` in any order.

Return the area of the largest submatrix within `matrix` where every element of the submatrix is `1` after reordering the columns optimally.


Example 1:
Input: matrix = [[0,0,1],[1,1,1],[1,0,1]]
Output: 4
Explanation: You can rearrange the columns as shown above.

The largest submatrix of 1s, in bold, has an area of 4.


Example 2:
Input: matrix = [[1,0,1,0,1]]
Output: 3
Explanation: You can rearrange the columns as shown above.

The largest submatrix of 1s, in bold, has an area of 3.


Example 3:
Input: matrix = [[1,1,0],[1,0,1]]
Output: 2
Explanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.


Example 4:
Input: matrix = [[0,0],[0,0]]
Output: 0
Explanation: As there are no 1s, no submatrix of 1s can be formed and the area is 0.


Constraints:
`m == matrix.length`
`n == matrix[i].length`
`1 <= m * n <= 105`
`matrix[i][j]` is `0` or `1`.

### Solution 
 To solve the problem of finding the area of the largest submatrix of `1`s that can be formed by rearranging the columns of a binary matrix, we can leverage the following approach:

### Explanation:

1. **Understanding the Problem**:
   - We can rearrange the columns of the matrix, which means we can freely sort the rows of each column based on the number of consecutive `1`s below each particular `1`.
   - The largest rectangular area of `1`s in the rearranged matrix can then be computed.

2. **Matrix Transformation**:
   - We'll create a height array where each entry corresponds to the number of consecutive `1`s in that column up to the current row. For each cell in the matrix that contains `1`, we increase the height from the previous row; if it's `0`, we reset the height.
     
3. **Finding the Maximum Area**:
   - For each row, after calculating the heights, we can sort the heights in descending order. Then, we can compute the area of the rectangles that can be formed using the sorted heights. The area for the i-th height (given it's sorted) can be computed as `height[i] * (i + 1)` (which represents the base width).

4. **Complexity**:
   - The overall complexity is O(m * n * log(n)) due to the sorting step for every row, which is efficient enough given the constraints.

### Implementation:

Here is the code which you can run on LeetCode:



```python
class Solution:
    def largestSubmatrix(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0

        m, n = len(matrix), len(matrix[0])
        max_area = 0
        
        # Heights array
        heights = [[0] * n for _ in range(m)]
        
        # Building the height array
        for j in range(n):
            for i in range(m):
                # If the current cell is 1, we increase the height
                if matrix[i][j] == 1:
                    heights[i][j] = (heights[i-1][j] + 1) if i > 0 else 1
        
        # Now, calculate the maximum area
        for i in range(m):
            # Sort the current row's heights in descending order
            sorted_heights = sorted(heights[i], reverse=True)
            # Calculate the maximum area
            for k in range(n):
                max_area = max(max_area, sorted_heights[k] * (k + 1))
        
        return max_area

```

### Code Explanation:
1. **Initialization**: We first check if the matrix is empty. We then retrieve the dimensions `m` (number of rows) and `n` (number of columns). We initialize the `max_area` to zero.

2. **Building the Height Array**: We initialize a `heights` array of the same size as the input matrix. We iterate through each cell in the matrix and fill the `heights` based on the current value of the matrix and the height from the previous row.

3. **Calculating Maximum Area**: For each row in the `heights`, we sort the row in descending order. Then for each sorted height, we calculate the area it could represent and update the `max_area` if this area is larger.

4. **Return Value**: Finally, return the maximum area calculated.

This solution reformulates the matrix in a way that allows us to compute the largest rectangle of `1`s efficiently after rearrangement.

# 1772. Sort Features by Popularity

### Problem Description 
You are given a string array `features` where `features[i]` is a single word that represents the name of a feature of the latest product you are working on. You have made a survey where users have reported which features they like. You are given a string array `responses`, where each `responses[i]` is a string containing space-separated words.

The popularity of a feature is the number of `responses[i]` that contain the feature. You want to sort the features in non-increasing order by their popularity. If two features have the same popularity, order them by their original index in `features`. Notice that one response could contain the same feature multiple times; this feature is only counted once in its popularity.

Return the features in sorted order.


Example 1:
Input: features = ["cooler","lock","touch"], responses = ["i like cooler cooler","lock touch cool","locker like touch"]
Output: ["touch","cooler","lock"]
Explanation: appearances("cooler") = 1, appearances("lock") = 1, appearances("touch") = 2. Since "cooler" and "lock" both had 1 appearance, "cooler" comes first because "cooler" came first in the features array.


Example 2:
Input: features = ["a","aa","b","c"], responses = ["a","a aa","a a a a a","b a"]
Output: ["a","aa","b","c"]

Constraints:
`1 <= features.length <= 104`
`1 <= features[i].length <= 10`
`features` contains no duplicates.

`features[i]` consists of lowercase letters.

`1 <= responses.length <= 102`
`1 <= responses[i].length <= 103`
`responses[i]` consists of lowercase letters and spaces.

`responses[i]` contains no two consecutive spaces.

`responses[i]` has no leading or trailing spaces.

### Solution 
 To solve the problem of sorting features based on their popularity in user responses, we can follow a systematic approach. Here’s a concise plan:

1. **Count Popularity**: We will maintain a set for each feature to track which responses include that feature. The idea is to count unique appearances of each feature in the responses.

2. **Sort Features**: After counting the appearances of each feature, we will sort them by:
   - Popularity in descending order.
   - Original index in `features` in ascending order in case of ties.

3. **Return Sorted Features**: Finally, we will return the sorted list of features based on the above conditions.

### Implementation Details

1. **Use a Dictionary for Counting**: We can use a dictionary to map features to their respective counts of unique responses where they appear.
2. **Process Response Strings**: Each response will be split into a set of unique features, allowing us to update our count efficiently without counting duplicates within the same response.
3. **Sorting**: We'll sort with a custom key that takes both popularity and index into account.

Here’s how we can implement the solution in Python:



```python
from typing import List

class Solution:
    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:
        # Initialize a dictionary to hold unique counts of features
        popularity = {feature: 0 for feature in features}
        
        # Process each response
        for response in responses:
            # Split response into a set of words to handle unique appearances
            words = set(response.split())
            
            for feature in features:
                if feature in words:
                    popularity[feature] += 1
        
        # Prepare for sorting; convert to a list and sort by (popularity, original index)
        sorted_features = sorted(features, key=lambda x: (-popularity[x], features.index(x)))
        
        return sorted_features

# Example usage:
# sol = Solution()
# print(sol.sortFeatures(["cooler","lock","touch"], ["i like cooler cooler","lock touch cool","locker like touch"]))
# prints: ['touch', 'cooler', 'lock']

```

### Explanation of the Code:

- **Class Definition:** The class `Solution` encapsulates our method, adhering to LeetCode’s format.
- **Initialization:** A dictionary `popularity` is initialized to keep track of how many unique responses each feature appeared in.
- **Processing Responses:**
  - Each response string is split into words and converted to a set to ensure uniqueness.
  - We check if each feature is present in the response and increment its count if it is.
  
- **Sorting Logic:**
  - The list of features is sorted using Python’s built-in `sorted()` function, where:
    - We sort primarily by negative popularity (for descending order).
    - If there’s a tie in popularity, features are sorted by their original index in the `features` list to maintain their input order.
  
- **Returning Results:** Finally, the sorted list of features is returned.

This implementation effectively handles the given constraints and returns the desired sorted order of features efficiently.

