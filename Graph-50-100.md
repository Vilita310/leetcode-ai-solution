# 1730. Shortest Path to Get Food

### Problem Description 
You are starving and you want to eat food as quickly as possible. You want to find the shortest path to arrive at any food cell.

You are given an `m x n` character matrix, `grid`, of these different types of cells:
`'*'` is your location. There is exactly one `'*'` cell.

`'#'` is a food cell. There may be multiple food cells.

`'O'` is free space, and you can travel through these cells.

`'X'` is an obstacle, and you cannot travel through these cells.

You can travel to any adjacent cell north, east, south, or west of your current location if there is not an obstacle.

Return the length of the shortest path for you to reach any food cell. If there is no path for you to reach food, return `-1`.


Example 1:
Input: grid = [["X","X","X","X","X","X"],["X","*","O","O","O","X"],["X","O","O","#","O","X"],["X","X","X","X","X","X"]]
Output: 3
Explanation: It takes 3 steps to reach the food.


Example 2:
Input: grid = [["X","X","X","X","X"],["X","*","X","O","X"],["X","O","X","#","X"],["X","X","X","X","X"]]
Output: -1
Explanation: It is not possible to reach the food.


Example 3:
Input: grid = [["X","X","X","X","X","X","X","X"],["X","*","O","X","O","#","O","X"],["X","O","O","X","O","O","X","X"],["X","O","O","O","O","#","O","X"],["X","X","X","X","X","X","X","X"]]
Output: 6
Explanation: There can be multiple food cells. It only takes 6 steps to reach the bottom food.


Example 4:
Input: grid = [["O","*"],["#","O"]]
Output: 2

Example 5:
Input: grid = [["X","*"],["#","X"]]
Output: -1

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m, n <= 200`
`grid[row][col]` is `'*'`, `'X'`, `'O'`, or `'#'`.

The `grid` contains exactly one `'*'`.

### Solution 
 To solve the problem of finding the shortest path from the starting position (denoted by `'*'`) to any food cell (denoted by `'#'`) in a grid, we can utilize a breadth-first search (BFS) algorithm. The BFS algorithm is particularly suited for this task as it explores all possible paths level by level, ensuring that we find the shortest path first.

Here's how to implement this solution step by step in Python, following the LeetCode solution structure:



```python
from collections import deque
from typing import List

class Solution:
    def getFood(self, grid: List[List[str]]) -> int:
        # Define the directions for moving in the grid (up, down, left, right)
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        # Find the starting position
        start_x = start_y = -1
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '*':
                    start_x, start_y = i, j
                    break
            if start_x != -1:  # If we found the start position, break out of the outer loop
                break
        
        # Initialize the BFS queue with the starting position and a step count of 0
        queue = deque([(start_x, start_y, 0)])  # (x, y, steps)
        visited = set((start_x, start_y))  # Set to keep track of visited positions
        
        while queue:
            x, y, steps = queue.popleft()
            
            # Check if we reached a food cell
            if grid[x][y] == '#':
                return steps
            
            # Explore all possible directions
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                # Ensure we stay within the grid boundaries and don't visit obstacles
                if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited:
                    if grid[nx][ny] != 'X':  # Move only to free spaces and food cells
                        visited.add((nx, ny))  # Mark the new cell as visited
                        queue.append((nx, ny, steps + 1))  # Add the new cell to the queue with incremented step count

        # If we exhaust the queue without finding food, return -1
        return -1

```

### Explanation of the Code:
1. **Initialization**: 
   - We define the possible directions of movement in a list called `directions`.
   - We then iterate through the grid to find the starting position marked by `'*'`.

2. **BFS Setup**: 
   - We use a deque for our BFS queue to handle the cells we need to explore.
   - We also use a set called `visited` to track which cells we've already traversed to prevent cycles.

3. **BFS Execution**: 
   - While there are cells in the queue, we pop the front of the queue to process it.
   - We check if the current cell is a food cell, in which case we return the number of steps taken to get there.
   - If not, we explore all four possible movements (up, down, left, right). For each direction, we compute the new position and check if it's valid (within bounds and not an obstacle).
   - If valid, we add the new position to the queue and mark it as visited.

4. **Exit Condition**: 
   - If we finish exploring the queue and haven’t reached a food cell, we return `-1`, indicating no path exists to any food cell.

This solution has a time complexity of \(O(m \times n)\) due to visiting each cell once, where \(m\) is the number of rows and \(n\) is the number of columns in the grid. The space complexity is also \(O(m \times n)\) for the queue and visited set in the worst case.

# 1761. Minimum Degree of a Connected Trio in a Graph

### Problem Description 
You are given an undirected graph. You are given an integer `n` which is the number of nodes in the graph and an array `edges`, where each `edges[i] = [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`.

A connected trio is a set of three nodes where there is an edge between every pair of them.

The degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not.

Return the minimum degree of a connected trio in the graph, or `-1` if the graph has no connected trios.


Example 1:
Input: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]
Output: 3
Explanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.


Example 2:
Input: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]
Output: 0
Explanation: There are exactly three trios:
1) [1,4,3] with degree 0.

2) [2,5,6] with degree 2.

3) [5,6,7] with degree 2.


Constraints:
`2 <= n <= 400`
`edges[i].length == 2`
`1 <= edges.length <= n * (n-1) / 2`
`1 <= ui, vi <= n`
`ui != vi`
There are no repeated edges.

### Solution 
 To solve the problem of finding the minimum degree of a connected trio in an undirected graph, we can follow these steps:

### Steps to Solve the Problem:
1. **Graph Representation**: We’ll represent the graph using an adjacency list for efficient traversal. We’ll also keep track of the degrees of each node.
  
2. **Finding Connected Trios**: A connected trio involves three nodes that are completely interconnected. This means that for any three nodes (a, b, c), there are three edges: (a, b), (a, c), and (b, c). We can use a nested loop to go through all possible triplets of nodes and check if they are connected.

3. **Calculating Degrees**: For each connected trio found, we will compute its degree, which is defined as the number of edges that connect the trio nodes to other nodes outside the trio.

4. **Return the Minimum Degree**: After checking all possible trios, we return the minimum degree found. If no trios are found, we will return -1.

### Python Code

Here is the code implementing the above logic in a format suitable for LeetCode:



```python
class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        from collections import defaultdict
        
        # Create the adjacency list representation of the graph
        graph = defaultdict(set)
        degree = [0] * (n + 1)
        
        # Fill in the graph and degree array
        for u, v in edges:
            graph[u].add(v)
            graph[v].add(u)
            degree[u] += 1
            degree[v] += 1
        
        min_degree = float('inf')
        found = False
        
        # Check for every combination of three nodes
        for a in range(1, n + 1):
            for b in range(a + 1, n + 1):
                if b in graph[a]:  # There should be a connection between a and b
                    for c in range(b + 1, n + 1):
                        if c in graph[a] and c in graph[b]:  # Check if c is connected to both a and b
                            found = True
                            # Calculate the degree of the trio (a, b, c)
                            trio_degree = (degree[a] + degree[b] + degree[c] - 6)  # Subtract 3 for edges within trio
                            min_degree = min(min_degree, trio_degree)
        
        return min_degree if found else -1

```

### Explanation of the Code:
1. **Graph Construction**:
   - We use a `defaultdict` to create an adjacency list where each node points to a set of its neighbors.
   - The `degree` list keeps track of how many edges are connecting to each node.

2. **Finding Connected Trios**:
   - We use three nested loops to consider every triplet of nodes (a, b, c).
   - We check if `(a, b)`, `(a, c)`, and `(b, c)` are edges of the graph.

3. **Calculating Minimum Degree**:
   - If a connected trio is found, we calculate its degree.
   - We subtract 6 because each edge among the three nodes contributes to the degree counted three times, so we remove those three edges.

4. **Return Statement**:
   - If we found at least one trio, we return the minimum degree; otherwise, we return -1.

### Edge Cases:
- This code efficiently handles any graph setup specified in the problem constraints, including disconnected components of the graph.

# 1765. Map of Highest Peak

### Problem Description 
You are given an integer matrix `isWater` of size `m x n` that represents a map of land and water cells.

If `isWater[i][j] == 0`, cell `(i, j)` is a land cell.

If `isWater[i][j] == 1`, cell `(i, j)` is a water cell.

You must assign each cell a height in a way that follows these rules:
The height of each cell must be non-negative.

If the cell is a water cell, its height must be `0`.

Any two adjacent cells must have an absolute height difference of at most `1`. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).

Find an assignment of heights such that the maximum height in the matrix is maximized.

Return an integer matrix `height` of size `m x n` where `height[i][j]` is cell `(i, j)`'s height. If there are multiple solutions, return any of them.


Example 1:
Input: isWater = [[0,1],[0,0]]
Output: [[1,0],[2,1]]
Explanation: The image shows the assigned heights of each cell.

The blue cell is the water cell, and the green cells are the land cells.


Example 2:
Input: isWater = [[0,0,1],[1,0,0],[0,0,0]]
Output: [[1,1,0],[0,1,1],[1,2,2]]
Explanation: A height of 2 is the maximum possible height of any assignment.

Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.


Constraints:
`m == isWater.length`
`n == isWater[i].length`
`1 <= m, n <= 1000`
`isWater[i][j]` is `0` or `1`.

There is at least one water cell.

### Solution 
 To solve the problem, we can employ a breadth-first search (BFS) strategy. The main idea is to propagate from all water cells (cells with a height of 0) outwards into the land cells. As we traverse the cells, we can increment the height of the adjacent land cells while ensuring that the height difference between adjacent cells is at most 1.

### Steps to Solve the Problem:

1. **Initialization**: Create a height matrix of the same dimensions as `isWater` and fill it with zeros. Also, create a queue to facilitate the BFS, initializing it with all the water cells.

2. **BFS Approach**:
   - For each water cell, attempt to visit its adjacent cells (up, down, left, right).
   - If the adjacent cell is a land cell (height has not been assigned), we assign it a height of the current water cell's height + 1.
   - Add this newly assigned height cell to the queue for further processing.

3. **Continue the Process**: Repeat the propagation until all reachable land cells are assigned heights.

4. **Return the Result**: Once the BFS completes, we'll have a filled height matrix representing the heights according to the given constraints.

Here's the implementation of the above logic:



```python
from collections import deque

class Solution:
    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:
        m, n = len(isWater), len(isWater[0])
        
        # Create a result matrix initialized with -1 (unknown heights)
        height = [[-1] * n for _ in range(m)]
        
        # Create a queue for BFS
        queue = deque()
        
        # Initialize BFS with water cells
        for i in range(m):
            for j in range(n):
                if isWater[i][j] == 1:
                    height[i][j] = 0  # Water cell has height of 0
                    queue.append((i, j))  # Add to BFS queue
        
        # Directions for the four possible moves (up, down, left, right)
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        
        # Perform BFS
        while queue:
            x, y = queue.popleft()
            
            # Explore the neighbors
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                # Check bounds and whether the cell is land and not visited
                if 0 <= nx < m and 0 <= ny < n and height[nx][ny] == -1:
                    # Assign the height
                    height[nx][ny] = height[x][y] + 1
                    queue.append((nx, ny))  # Add new cell to the queue
        
        return height

```

### Explanation of Code:
- We start by defining the `highestPeak` function which takes the input matrix `isWater`.
- We use a deque (double-ended queue) for efficient removal from the front, where water cells are initially added.
- The BFS ensures that for each water cell, we learn its immediate land cell neighbors' heights by increasing the height by 1.
- We use a directions list to simplify neighbor traversal.
- The final result is stored in the `height` matrix and is returned after the BFS completes.

### Complexity Analysis:
- **Time Complexity**: O(m * n) since we potentially visit every cell once. 
- **Space Complexity**: O(m * n) for the height matrix and the queue.

This solution is efficient and straightforward for the given constraints.

# 1778. Shortest Path in a Hidden Grid

### Problem Description 
This is an interactive problem.

There is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size `m x n`, and each cell in the grid is either empty or blocked. It is guaranteed that the starting cell and the target cell are different, and neither of them is blocked.

You want to find the minimum distance to the target cell. However, you do not know the grid's dimensions, the starting cell, nor the target cell. You are only allowed to ask queries to the `GridMaster` object.

Thr `GridMaster` class has the following functions:
`boolean canMove(char direction)` Returns `true` if the robot can move in that direction. Otherwise, it returns `false`.

`void move(char direction)` Moves the robot in that direction. If this move would move the robot to a blocked cell or off the grid, the move will be ignored, and the robot will remain in the same position.

`boolean isTarget()` Returns `true` if the robot is currently on the target cell. Otherwise, it returns `false`.

Note that `direction` in the above functions should be a character from `{'U','D','L','R'}`, representing the directions up, down, left, and right, respectively.

Return the minimum distance between the robot's initial starting cell and the target cell. If there is no valid path between the cells, return `-1`.

Custom testing:
The test input is read as a 2D matrix `grid` of size `m x n` where:
`grid[i][j] == -1` indicates that the robot is in cell `(i, j)` (the starting cell).

`grid[i][j] == 0` indicates that the cell `(i, j)` is blocked.

`grid[i][j] == 1` indicates that the cell `(i, j)` is empty.

`grid[i][j] == 2` indicates that the cell `(i, j)` is the target cell.

There is exactly one `-1` and `2` in `grid`. Remember that you will not have this information in your code.


Example 1:
Input: grid = [[1,2],[-1,0]]
Output: 2
Explanation: One possible interaction is described below:
The robot is initially standing on cell (1, 0), denoted by the -1.

- master.canMove('U') returns true.

- master.canMove('D') returns false.

- master.canMove('L') returns false.

- master.canMove('R') returns false.

- master.move('U') moves the robot to the cell (0, 0).

- master.isTarget() returns false.

- master.canMove('U') returns false.

- master.canMove('D') returns true.

- master.canMove('L') returns false.

- master.canMove('R') returns true.

- master.move('R') moves the robot to the cell (0, 1).

- master.isTarget() returns true. 
We now know that the target is the cell (0, 1), and the shortest path to the target cell is 2.


Example 2:
Input: grid = [[0,0,-1],[1,1,1],[2,0,0]]
Output: 4
Explanation: The minimum distance between the robot and the target cell is 4.


Example 3:
Input: grid = [[-1,0],[0,2]]
Output: -1
Explanation: There is no path from the robot to the target cell.


Constraints:
`1 <= n, m <= 500`
`m == grid.length`
`n == grid[i].length`
`grid[i][j]` is either `-1`, `0`, `1`, or `2`.

There is exactly one `-1` in `grid`.

There is exactly one `2` in `grid`.

### Solution 
 To solve this problem, we need to implement a breadth-first search (BFS) strategy to traverse the grid based on the abilities provided by the `GridMaster` class. BFS is suitable here because it explores all possible paths in layers, ensuring that when we reach the target cell, we do so using the shortest path.

Here’s a detailed explanation of the steps we will take:

1. **Initialization**: We'll initialize our BFS queue and a set to keep track of visited cells to avoid cycles.

2. **Exploration**: For each cell, we will check the four possible directions (up, down, left, right) using the `canMove` method. If moving in that direction is allowed, we'll move into that cell and record it.

3. **Checking Target**: At each new cell, we'll check if it's the target with the `isTarget` method. If it is, we will return the distance.

4. **Handling the BFS**: We maintain the distance from the start position. When we successfully move to a new cell, we increment the distance.

5. **Termination**: If we exit the loop without finding the target, we return `-1`.

Here’s how you can implement this solution:



```python
class Solution:
    def minDistance(self, master: 'GridMaster') -> int:
        from collections import deque
        
        # Directions are ordered as (up, down, left, right)
        directions = ['U', 'D', 'L', 'R']
        d_row = [-1, 1, 0, 0]  # Corresponding row changes for U, D, L, R
        d_col = [0, 0, -1, 1]  # Corresponding column changes for U, D, L, R
        
        # BFS setup
        queue = deque([(0, 0, 0)])  # (row, col, distance)
        visited = set((0, 0))  # Set to track visited positions
        
        while queue:
            row, col, dist = queue.popleft()
            
            # Check if we've reached the target
            if master.isTarget():
                return dist
            
            # Try to move in all 4 directions
            for direction, dr, dc in zip(directions, d_row, d_col):
                # Check if the robot can move in the current direction
                if master.canMove(direction):
                    # Move in that direction
                    master.move(direction)
                    
                    # Calculate new position
                    new_row, new_col = row + dr, col + dc
                    
                    if (new_row, new_col) not in visited:
                        visited.add((new_row, new_col))
                        queue.append((new_row, new_col, dist + 1))
    
                    # After trying to move, we should move back to the original position
                    # to continue searching from there
                    if direction == 'U':
                        master.move('D')
                    elif direction == 'D':
                        master.move('U')
                    elif direction == 'L':
                        master.move('R')
                    elif direction == 'R':
                        master.move('L')
        
        return -1  # Return -1 if target not found

```

### Explanation of the Code:

- **Direction Handling**: We define movements using an array of directions and their respective row-column adjustments. This helps simplify directional movement.
  
- **Queue Initialization**: We start BFS from the position (0, 0) with an initial distance of 0. This will be adjusted as we traverse.

- **While Loop**: This loop continues until all possible paths are explored.
  
- **Target Check**: If `isTarget` returns true, we immediately return the current distance.

- **Direction Query**: For each direction, we check if movement is valid. Upon a successful move, we append the new position and increased distance to the queue.

- **Reversal of Moves**: After moving, we simulate a reverse move to ensure the robot returns to its previous position in order to explore new paths correctly.

This algorithm is efficient and will work within the constraints provided (a grid of up to size 500x500), as BFS is well-suited for such traversing problems.

# 1782. Count Pairs Of Nodes

### Problem Description 
You are given an undirected graph represented by an integer `n`, which is the number of nodes, and `edges`, where `edges[i] = [ui, vi]` which indicates that there is an undirected edge between `ui` and `vi`. You are also given an integer array `queries`.

The answer to the `jth` query is the number of pairs of nodes `(a, b)` that satisfy the following conditions:
`a < b`
`cnt` is strictly greater than `queries[j]`, where `cnt` is the number of edges incident to `a` or `b`.

Return an array `answers` such that `answers.length == queries.length` and `answers[j]` is the answer of the `jth` query.

Note that there can be repeated edges.


Example 1:
Input: n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
Output: [6,5]
Explanation: The number of edges incident to at least one of each pair is shown above.


Example 2:
Input: n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
Output: [10,10,9,8,6]

Constraints:
`2 <= n <= 2 * 104`
`1 <= edges.length <= 105`
`1 <= ui, vi <= n`
`ui != vi`
`1 <= queries.length <= 20`
`0 <= queries[j] < edges.length`

### Solution 
 To solve the problem of counting pairs of nodes in an undirected graph based on edge incident counts that exceed given queries, we can follow a systematic approach:

### Step-by-Step Explanation:

1. **Graph Representation**: We will first create an array to hold the degree of each node. The degree of a node is defined as the number of edges connected to that node.

2. **Counting Degrees**: For each edge provided, we will increment the degree count for both nodes involved in that edge.

3. **Counting Pairs**: We need to calculate the number of pairs `(a, b)` with `a < b` such that the maximum degree of the nodes in each pair is strictly greater than the specified query. This can be achieved efficiently by:
   - Sorting the degree array.
   - Using binary search strategies to quickly find the number of valid pairs for each query.

4. **Query Response**: For each query, we will determine the number of pairs where the maximum degree exceeds the value of the query. This can be derived by considering the sorted degree values and using cumulative counting.

Now, let's implement this logic in Python, following the format suitable for LeetCode.



```python
class Solution:
    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
        from collections import defaultdict
        from bisect import bisect_right
        
        # Step 1: Create degree count for each node
        degree_count = [0] * (n + 1)  # From 1 to n, so creating n + 1
        for u, v in edges:
            degree_count[u] += 1
            degree_count[v] += 1
            
        # Step 2: Sort the degree counts (ignoring index 0)
        degrees = sorted(degree_count[1:])
        
        # Step 3: Prepare answers for each query
        answers = []
        num_edges = len(edges)
        total_pairs = n * (n - 1) // 2  # Total pairs (a, b) with a < b
        
        for query in queries:
            # Get the cutoff degree
            cutoff = query
            # Find how many nodes have degree less than or equal to `cutoff`
            index = bisect_right(degrees, cutoff)
            valid_count = n - index  # Nodes that have degree > cutoff
            
            # Calculate valid pairs: choose any 2 from valid_count
            valid_pairs = valid_count * (valid_count - 1) // 2
            
            # The answer for this query will be total pairs minus invalid pairs
            answers.append(total_pairs - valid_pairs)

        return answers

```

### Explanation of the Code:
1. **Input Handling**: The function `countPairs` takes `n`, `edges`, and `queries` as inputs.
  
2. **Degree Calculation**: We maintain an array `degree_count` to keep track of the degree of each node. As we iterate through `edges`, we increment the degree count for both nodes involved.

3. **Sorting**: The degree list (ignoring index 0) is sorted to facilitate efficient counting of degrees above given query thresholds.

4. **Binary Search**: We use `bisect_right` from the `bisect` module to find how many nodes have degrees less than or equal to the current query degree. This allows us to calculate how many nodes exceed the query effectively.

5. **Pair Calculation**: For each valid count of nodes with degrees above the query, we calculate the number of valid `(a, b)` pairs and finally append results to the `answers` list.

### Complexity:
- The overall time complexity is dominated by the sorting step which is O(n log n) and the subsequent queries which each perform an O(log n) operation for binary search, resulting in an overall complexity of O(n log n + q log n) where `q` is the number of queries. This is efficient given the constraints. 

This code can be directly copied and run on LeetCode or any similar competitive programming environment that supports Python.

# 1786. Number of Restricted Paths From First to Last Node

### Problem Description 
There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes that there is an edge between nodes `ui` and `vi` with weight equal to `weighti`.

A path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2, ..., zk]` such that `z0 = start` and `zk = end` and there is an edge between `zi` and `zi+1` where `0 <= i <= k-1`.

The distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A restricted path is a path that also satisfies that `distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.

Return the number of restricted paths from node `1` to node `n`. Since that number may be too large, return it modulo `109 + 7`.


Example 1:
Input: n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
Output: 3
Explanation: Each circle contains the node number in black and its `distanceToLastNode value in blue. `The three restricted paths are:
1) 1 --> 2 --> 5
2) 1 --> 2 --> 3 --> 5
3) 1 --> 3 --> 5

Example 2:
Input: n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
Output: 1
Explanation: Each circle contains the node number in black and its `distanceToLastNode value in blue. `The only restricted path is 1 --> 3 --> 7.


Constraints:
`1 <= n <= 2 * 104`
`n - 1 <= edges.length <= 4 * 104`
`edges[i].length == 3`
`1 <= ui, vi <= n`
`ui != vi`
`1 <= weighti <= 105`
There is at most one edge between any two nodes.

There is at least one path between any two nodes.

### Solution 
 To solve this problem, we need to find all the restricted paths from node `1` to node `n` in an undirected weighted graph, where the number of nodes is given by `n` and the edges are specified in the provided `edges` list.

A restricted path `p` complies with the condition that for every consecutive pair of nodes in the path, the distance from `n` to the first node must be greater than the distance from `n` to the second node.

To achieve this, we can break down the solution into the following steps:

1. **Graph Representation**: We will represent the graph using an adjacency list.

2. **Distance Calculation**: We will compute the shortest distance from node `n` to all other nodes using Dijkstra's algorithm.

3. **DFS for Counting Paths**: After calculating the shortest distances, we utilize Depth-First Search (DFS) to count the number of restricted paths from node `1` to node `n`, ensuring we abide by the condition of distances.

4. **Dynamic Programming/Caching**: To prevent recomputing counts for previously visited nodes, we can cache results in a memoization dictionary.

5. **Result Modulo**: Since the answer may be large, we will return the results modulo \(10^9 + 7\).

Now, let's look at the implementation:



```python
import heapq
from collections import defaultdict

class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        MOD = 10**9 + 7
        
        # Build the graph as an adjacency list
        graph = defaultdict(list)
        for u, v, weight in edges:
            graph[u].append((v, weight))
            graph[v].append((u, weight))

        # Dijkstra's algorithm to find shortest paths from node n
        def dijkstra(start):
            distances = [float('inf')] * (n + 1)
            distances[start] = 0
            pq = [(0, start)]  # (distance, node)
            
            while pq:
                current_distance, current_node = heapq.heappop(pq)
                
                if current_distance > distances[current_node]:
                    continue
                
                for neighbor, weight in graph[current_node]:
                    distance = current_distance + weight
                    
                    if distance < distances[neighbor]:
                        distances[neighbor] = distance
                        heapq.heappush(pq, (distance, neighbor))
            
            return distances
        
        # Get the shortest distances from node n
        dist_from_n = dijkstra(n)
        
        # DFS with memoization to count restricted paths
        memo = {}
        
        def dfs(node):
            if node in memo:
                return memo[node]
            if node == n:
                return 1
            
            count = 0
            for neighbor, weight in graph[node]:
                if dist_from_n[node] > dist_from_n[neighbor]:  # Restricted condition
                    count = (count + dfs(neighbor)) % MOD
            
            memo[node] = count
            return count
        
        # Start the DFS from node 1
        return dfs(1)


```

### Detailed Explanation:

1. **Graph Representation**: A `defaultdict` of lists is used to store each node and its edges along with weights. This allows for easy traversal of the graph.

2. **Dijkstra's Algorithm**: This algorithm is implemented in the `dijkstra` function, which computes the shortest path from the node `n` to all other nodes. A priority queue (min-heap) is employed to efficiently get the next closest node.

3. **Depth-First Search (DFS)**: The `dfs` function recursively counts all valid paths from the current node to the target node `n`. It checks if moving to the neighboring node maintains the restricted path property.

4. **Memoization**: By storing previously computed results in `memo`, we avoid unnecessary recalculation and enhance the function's efficiency.

5. **Returning the Result**: Finally, the count of restricted paths is returned modulo \(10^9 + 7\).

This approach efficiently handles the constraints of the problem while ensuring correctness and adherence to the requirements specified.

# 1791. Find Center of Star Graph

### Problem Description 
There is an undirected star graph consisting of `n` nodes labeled from `1` to `n`. A star graph is a graph where there is one center node and exactly `n - 1` edges that connect the center node with every other node.

You are given a 2D integer array `edges` where each `edges[i] = [ui, vi]` indicates that there is an edge between the nodes `ui` and `vi`. Return the center of the given star graph.


Example 1:
Input: edges = [[1,2],[2,3],[4,2]]
Output: 2
Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center.


Example 2:
Input: edges = [[1,2],[5,1],[1,3],[1,4]]
Output: 1

Constraints:
`3 <= n <= 105`
`edges.length == n - 1`
`edges[i].length == 2`
`1 <= ui, vi <= n`
`ui != vi`
The given `edges` represent a valid star graph.

### Solution 
 To solve the problem of identifying the center of an undirected star graph, we can utilize the property of star graphs: there exists one node (the center) that is connected to all other nodes. Given that we have `n-1` edges, it guarantees that one node will have connections to every other node.

To implement a solution, we can:
1. Use a hash map (or dictionary in Python) to count the frequency of connections for each node. 
2. Iterate through the list of edges and for each edge, increment the count for both connected nodes in the dictionary.
3. After processing all edges, the node with the maximum count (which should be `n - 1` if it's the center) is the center of the star graph.

Let's implement this in the format suitable for LeetCode:



```python
class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        # A dictionary to count connections
        connection_count = {}
        
        # Iterate through each edge
        for u, v in edges:
            # Increase count for both nodes in the edge
            if u in connection_count:
                connection_count[u] += 1
            else:
                connection_count[u] = 1
            
            if v in connection_count:
                connection_count[v] += 1
            else:
                connection_count[v] = 1
        
        # The center node is the one that has `n - 1` connections
        n = len(edges) + 1  # Total nodes is edges + 1
        for node, count in connection_count.items():
            if count == n - 1:  # If the count is exactly n - 1, it's the center
                return node

# Example usage:
# solution = Solution()
# print(solution.findCenter([[1,2],[2,3],[4,2]]))  # Output: 2
# print(solution.findCenter([[1,2],[5,1],[1,3],[1,4]]))  # Output: 1

```

### Explanation:
1. **Input**: We receive a list of edges, where each edge connects two nodes.
2. **Data Structure**: We use a dictionary `connection_count` to keep track of how many edges are connected to each node.
3. **Counting Connections**: For each edge `(u, v)`, we increment the count of connections for both nodes `u` and `v`.
4. **Finding the Center**: Finally, we check which node has a count of `n - 1` (where `n` is the total number of nodes, calculated as `len(edges) + 1`), indicating that this node is connected to all other nodes.
5. **Return Value**: The node that fulfills the `n - 1` connection condition is returned as the center.

This code adheres to the required constraints of the problem, running efficiently in O(n) time, making it scalable for large inputs.

# 1810. Minimum Path Cost in a Hidden Grid

### Problem Description 
This is an interactive problem.

There is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size `m x n`, and each cell in the grid is either empty or blocked. It is guaranteed that the starting cell and the target cell are different, and neither of them is blocked.

Each cell has a cost that you need to pay each time you move to the cell. The starting cell's cost is not applied before the robot moves.

You want to find the minimum total cost to move the robot to the target cell. However, you do not know the grid's dimensions, the starting cell, nor the target cell. You are only allowed to ask queries to the `GridMaster` object.

The `GridMaster` class has the following functions:
`boolean canMove(char direction)` Returns `true` if the robot can move in that direction. Otherwise, it returns `false`.

`int move(char direction)` Moves the robot in that direction and returns the cost of moving to that cell. If this move would move the robot to a blocked cell or off the grid, the move will be ignored, the robot will remain in the same position, and the function will return `-1`.

`boolean isTarget()` Returns `true` if the robot is currently on the target cell. Otherwise, it returns `false`.

Note that `direction` in the above functions should be a character from `{'U','D','L','R'}`, representing the directions up, down, left, and right, respectively.

Return the minimum total cost to get the robot from its initial starting cell to the target cell. If there is no valid path between the cells, return `-1`.

Custom testing:
The test input is read as a 2D matrix `grid` of size `m x n` and four integers `r1`, `c1`, `r2`, and `c2` where:
`grid[i][j] == 0` indicates that the cell `(i, j)` is blocked.

`grid[i][j] >= 1` indicates that the cell `(i, j)` is empty and `grid[i][j]` is the cost to move to that cell.

`(r1, c1)` is the starting cell of the robot.

`(r2, c2)` is the target cell of the robot.

Remember that you will not have this information in your code.


Example 1:
Input: grid = [[2,3],[1,1]], r1 = 0, c1 = 1, r2 = 1, c2 = 0
Output: 2
Explanation: One possible interaction is described below:
The robot is initially standing on cell (0, 1), denoted by the 3.

- master.canMove('U') returns false.

- master.canMove('D') returns true.

- master.canMove('L') returns true.

- master.canMove('R') returns false.

- master.move('L') moves the robot to the cell (0, 0) and returns 2.

- master.isTarget() returns false.

- master.canMove('U') returns false.

- master.canMove('D') returns true.

- master.canMove('L') returns false.

- master.canMove('R') returns true.

- master.move('D') moves the robot to the cell (1, 0) and returns 1.

- master.isTarget() returns true.

- master.move('L') doesn't move the robot and returns -1.

- master.move('R') moves the robot to the cell (1, 1) and returns 1.

We now know that the target is the cell (0, 1), and the minimum total cost to reach it is 2. 

Example 2:
Input: grid = [[0,3,1],[3,4,2],[1,2,0]], r1 = 2, c1 = 0, r2 = 0, c2 = 2
Output: 9
Explanation: The minimum cost path is (2,0) -> (2,1) -> (1,1) -> (1,2) -> (0,2).


Example 3:
Input: grid = [[1,0],[0,1]], r1 = 0, c1 = 0, r2 = 1, c2 = 1
Output: -1
Explanation: There is no path from the robot to the target cell.


Constraints:
`1 <= n, m <= 100`
`m == grid.length`
`n == grid[i].length`
`0 <= grid[i][j] <= 100`

### Solution 
 To solve the problem of moving a robot in a hidden grid from a starting cell to a target cell while incurring certain costs, we can use a breadth-first search (BFS) approach. Since we don't know the size of the grid or the positions of the cells beforehand, our solution will involve iteratively querying the `GridMaster` class to understand our surroundings.

### Explanation of the Approach:

1. **Understanding Directions**: We'll define movements as an array of possible directions: Up, Down, Left, Right, and associate costs with moving in those directions.
  
2. **Initialization**: We'll keep track of visited cells to avoid revisiting them. A queue will help us implement the BFS approach, where we explore the least costly paths first. Our primary goal is to reach a cell that matches the target condition.

3. **BFS Implementation**: The BFS will involve:
   - Starting from the initial position.
   - Checking which moves are possible using `canMove()` method. 
   - Moving towards each direction using `move()` and updating the cumulative cost when successful.
   - If we reach the target cell (checked through `isTarget()`), we'll return the total cost incurred to reach there.
  
4. **Handling Blocked Cells**: If a move is not possible (returns `-1`), we simply ignore it without adding to the queue.

5. **Return Value**: If we exhaust all possibilities without reaching the target, we return `-1`.

### Python Code in LeetCode Style:

Here's how the code would look in a LeetCode format:



```python
class GridMaster:
    def canMove(self, direction: str) -> bool:
        pass

    def move(self, direction: str) -> int:
        pass

    def isTarget(self) -> bool:
        pass

from collections import deque

class Solution:
    def findMinimumCost(self, master: GridMaster) -> int:
        directions = ['U', 'D', 'L', 'R']
        direction_moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right
        
        # Queue for BFS - stores (current cost, x, y)
        queue = deque()
        queue.append((0, 0, 0))  # Start at the initial position
        
        visited = set()  # To remember visited positions
        visited.add((0, 0))
        min_cost = float('inf')
        
        while queue:
            cost, x, y = queue.popleft()
            
            # Check if we've reached the target
            if master.isTarget():
                return cost
            
            # Explore possible movements
            for i in range(4):
                if master.canMove(directions[i]):
                    # Move in this direction
                    move_cost = master.move(directions[i])
                    if move_cost != -1:  # Valid move
                        new_x, new_y = x + direction_moves[i][0], y + direction_moves[i][1]
                        
                        if (new_x, new_y) not in visited:  # Avoid revisiting
                            visited.add((new_x, new_y))
                            queue.append((cost + move_cost, new_x, new_y))
                        # If move didn't work to a new cell, we might be backtracking
                        # Therefore, we do not need to change `x` and `y`.
                    
        return -1  # If we exit the loop, it means target couldn't be reached

```

### Key Points:

- **Memory Management**: We use a set to track visited cells to avoid cycles and redundant checks which would inflate our search time.
- **Cost Calculation**: The cost is updated only when a successful move is made to a different cell.
- **Early Exit**: If the target is reached during any move, we return the cost immediately, optimizing our path discovery.

This approach reliably finds the minimal cost path to the target cell, assuming all methods of `GridMaster` function correctly as described in the problem statement.


# 1820. Maximum Number of Accepted Invitations

### Problem Description 
There are `m` boys and `n` girls in a class attending an upcoming party.

You are given an `m x n` integer matrix `grid`, where `grid[i][j]` equals `0` or `1`. If `grid[i][j] == 1`, then that means the `ith` boy can invite the `jth` girl to the party. A boy can invite at most one girl, and a girl can accept at most one invitation from a boy.

Return the maximum possible number of accepted invitations.


Example 1:
Input: grid = [[1,1,1],
               [1,0,1],
               [0,0,1]]
Output: 3
Explanation: The invitations are sent as follows:
- The 1st boy invites the 2nd girl.

- The 2nd boy invites the 1st girl.

- The 3rd boy invites the 3rd girl.


Example 2:
Input: grid = [[1,0,1,0],
               [1,0,0,0],
               [0,0,1,0],
               [1,1,1,0]]
Output: 3
Explanation: The invitations are sent as follows:
-The 1st boy invites the 3rd girl.

-The 2nd boy invites the 1st girl.

-The 3rd boy invites no one.

-The 4th boy invites the 2nd girl.


Constraints:
`grid.length == m`
`grid[i].length == n`
`1 <= m, n <= 200`
`grid[i][j]` is either `0` or `1`.

### Solution 
 To solve the problem of maximizing the number of acceptances for invitations from boys to girls based on a given constraint, we can view this as a bipartite matching problem. The matrix `grid` can be interpreted as a bipartite graph where boys and girls represent the two disjoint sets. If `grid[i][j] == 1`, it signifies an edge between boy `i` and girl `j`.

### Approach:
1. **Graph Representation**: We will represent the boys and girls as two sets in a bipartite graph.
2. **Bipartite Matching**: We will use Depth First Search (DFS) to find an augmenting path in the graph. This will allow us to "pair" boys with girls they can invite.
3. **Tracking Matches**: We will maintain a secondary array to keep track of which girl has been invited by which boy to ensure that girls can accept only one invitation.

### Implementation Steps:
- Iterate through each boy. For each boy, try to find a girl he can invite using DFS.
- If a girl is already paired with another boy, try to find a new match for that boy.
- Count every successful match to compute the maximum number of accepted invitations.



```python
class Solution:
    def maxInvitations(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        girl_matched = [-1] * n  # Tracks which boy each girl is currently matched with
        visited = [False] * m    # Tracks which boys have been visited in the current DFS

        def can_invit(boy: int) -> bool:
            for girl in range(n):
                if grid[boy][girl] == 1 and not visited[boy]:
                    visited[boy] = True  # Mark this boy as visited
                    if girl_matched[girl] == -1 or can_invit(girl_matched[girl]):
                        girl_matched[girl] = boy  # Match this girl with the current boy
                        return True
            return False

        max_invites = 0
        
        # Try to find matches for each boy
        for boy in range(m):
            visited = [False] * m  # Reset visited for a fresh DFS for each boy
            if can_invit(boy):
                max_invites += 1

        return max_invites

```

### Explanation:
1. The `girl_matched` list maintains the current pairing of girls to boys. A value of `-1` indicates that a girl has no current invitation.
2. The `can_invit(boy)` function performs DFS. For each girl the current boy can invite:
   - If the girl is not matched or if the boy matched with her can find another girl, we change the matching.
3. We reset the `visited` list for each boy to ensure that each DFS run is independent.
4. Finally, we sum the successful matches (invitations) and return that count.

### Complexity:
- **Time Complexity**: O(m * n), where `m` is the number of boys and `n` is the number of girls, since for each boy we might check each girl.
- **Space Complexity**: O(n) for storing the girl_matched array. The visited list also takes O(m) space but is reused across iterations.

### Conclusion:
This algorithm efficiently finds the maximum number of accepted invitations based on the constraints provided, structured in a way that works directly with the LeetCode platform.

