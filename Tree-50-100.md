# 450. Delete Node in a BST

### Problem Description 
Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:
Search for a node to remove.

If the node is found, delete the node.

Follow up: Can you solve it with time complexity `O(height of tree)`?

Example 1:
Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.

One valid answer is [5,4,6,2,null,null,7], shown in the above BST.

Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.


Example 2:
Input: root = [5,3,6,2,4,null,7], key = 0
Output: [5,3,6,2,4,null,7]
Explanation: The tree does not contain a node with value = 0.


Example 3:
Input: root = [], key = 0
Output: []

Constraints:
The number of nodes in the tree is in the range `[0, 104]`.

`-105 <= Node.val <= 105`
Each node has a unique value.

`root` is a valid binary search tree.

`-105 <= key <= 105`

### Solution 
 To solve the problem of deleting a node from a Binary Search Tree (BST) in Python, we need to follow some essential steps:

1. **Search for the Node:** Traverse the tree to find the node that contains the key we want to delete.
2. **Delete the Node:** Depending on the position of the node in the BST, there are three scenarios we need to handle:
   - The node is a leaf (no children).
   - The node has one child.
   - The node has two children (the most complex case).

The code should efficiently find and remove the node while maintaining the properties of the BST.

Below is the Python code that accomplishes this:

### Python Solution:


```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:
            return None
        
        # First, we perform the search for the node to delete
        if key < root.val:
            root.left = self.deleteNode(root.left, key)  # Go left
        elif key > root.val:
            root.right = self.deleteNode(root.right, key)  # Go right
        else:
            # Node found, now we need to delete it
            if not root.left:  # Node with only right child or no child
                return root.right
            elif not root.right:  # Node with only left child
                return root.left
            else:
                # Node with two children:
                # Find the minimum value node from the right subtree
                min_larger_node = self.getMin(root.right)
                root.val = min_larger_node.val  # Replace value
                root.right = self.deleteNode(root.right, min_larger_node.val)  # Delete the minimum node in right subtree

        return root
        
    def getMin(self, node: TreeNode) -> TreeNode:
        while node.left:
            node = node.left
        return node

```

### Explanation:
1. **TreeNode Class**: We create a simple class `TreeNode` that defines the structure of a node in the BST. Each node contains a value (`val`), a left child (`left`), and a right child (`right`).

2. **Solution Class**: We define the `Solution` class that includes two methods:
   - `deleteNode`: This method takes the root of the BST and the key to delete. It checks where the key resides in the tree and navigates accordingly using a recursive approach.
      - If the current node’s value is less than the key, it searches the right subtree.
      - If greater, it searches the left subtree.

3. **Deletion Logic**: When the node is found:
   - If the node has no children (leaf node), it simply returns `None`.
   - If it has one child, it returns the child, effectively removing the node.
   - If it has two children, it finds the minimum node in the right subtree (the successor), replaces the value of the current node with that value, and then recursively deletes the successor.

4. **getMin Method**: This helper method is utilized to find the node with the minimum value in a given subtree, which is crucial for handling the deletion of nodes with two children.

### Complexity:
The time complexity of this algorithm is `O(h)`, where `h` is the height of the tree. The space complexity is also `O(h)` due to the recursion stack.

This code can be run directly on LeetCode within the context of the problem and will work correctly for the provided examples and constraints.

# 501. Find Mode in Binary Search Tree

### Problem Description 
Given the `root` of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.

If the tree has more than one mode, return them in any order.

Assume a BST is defined as follows:
The left subtree of a node contains only nodes with keys less than or equal to the node's key.

The right subtree of a node contains only nodes with keys greater than or equal to the node's key.

Both the left and right subtrees must also be binary search trees.


Example 1:
Input: root = [1,null,2,2]
Output: [2]

Example 2:
Input: root = [0]
Output: [0]

Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`-105 <= Node.val <= 105`
Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).

### Solution 
 To solve the problem of finding the mode(s) in a binary search tree (BST) with duplicates, we will follow these steps:

1. **In-Order Traversal**: Perform an in-order traversal of the BST to get the values in sorted order. This is crucial because BST properties assure us that the in-order sequence is sorted, which makes counting duplicates easier.
  
2. **Count Frequencies**: As we traverse the tree, we will keep track of the current number, its count, and the maximum count found so far. If the current number matches the previous one, we increment its count. If it doesn't, we compare the count with the maximum count and update accordingly.

3. **Collect Modes**: Finally, based on the maximum count, we will collect all numbers that have this count as the modes.

Here's a Python code that implements the above plan in the LeetCode format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findMode(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        
        # Helper function for in-order traversal
        def in_order_traversal(node):
            if not node:
                return
            
            in_order_traversal(node.left)
            # Process current node
            if self.current_val == node.val:
                self.current_count += 1
            else:
                # Reset count for new value
                self.current_val = node.val
                self.current_count = 1
            
            if self.current_count > self.max_count:
                self.max_count = self.current_count
                self.modes = [self.current_val]
            elif self.current_count == self.max_count:
                self.modes.append(self.current_val)
                
            in_order_traversal(node.right)
        
        # Initialize variables for tracking
        self.current_val = None
        self.current_count = 0
        self.max_count = 0
        self.modes = []

        # Start in-order traversal
        in_order_traversal(root)
        return self.modes

```

### Explanation of the Code

1. **TreeNode Class**: This class defines the structure for nodes of the tree with attributes for value (`val`), left child (`left`), and right child (`right`).

2. **Solution Class**: This is the class where we define our method `findMode`.

3. **Initial Checks**: If the root is `None`, we return an empty list since there are no modes in an empty tree.

4. **Traversal Function**: We define a nested function `in_order_traversal` that uses recursion to perform an in-order traversal:
   - We traverse to the left child first, then process the current node, and finally traverse to the right child.
   - We use an `if-else` structure to count occurrences of each value using `self.current_val` and `self.current_count`. If the current node's value is the same as the last processed one, we increment the count. If it's a new value, we check if the previous count is greater than the `max_count` and update our modes accordingly.

5. **Tracking Modes**: We maintain a list `self.modes` which either gets the new mode when we find a larger count or appends to the list if we find another mode with the same count.

6. **Return Statement**: Finally, we return the `self.modes` which contains all the mode values in the tree.

### Performance
This solution runs in O(n) time complexity, where n is the number of nodes in the tree, since each node is processed exactly once. The space complexity is O(h), where h is the height of the tree, due to the recursive call stack.

With this implementation, you can submit this code on the LeetCode website directly to solve the problem successfully.

# 508. Most Frequent Subtree Sum

### Problem Description 
Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.


Examples 1
Input:
  5
 /  \
2   -3
return [2, -3, 4], since all the values happen only once, return all of them in any order.


Examples 2
Input:
  5
 /  \
2   -5
return [2], since 2 happens twice, however -5 only occur once.

Note:
You may assume the sum of values in any subtree is in the range of 32-bit signed integer.

### Solution 
 To solve the problem of finding the most frequent subtree sum in a binary tree, we can break down our approach into the following steps:

1. **Calculate the Subtree Sums**: We need to traverse the binary tree and compute the subtree sum for each node. The subtree sum for a node is defined as the sum of the node's value plus the sums of all its children.

2. **Count Frequencies**: For each calculated subtree sum, we will keep track of how many times each sum has occurred using a dictionary (or `collections.Counter`).

3. **Determine Most Frequent Sums**: At the end of our traversal, we will identify the maximum frequency of any subtree sum and collect all sums that occur at that maximum frequency.

4. **Return the Result**: Finally, we will return the sums that occurred with the highest frequency.

Here's the code that implements this logic in Python following the LeetCode solution format:



```python
from collections import defaultdict
from typing import List, Optional

# Definition for a binary tree node
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:
        # Dictionary to store the frequency of each subtree sum
        sum_count = defaultdict(int)

        def postorder(node: Optional[TreeNode]) -> int:
            if not node:
                return 0
            
            # Recursively calculate the subtree sums for left and right children
            left_sum = postorder(node.left)
            right_sum = postorder(node.right)
            subtree_sum = node.val + left_sum + right_sum
            
            # Update the count of this subtree sum
            sum_count[subtree_sum] += 1
            
            return subtree_sum
        
        # Calculate subtree sums starting from the root
        postorder(root)
        
        # Determine the maximum frequency
        max_count = max(sum_count.values())
        
        # Collect all sums that have the maximum frequency
        result = [s for s, count in sum_count.items() if count == max_count]
        
        return result

```

### Explanation of the Code:
1. **TreeNode Class**: This class is defined to create nodes of the binary tree. Each node has a value (`val`), a left child (`left`), and a right child (`right`).

2. **Solution Class**: This class contains the main method `findFrequentTreeSum` which is responsible for finding the most frequent subtree sums.

3. **sum_count Dictionary**: We use `defaultdict(int)` to automatically initialize counts for subtree sums. This will map each subtree sum to the number of times it has been calculated.

4. **Postorder Function**: This is a helper function that implements postorder traversal of the binary tree. It calculates the sum of the subtree rooted at each node, updates the frequency of the sum in `sum_count`, and returns the sum to its parent node.

5. **Calculating Maximum Frequency**: After all subtree sums are calculated, we find the highest frequency using `max(sum_count.values())`.

6. **Building the Result List**: We then collect all sums that match the maximum frequency into a result list, which is returned as the final output.

This approach ensures that we traverse the tree only once, resulting in a time complexity of O(N), where N is the number of nodes in the tree. The space complexity is O(N) in the worst case if all subtree sums are unique.

# 510. Inorder Successor in BST II

### Problem Description 
Given a `node` in a binary search tree, return the in-order successor of that node in the BST. If that node has no in-order successor, return `null`.

The successor of a `node` is the node with the smallest key greater than `node.val`.

You will have direct access to the node but not to the root of the tree. Each node will have a reference to its parent node. Below is the definition for `Node`:
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
}

Example 1:
Input: tree = [2,1,3], node = 1
Output: 2
Explanation: 1's in-order successor node is 2. Note that both the node and the return value is of Node type.


Example 2:
Input: tree = [5,3,6,2,4,null,null,1], node = 6
Output: null
Explanation: There is no in-order successor of the current node, so the answer is null.


Example 3:
Input: tree = [15,6,18,3,7,17,20,2,4,null,13,null,null,null,null,null,null,null,null,9], node = 15
Output: 17

Example 4:
Input: tree = [15,6,18,3,7,17,20,2,4,null,13,null,null,null,null,null,null,null,null,9], node = 13
Output: 15

Example 5:
Input: tree = [0], node = 0
Output: null

Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`-105 <= Node.val <= 105`
All Nodes will have unique values.

Follow up: Could you solve it without looking up any of the node's values?

### Solution 
 To solve the problem of finding the in-order successor of a given node in a binary search tree (BST) where each node has a reference to its parent, we can break down the solution into two main cases:

1. **If the node has a right child**: The successor will be the smallest node in the right subtree.
2. **If the node does not have a right child**: We need to traverse up the tree using the parent references until we find the first node which is the left child of its parent. The parent of that node will be the successor.

### Here's the implementation:



```python
class Node:
    def __init__(self, val=0, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent

class Solution:
    def inorderSuccessor(self, node: Node) -> Node:
        # Case 1: If there's a right child, the successor is the leftmost node of the right subtree
        if node.right:
            successor = node.right
            while successor.left:
                successor = successor.left
            return successor
        
        # Case 2: If there's no right child, travel up the tree
        while node.parent:
            if node.parent.left == node:
                return node.parent
            node = node.parent
        
        # If we reach here, it means there's no successor
        return None

```

### Explanation of the code:

1. **Node class**: A simple implementation of the `Node` class is provided, which contains the necessary attributes: `val` (value of the node), `left` (left child), `right` (right child), and `parent` (parent node).

2. **inorderSuccessor method**:
   - **Input**: It takes a `node` of type `Node`.
   - **Step 1** (Right Child Check): We first check if the given node has a right child. If it does, the successor will be found by continuously traversing to the leftmost node in that right subtree, as it contains the smallest value greater than `node.val`.
   - **Step 2** (No Right Child): If the node does not have a right child, we traverse up to its parent nodes. We look for the first parent node which is a left child of its parent. This implies that this parent is the smallest node with a value greater than `node.val`.
   - If we reach the top of the tree and do not find such a parent, there would be no successor, so we return `None`.

### Example Walkthroughs:

- **Example 1**: Given node `1`, it has the right child `2`. Since `2` is the leftmost node in the right subtree of `1`, the successor is `2`.

- **Example 2**: Given node `6`, there is no right child. As we travel up the tree from `6`, we find that it is the right child of its parent `5`, hence it has no valid successor, returning `None`.

- **Example 3**: Given node `15`, it has the right child `18`, but the smallest node greater than `15` is `17`, which is the leftmost node in the right subtree. Thus, the successor is `17`.

This concise implementation efficiently finds the in-order successor with a runtime complexity of O(h), where h is the height of the tree, which is optimal given the constraints. Additionally, since it does not require looking up any node values beyond the parent links, it adheres to the constraints of the problem.

# 513. Find Bottom Left Tree Value

### Problem Description 
Given the `root` of a binary tree, return the leftmost value in the last row of the tree.


Example 1:
Input: root = [2,1,3]
Output: 1

Example 2:
Input: root = [1,2,3,4,null,5,6,null,null,7]
Output: 7

Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`-231 <= Node.val <= 231 - 1`

### Solution 
 To solve the problem of finding the leftmost value in the last row of a binary tree, we can use a breadth-first search (BFS) approach. This method is effective because it explores the tree level by level, allowing us to easily keep track of the nodes at each level.

Here's a step-by-step breakdown of the solution:

1. **Use a Queue**: We will utilize a queue to facilitate our BFS. A queue allows us to process nodes in the same level before moving down to the next level.

2. **Traversal**: As we traverse the tree, we will keep track of the values of nodes at each level. The leftmost node of the last level can be identified during this traversal.

3. **Update the Leftmost Value**: Each time we fully process a level, we update our leftmost value to the first node we encounter at that level.

4. **Return the Result**: Once we have traversed all levels of the tree, the leftmost value stored will be the desired output.

Now, here's how this can be implemented in Python following the LeetCode format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

from collections import deque

class Solution:
    def findingBottomLeftValue(self, root: TreeNode) -> int:
        # Initialize a queue for BFS
        queue = deque([root])
        leftmost_value = 0  # Variable to hold the leftmost value

        # Perform BFS
        while queue:
            # Number of nodes at the current level
            level_size = len(queue)
            # Store the first value of this level
            for i in range(level_size):
                node = queue.popleft()
                
                # The first node at this level will be the leftmost
                if i == 0:
                    leftmost_value = node.val
                
                # Add child nodes to the queue
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        
        # After all levels are processed, return the leftmost value found
        return leftmost_value

```

### Explanation of the Code:
1. **TreeNode Class**: This is a basic structure class that represents a node in the binary tree, containing a value, and links to the left and right children.

2. **Solution Class**: Here, we define a method `findingBottomLeftValue` that takes the root of the binary tree as input and returns the leftmost value of the last row.

3. **BFS Implementation**:
   - We initialize a deque (double-ended queue) from the collections module to facilitate the queue operations.
   - We enqueue the root node to start the BFS traversal.
   - Inside a `while` loop, as long as there are nodes in the queue, we process each level:
     - We determine the `level_size` which tells us how many nodes are present at the current level.
     - We iterate through each node at the current level, popping them from the queue. The first node we pop at each level is assigned to `leftmost_value`.
     - Finally, we enqueue the left and right children of the node (if they exist) for processing in the next level.

4. **Return Statement**: After all levels have been processed, we return the `leftmost_value`, which will be the leftmost node of the last row in the binary tree.

This approach has a time complexity of O(N), where N is the number of nodes in the tree, and a space complexity of O(W), where W is the maximum width of the tree at any level (in the worst case it can be O(N) as well). This solution works efficiently within the constraints provided.

# 515. Find Largest Value in Each Tree Row

### Problem Description 
Given the `root` of a binary tree, return an array of the largest value in each row of the tree (0-indexed).


Example 1:
Input: root = [1,3,2,5,3,null,9]
Output: [1,3,9]

Example 2:
Input: root = [1,2,3]
Output: [1,3]

Example 3:
Input: root = [1]
Output: [1]

Example 4:
Input: root = [1,null,2]
Output: [1,2]

Example 5:
Input: root = []
Output: []

Constraints:
The number of nodes in the tree will be in the range `[0, 104]`.

`-231 <= Node.val <= 231 - 1`

### Solution 
 To solve the problem of finding the largest value in each row of a binary tree, we can use a level-order traversal (also known as breadth-first search) approach. When performing a level-order traversal, we can keep track of the maximum value found at each level as we iterate through the nodes of the tree. Here's how the solution works step-by-step:

### Step-by-step Explanation:

1. **Initialization**: Start by checking if the root of the tree is `None`. If it is, return an empty list since there are no nodes in the tree.

2. **Queue for Level Order Traversal**: Use a queue to help with the level-order traversal. We will use a deque from the collections module which allows appending and popping nodes efficiently.

3. **Iterate Over Levels**: While there are nodes to process in the queue:
   - Count the number of nodes at the current level.
   - Initialize a variable to keep track of the maximum value for this level.

4. **Process Each Node**: For each node at the current level:
   - Update the maximum value if the current node's value is greater than the stored maximum.
   - If the current node has left and right children, add them to the queue for processing in the next level.

5. **Store Results**: After processing all nodes for a level, append the maximum value found to the result list.

6. **Return the Result**: Finally, return the list that contains the maximum values from each level.

### Python Code:
Here is the code that implements the above logic in Python, formatted to be compatible with LeetCode:



```python
from collections import deque
from typing import List, Optional

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        result = []
        queue = deque([root])

        while queue:
            level_max = float('-inf')  # Initialize level max to the smallest integer
            level_size = len(queue)

            for _ in range(level_size):
                node = queue.popleft()  # Get the current node from the queue
                level_max = max(level_max, node.val)  # Update the max value at this level
                
                # Add children to the queue
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(level_max)  # Append the largest value for this level
        
        return result

```

### Explanation of the Code:
- **TreeNode Class**: This is a basic data structure for the nodes of the binary tree, where each node has a value and pointers to left and right children.
  
- **Solution Class**: The `largestValues` method accepts the root of the binary tree.
  
- `deque([root])`: Initializes the queue with the root node.
  
- The outer loop continues until there are no more nodes left in the queue. The inner loop iterates through the current level nodes, updating the maximum value found at that level. Each level's maximum value is appended to the `result` list.

- Finally, it returns the list containing the largest values from each row of the tree.

### Complexity Analysis:
- **Time Complexity**: O(N), where N is the number of nodes in the tree, because we traverse each node exactly once.
- **Space Complexity**: O(W), where W is the maximum width of the tree, due to the storage requirements of the queue.

This solution provides an efficient way to retrieve the largest values from each row of the binary tree using level-order traversal.

# 530. Minimum Absolute Difference in BST

### Problem Description 
Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.


Example:
Input:
   1
    \
     3
    /
   2
Output:
1
Explanation:
The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).

Note:
There are at least two nodes in this BST.

This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/

### Solution 
 To solve the problem of finding the minimum absolute difference between values of any two nodes in a binary search tree (BST), we can leverage the properties of a BST. In a BST, for any given node, the values in its left subtree are less than the node's value, and the values in its right subtree are greater. This property can be used to ensure that when we traverse the tree in-order (left-root-right), we get the node values in sorted order.

### Approach:

1. **In-Order Traversal:** By performing an in-order traversal of the BST, we can collect the values of the nodes in sorted order. This allows us to efficiently calculate the differences between consecutive values to find the minimum absolute difference.

2. **Calculate Differences:** As we traverse the sorted list of values, we compute the absolute differences between consecutive values. The minimum of these differences will be our answer.

3. **Implementation:** We can use a recursive function for in-order traversal. We'll maintain the previous node's value as we traverse and calculate the difference between the current node's value and the previous value.

### Time Complexity:
The time complexity of this solution is O(n), where n is the number of nodes in the BST, as we are traversing each node once.

### Space Complexity:
The space complexity is O(h), where h is the height of the tree due to the recursion stack. In the worst case (when the tree is unbalanced), it can become O(n).

Now let's implement the solution in the LeetCode format.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        # This will store the values of nodes in sorted order
        self.prev = -1
        self.min_diff = float('inf')
        
        # Define in-order traversal function
        def in_order(node):
            if not node:
                return
            
            # Traverse the left subtree
            in_order(node.left)
            
            # When visiting a node, we compare it with the previous node
            if self.prev != -1:
                # Calculate the difference with the previous value
                diff = node.val - self.prev
                self.min_diff = min(self.min_diff, diff)
            
            # Update the previous value to current node's value
            self.prev = node.val
            
            # Traverse the right subtree
            in_order(node.right)
        
        # Start the in-order traversal from the root
        in_order(root)
        
        # Return the minimum difference found
        return self.min_diff

```

### Explanation of the Code:
- We define a class `TreeNode` which represents a node in the binary tree.
- We then define the `Solution` class with a method `getMinimumDifference` that takes the root of the BST.
- We initialize `self.prev` to keep track of the last visited node's value and `self.min_diff` to store the minimum difference.
- The `in_order` function performs the in-order traversal recursively. It checks if the current node is not `None`, traverses the left subtree, compares the current node's value with `self.prev`, updates `self.min_diff` if the current difference is smaller, updates the previous value, and finally traverses the right subtree.
- After completing the traversal, the method returns the minimum absolute difference found.

This structured format should work correctly on LeetCode for the described problem.

# 536. Construct Binary Tree from String

### Problem Description 
You need to construct a binary tree from a string consisting of parenthesis and integers.

The whole input represents a binary tree. It contains an integer followed by zero, one or two pairs of parenthesis. The integer represents the root's value and a pair of parenthesis contains a child binary tree with the same structure.

You always start to construct the left child node of the parent first if it exists.


Example 1:
Input: s = "4(2(3)(1))(6(5))"
Output: [4,2,6,3,1,5]

Example 2:
Input: s = "4(2(3)(1))(6(5)(7))"
Output: [4,2,6,3,1,5,7]

Example 3:
Input: s = "-4(2(3)(1))(6(5)(7))"
Output: [-4,2,6,3,1,5,7]

Constraints:
`0 <= s.length <= 3 * 104`
`s` consists of digits, `'('`, `')'`, and `'-'` only.

### Solution 
 Certainly! Let's walk through a solution for constructing a binary tree from the given string representation in Python. We'll then format the solution to run directly on the LeetCode platform.

### Problem Analysis
The input string represents a binary tree where:
- An integer represents a node's value.
- Parentheses indicate the left and right children of the node.

The tree is constructed recursively:
1. Read the root value (which is purely numerical).
2. If an opening parenthesis `(` is found, it indicates the beginning of the left child.
3. If another opening parenthesis follows, it indicates the beginning of the right child after the left child.
4. Split the string accordingly to process the left and right subtrees.

### Implementation
To implement this, we will define a `TreeNode` class for the binary tree nodes. We will also define a function to parse the string and build the tree recursively.

Let's implement this step-by-step:

1. **Tree Node Definition**: We'll define a binary tree node using a class.
2. **String Parsing and Tree Construction**: We'll read the string and construct nodes recursively.
3. **Traversal or Collection of Values**: Finally, we will use a simple traversal to return the list of node values as required.

### Code

Here’s how we can implement this solution:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def recoverFromPreorder(self, s: str) -> List[int]:
        # Helper function to construct the tree from a string
        def build_tree(index):
            if index >= len(s):
                return None, index
            
            num = 0
            # Read the number
            while index < len(s) and s[index].isdigit():
                num = num * 10 + int(s[index])
                index += 1
            
            # Create the root node
            node = TreeNode(num)
            
            # Read the left child
            if index < len(s) and s[index] == '(':
                index += 1  # skip '('
                node.left, index = build_tree(index)
                index += 1  # skip ')'
            
            # Read the right child
            if index < len(s) and s[index] == '(':
                index += 1  # skip '('
                node.right, index = build_tree(index)
                index += 1  # skip ')'
            
            return node, index
        
        root, _ = build_tree(0)
        result = []
        
        # In-order traversal to collect the values
        def traverse(node):
            if not node:
                return
            traverse(node.left)
            result.append(node.val)
            traverse(node.right)
        
        traverse(root)
        return result

# Usage example
solution = Solution()
print(solution.recoverFromPreorder("4(2(3)(1))(6(5)(7))"))  # Output: [4, 2, 6, 3, 1, 5, 7]

```

### Explanation of the Code
1. **TreeNode Class**: We define a class `TreeNode` that holds the value and references to its left and right children.
2. **recoverFromPreorder Function**:
   - This function kicks off the tree construction, utilizing a helper function `build_tree`.
   - The `build_tree` function reads numbers to form node values and recursively constructs left and right children by checking for parentheses.
3. **Tree Traversal**: After constructing the tree, we perform an in-order traversal to collect the values into a list, which is returned as the final output.

### Complexity
- **Time Complexity**: \(O(n)\), where \(n\) is the length of the string, as we parse the string in a single pass to construct the tree.
- **Space Complexity**: \(O(h)\), where \(h\) is the height of the tree, due to the recursive stack used during construction.

You can run the provided code directly on LeetCode using the appropriate framework for binary trees and input parsing.

# 538. Convert BST to Greater Tree

### Problem Description 
Given the `root` of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.

As a reminder, a binary search tree is a tree that satisfies these constraints:
The left subtree of a node contains only nodes with keys less than the node's key.

The right subtree of a node contains only nodes with keys greater than the node's key.

Both the left and right subtrees must also be binary search trees.

Note: This question is the same as 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/

Example 1:
Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

Example 2:
Input: root = [0,null,1]
Output: [1,null,1]

Example 3:
Input: root = [1,0,2]
Output: [3,3,2]

Example 4:
Input: root = [3,2,4,1]
Output: [7,9,4,10]

Constraints:
The number of nodes in the tree is in the range `[0, 104]`.

`-104 <= Node.val <= 104`
All the values in the tree are unique.

`root` is guaranteed to be a valid binary search tree.

### Solution 
 To solve this problem, we need to convert the given Binary Search Tree (BST) into a Greater Tree, where each node's value is updated to the sum of its original value plus all values greater than its original value in the BST. 

To achieve this transformation, we can traverse the tree in reverse in-order (starting from the largest node and moving to the smallest), while maintaining a cumulative sum of the values we have seen so far. This way, when we visit a node, we can add the cumulative sum to its original value to obtain the updated value.

### Detailed Explanation:

1. **In-order Traversal**: Normally, an in-order traversal for a BST gives us values in ascending order (left-root-right). To sum greater values, we can perform a reverse in-order traversal (right-root-left), which gives us values in descending order.

2. **Cumulative Sum**: We maintain a variable (`accumulated_sum`) that keeps track of the sum of values we have already processed. When we visit a node, we add this `accumulated_sum` to the node's value and then update our `accumulated_sum` with this new value.

3. **Recursive Function**: This can be implemented using a helper function that we call recursively, starting from the root of the tree. We will pass the `accumulated_sum` as a list containing a single integer (so it is mutable) or as a nonlocal or global variable if you prefer.

### Implementation:

Here's how you can implement this in Python using the LeetCode solution format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        # Initialize the cumulative sum
        self.accumulated_sum = 0
        
        def traverse(node: TreeNode):
            if not node:
                return
            
            # Traverse the right subtree first (greater values)
            traverse(node.right)
            
            # Update the current node's value with the accumulated sum
            node.val += self.accumulated_sum
            
            # Update the accumulated sum
            self.accumulated_sum = node.val
            
            # Traverse the left subtree (smaller values)
            traverse(node.left)
        
        traverse(root)
        return root

```

### Explanation of the Code:

- We define a `TreeNode` class representing the nodes in the binary tree.
- The `Solution` class contains the `convertBST` method, which is called with the root of the tree.
- Inside `convertBST`, we initialize `self.accumulated_sum` to keep track of the cumulative sum.
- The `traverse` function performs the reverse in-order traversal:
  - It starts by traversing the right subtree to process greater values.
  - For each node, it updates its value by adding the `accumulated_sum`.
  - Then, it updates `self.accumulated_sum` to the new value of the node.
  - Finally, it traverses the left subtree.

### Complexity Analysis:

- **Time Complexity**: O(n), where n is the number of nodes in the tree, since each node is visited exactly once.
- **Space Complexity**: O(h), where h is the height of the tree. This is due to the recursion stack used in the traversal. In the worst case of a skewed tree, this could be O(n), but for a balanced tree, it would be O(log n).

This code can be run directly in the LeetCode environment. Ensure to define the `TreeNode` class as seen above for the tests to work correctly.

# 543. Diameter of Binary Tree

### Problem Description 
Given the `root` of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.

The length of a path between two nodes is represented by the number of edges between them.


Example 1:
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3is the length of the path [4,2,1,3] or [5,2,1,3].


Example 2:
Input: root = [1,2]
Output: 1

Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`-100 <= Node.val <= 100`

### Solution 
 To solve the problem of calculating the diameter of a binary tree, we can use a depth-first search (DFS) strategy. The idea is to traverse the tree, calculating the height of each subtree, while keeping track of the maximum diameter found during the traversal.

### Explanation:

1. **Definitions**:
   - The **diameter** of a binary tree is defined as the length of the longest path between any two nodes in the tree. The length of the path is counted as the number of edges.

2. **Approach**:
   - We'll define a recursive function that calculates the height of a subtree and update the maximum diameter as we compute the heights of the left and right subtrees for every node.
   - The height of a node is defined as the number of edges on the longest path from that node down to a leaf. 
   - For each node, the potential diameter can be calculated as the sum of the heights of its left and right subtrees.

3. **Implementation Steps**:
   - Create a helper function `dfs` that accepts a node as input and returns its height.
   - For each node:
     - Recursively calculate the height of the left and right children.
     - Update the maximum diameter using the sum of the left and right heights.
     - Return the current node's height to its parent.

4. **Base Case**:
   - If the node is `None`, we return 0 because the height of an empty subtree is 0.

Here’s how you can implement this in Python following LeetCode solution format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.diameter = 0  # Initialize diameter
        
        def dfs(node: TreeNode) -> int:
            if not node:
                return 0  # Base case: height of an empty node is 0
            
            left_height = dfs(node.left)  # Compute height of left subtree
            right_height = dfs(node.right)  # Compute height of right subtree
            
            # Update the diameter with the max value found
            self.diameter = max(self.diameter, left_height + right_height)
            
            # Return the height of the tree rooted at this node
            return max(left_height, right_height) + 1
        
        dfs(root)  # Trigger the dfs from the root
        return self.diameter  # Return the maximum diameter found

```

### Explanation of the Code:

- **TreeNode Class**: This is a simple class to represent each node in the binary tree, having `val`, `left`, and `right` attributes.
  
- **Solution Class**: This contains the main method `diameterOfBinaryTree` which initializes the `diameter` variable to keep track of the maximum diameter found.

- **dfs Function**: 
  - If the current node is `None`, the function returns a height of zero.
  - Otherwise, it calculates the heights of the left and right subtrees by calling `dfs` recursively.
  - It then updates the `self.diameter` by considering the sum of the left and right heights for the current node. The maximum of this value will give the longest path that passes through this node.
  - Finally, the function returns the height of the current node, which is `1 + max(left_height, right_height)`.

### Complexity:
- **Time Complexity**: O(N), where N is the number of nodes, since we traverse each node once.
- **Space Complexity**: O(H), where H is the height of the tree, due to the recursion stack.

This solution is efficient and works well within the constraints provided in the problem statement.

# 545. Boundary of Binary Tree

### Problem Description 
The boundary of a binary tree is the concatenation of the root, the left boundary, the leaves ordered from left-to-right, and the reverse order of the right boundary.

The left boundary is the set of nodes defined by the following:
The root node's left child is in the left boundary. If the root does not have a left child, then the left boundary is empty.

If a node in the left boundary and has a left child, then the left child is in the left boundary.

If a node is in the left boundary, has no left child, but has a right child, then the right child is in the left boundary.

The leftmost leaf is not in the left boundary.

The right boundary is similar to the left boundary, except it is the right side of the root's right subtree. Again, the leaf is not part of the right boundary, and the right boundary is empty if the root does not have a right child.

The leaves are nodes that do not have any children. For this problem, the root is not a leaf.

Given the `root` of a binary tree, return the values of its boundary.


Example 1:
Input: root = [1,null,2,3,4]
Output: [1,3,4,2]
Explanation:
- The left boundary is empty because the root does not have a left child.

- The right boundary follows the path starting from the root's right child 2 -> 4.

  4 is a leaf, so the right boundary is [2].

- The leaves from left to right are [3,4].

Concatenating everything results in [1] + [] + [3,4] + [2] = [1,3,4,2].


Example 2:
Input: root = [1,2,3,4,5,6,null,null,null,7,8,9,10]
Output: [1,2,4,7,8,9,10,6,3]
Explanation:
- The left boundary follows the path starting from the root's left child 2 -> 4.

  4 is a leaf, so the left boundary is [2].

- The right boundary follows the path starting from the root's right child 3 -> 6 -> 10.

  10 is a leaf, so the right boundary is [3,6], and in reverse order is [6,3].

- The leaves from left to right are [4,7,8,9,10].

Concatenating everything results in [1] + [2] + [4,7,8,9,10] + [6,3] = [1,2,4,7,8,9,10,6,3].


Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`-1000 <= Node.val <= 1000`

### Solution 
 Here's a Python solution that constructs the boundary of a binary tree as described in the problem. This solution can be directly implemented in the LeetCode environment. I'll follow the LeetCode solution format and provide detailed explanations for clarity.

### Python Code:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def boundaryOfBinaryTree(self, root: TreeNode) -> List[int]:
        if not root:
            return []

        def addLeftBoundary(node, boundary):
            if node is None or (node.left is None and node.right is None):
                return
            boundary.append(node.val)
            if node.left:
                addLeftBoundary(node.left, boundary)
            else:
                addLeftBoundary(node.right, boundary)

        def addLeaves(node, boundary):
            if node is None:
                return
            if node.left is None and node.right is None:
                boundary.append(node.val)
            addLeaves(node.left, boundary)
            addLeaves(node.right, boundary)

        def addRightBoundary(node, boundary):
            if node is None or (node.left is None and node.right is None):
                return
            if node.right:
                addRightBoundary(node.right, boundary)
            else:
                addRightBoundary(node.left, boundary)
            boundary.append(node.val)

        boundary = []
        boundary.append(root.val)  # Start with the root.

        # Add the left boundary
        addLeftBoundary(root.left, boundary)
        
        # Add leaves
        addLeaves(root, boundary)
        
        # Add the right boundary in reverse order
        right_boundary = []
        addRightBoundary(root.right, right_boundary)
        boundary.extend(reversed(right_boundary))

        return boundary

```

### Explanation:

1. **TreeNode Class**: This is the basic structure of a binary tree node, with attributes for the node's value and its left and right children.

2. **Solution Class**: This contains the main function `boundaryOfBinaryTree`.

3. **Boundary Construction**:
   - **Root**: The boundary always starts with the root's value, which we add to the `boundary` list immediately.

   - **Left Boundary** (`addLeftBoundary` function):
     - This function traverses the left side of the tree recursively.
     - If the node is not a leaf (a leaf has no children), we add its value to the boundary.
     - If a node has a left child, we continue with it; if it doesn't, we go to the right child.

   - **Leaves** (`addLeaves` function):
     - This function collects all leaf nodes in the tree.
     - If a node is a leaf (both left and right children are `None`), its value is added to the boundary.
     - The function recursively visits both left and right children to gather all leaves.

   - **Right Boundary** (`addRightBoundary` function):
     - This function behaves similarly to the left boundary, but we store the values in a temporary list called `right_boundary`.
     - We ensure that we traverse down the right side of the tree.
     - After collecting the right boundary values, we append them to the main boundary list in reverse order since we need them from bottom to top.

4. **Return Value**: Finally, we return the `boundary` list which contains the values in the correct order as specified: root + left boundary + leaves + reversed right boundary.

### Edge Cases Handled:
- An empty tree returns an empty list.
- The recursive functions handle nodes that are `None` and leaves correctly to ensure the boundary construction is robust.

This solution efficiently constructs the required binary tree boundary in O(n) time complexity, where n is the number of nodes in the tree, and uses O(h) additional space for the recursion stack, where h is the height of the tree.

# 549. Binary Tree Longest Consecutive Sequence II

### Problem Description 
Given the `root` of a binary tree, return the length of the longest consecutive path in the tree.

This path can be either increasing or decreasing.

For example, `[1,2,3,4]` and `[4,3,2,1]` are both considered valid, but the path `[1,2,4,3]` is not valid.

On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.


Example 1:
Input: root = [1,2,3]
Output: 2
Explanation: The longest consecutive path is [1, 2] or [2, 1].


Example 2:
Input: root = [2,1,3]
Output: 3
Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1].


Constraints:
The number of nodes in the tree is in the range `[1, 3 * 104]`.

`-3 * 104 <= Node.val <= 3 * 104`

### Solution 
 To solve the problem of finding the length of the longest consecutive path in a binary tree, we can employ a depth-first search (DFS) strategy. We'll define a recursive function that explores each node and keeps track of the lengths of increasing and decreasing consecutive paths as we traverse the tree. 

### Approach:
1. We're defining two sequences:
   - An increasing sequence, where the current node value is one more than the parent node value.
   - A decreasing sequence, where the current node value is one less than the parent node value.

2. For each node, we will check its left and right children:
   - For each child, if its value continues the increasing sequence, we increase the count of the length of the consecutive increasing path, otherwise reset it.
   - Similarly, we do the same for the decreasing path.

3. During the traversal, we will keep track of the maximum length obtained, which we will return once the entire tree has been traversed.

### Implementation:
We'll implement this in a class format to conform to LeetCode's format. We'll define a `TreeNode` class and our main solution will be inside a `Solution` class that has the `longestConsecutive` method.

Here is the complete code:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def longestConsecutive(self, root: TreeNode) -> int:
        def dfs(node, parent_val, length):
            if not node:
                return

            # If the current node continues the consecutive sequence
            if node.val == parent_val + 1:
                increasing = length[0] + 1
            else:
                increasing = 1
            
            # If the current node continues the decreasing sequence
            if node.val == parent_val - 1:
                decreasing = length[1] + 1
            else:
                decreasing = 1

            # Update the maximum length found so far
            self.max_length = max(self.max_length, increasing, decreasing)

            # Recur for left and right child
            dfs(node.left, node.val, [increasing, decreasing])
            dfs(node.right, node.val, [increasing, decreasing])

        self.max_length = 0
        dfs(root, float('inf'), [0, 0])  # Send an initial parent value that can't match any real node
        return self.max_length

```

### Explanation:
1. **TreeNode Class:** This class represents each node of the binary tree with a value (`val`), and pointers to its left (`left`) and right (`right`) children.
  
2. **Solution Class:**
   - `longestConsecutive`: This is the method that initializes the maximum length and starts the DFS.
   - It uses the `dfs` nested function to perform depth-first traversal. It keeps track of the current node, its parent value, and an array `length` to capture the lengths of increasing and decreasing sequences.

3. **DFS Algorithm:**
   - For each node, check if its value can extend the increasing or decreasing sequences and update the length counters accordingly.
   - Update the maximum consecutive length found so far after checking both sequences.
   - Call the `dfs` function recursively for the left and right children.

This solution efficiently calculates the longest consecutive path in both increasing and decreasing order while traversing the tree only once, resulting in a time complexity of O(N), where N is the number of nodes in the tree. The space complexity is O(H) where H is the height of the tree, due to the recursion stack space.

# 559. Maximum Depth of N-ary Tree

### Problem Description 
Given a n-ary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).


Example 1:
Input: root = [1,null,3,2,4,null,5,6]
Output: 3

Example 2:
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: 5

Constraints:
The depth of the n-ary tree is less than or equal to `1000`.

The total number of nodes is between `[0, 104]`.

### Solution 
 To solve the problem of finding the maximum depth of an n-ary tree, we can utilize a recursive depth-first search (DFS) approach. The key observation here is that for each node, the maximum depth can be determined by looking at the depth of its children and adding one to account for the current node. 

### Breakdown of the Approach:
1. **Base Case**: If the current node is `None`, return a depth of `0`.
2. **Recursive Case**: If the current node is not `None`, initialize a variable `max_depth` to zero. For each child of the current node, calculate the depth recursively and update `max_depth` if that depth is greater than the current `max_depth`.
3. Finally, return `max_depth + 1` to account for the current node itself.

### N-ary Tree Representation:
Each node in an n-ary tree can be represented by a class called `Node`, which contains a value and a list of children. The input for the tree will be provided in a specific format where nodes may have null values representing the end of a group of children.

Here's the solution in Python that follows the format expected by LeetCode:



```python
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

class Solution:
    def maxDepth(self, root: Node) -> int:
        # Base case: if the node is None, the depth is 0
        if root is None:
            return 0
        
        # If there are no children, depth is 1 (current node)
        if not root.children:
            return 1
        
        # Variable to store maximum depth
        max_depth = 0
        
        # Recursively calculate the depth for each child
        for child in root.children:
            child_depth = self.maxDepth(child)
            max_depth = max(max_depth, child_depth)
        
        # Return the maximum depth found plus one for the current node
        return max_depth + 1

# Example usage:
# Creating the n-ary tree from example 1
# Input: root = [1, null, 3, 2, 4, null, 5, 6]

# Function to construct the n-ary tree from the level order input (example helper function)
def construct_n_ary_tree(level_order):
    if not level_order:
        return None

    root = Node(level_order[0])
    queue = [root]
    i = 1
    
    while i < len(level_order):
        current = queue.pop(0)
        while i < len(level_order) and level_order[i] is not None:
            child = Node(level_order[i])
            current.children.append(child)
            queue.append(child)
            i += 1
        i += 1  # Skip the null value

    return root

# You can create an instance of the Solution class and test it with the constructed tree
# root = construct_n_ary_tree([1, None, 3, 2, 4, None, 5, 6])
# sol = Solution()
# print(sol.maxDepth(root))  # Output: 3

```

### Explanation of the Code:
- **Node Class**: Represents a node of the n-ary tree consisting of a value and a list of children.
- **maxDepth Method**: 
  - Checks if the node is `None`, returning a depth of 0.
  - If the node has no children, it returns 1 since it's a leaf node.
  - It iterates through each child of the node, recursively calculating and updating the maximum depth.
  - Finally, it returns `max_depth + 1` to account for the current node.
- **Helper Function**: `construct_n_ary_tree` constructs an n-ary tree from a given level order representation. 

This code can be executed on LeetCode by wrapping the logic in the provided function format, allowing for the problem to be directly addressable through the site's interface.

# 563. Binary Tree Tilt

### Problem Description 
Given the `root` of a binary tree, return the sum of every tree node's tilt.

The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as `0`. The rule is similar if there the node does not have a right child.


Example 1:
Input: root = [1,2,3]
Output: 1
Explanation: 
Tilt of node 2 : |0-0| = 0 (no children)
Tilt of node 3 : |0-0| = 0 (no children)
Tilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)
Sum of every tilt : 0 + 0 + 1 = 1

Example 2:
Input: root = [4,2,9,3,5,null,7]
Output: 15
Explanation: 
Tilt of node 3 : |0-0| = 0 (no children)
Tilt of node 5 : |0-0| = 0 (no children)
Tilt of node 7 : |0-0| = 0 (no children)
Tilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)
Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)
Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)
Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15

Example 3:
Input: root = [21,7,14,1,1,2,2,3,3]
Output: 9

Constraints:
The number of nodes in the tree is in the range `[0, 104]`.

`-1000 <= Node.val <= 1000`

### Solution 
 To solve the problem of finding the sum of every node's tilt in a binary tree, we can break down our approach into a few simple steps. We will traverse the tree using a postorder traversal strategy (visiting the left subtree, the right subtree, and then the node itself). During the traversal, we'll calculate the tilt for each node and also return the sum of values in that subtree for the parent node computation.

Here's a detailed breakdown of the steps we'll follow in our implementation:

1. **Understand the Tilt Calculation**: The tilt for a node is defined as the absolute difference between the sum of values in its left subtree and the sum of values in its right subtree.

2. **Postorder Traversal**: We will use a recursive helper function to perform a postorder traversal. This ensures we first calculate and return the sums of the left and right subtrees before calculating and returning the tilt of the parent node.

3. **Maintain a Tilt Sum**: We will keep a cumulative sum of all tilts in a variable that gets updated every time we calculate a node's tilt.

4. **Base Case for Recursion**: If a node is `None` (indicating that it's a leaf's child), we'll return a sum of `0`.

5. **Return Values**: Each recursive call will return the sum of values from the current subtree to the parent node.

Here's the implementation in Python following the LeetCode solution format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findTilt(self, root: TreeNode) -> int:
        self.total_tilt = 0  # This will hold the sum of all tilts
        
        def postorder(node: TreeNode) -> int:
            if not node:
                return 0  # If the node is None, return sum as 0
            
            # Recursively get the sum of the left and right subtrees
            left_sum = postorder(node.left)
            right_sum = postorder(node.right)
            
            # Calculate the tilt for the current node
            current_tilt = abs(left_sum - right_sum)
            self.total_tilt += current_tilt  # Update the total tilt
            
            # Return the total sum including the current node's value
            return left_sum + right_sum + node.val
        
        postorder(root)  # Start the postorder traversal from root
        return self.total_tilt  # Return the accumulated tilt sum


```

### Explanation of the Code:
1. **TreeNode Class**: We first define a `TreeNode` class to represent the nodes of the binary tree.

2. **Solution Class**: Inside the `Solution` class, we define a method `findTilt`.

3. **Total Tilt Variable**: We declare `self.total_tilt` to keep track of the cumulative tilt.

4. **Postorder Function**: 
   - It takes a node as an argument and checks if it's `None`.
   - It recursively computes the sums of the left and right subtrees.
   - The tilt of the current node is computed and added to `self.total_tilt`.
   - Finally, it returns the total sum of the subtree that includes the current node’s value.

5. **Starting Point**: We call the `postorder` function starting from the `root` of the tree.

6. **Returning Result**: Finally, we return the total tilt after completing the traversal.

This approach runs in O(N) time, where N is the number of nodes in the tree, as we visit each node exactly once. The space complexity is O(H) due to the recursion stack, where H is the height of the tree. If the tree is balanced, this is O(log N); in the worst case of a skewed tree, it becomes O(N).

# 572. Subtree of Another Tree

### Problem Description 
Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.


Example 1:
Given tree s:
     3
    / \
   4   5
  / \
 1   2
Given tree t:
   4 
  / \
 1   2
Return true, because t has the same structure and node values with a subtree of s.


Example 2:
Given tree s:
     3
    / \
   4   5
  / \
 1   2
    /
   0
Given tree t:
   4
  / \
 1   2
Return false.

### Solution 
 To solve the problem of determining whether one binary tree (t) is a subtree of another binary tree (s), we can take the following approach:

1. **Traverse Tree `s`:** We will perform a traversal of tree `s` and at each node, we will check if the subtree starting from that node matches tree `t`.
2. **Tree Comparison:** To check if two trees are identical (i.e., they have the same structure and node values), we will create a helper function that compares two trees.

The solution consists of the following main components:
- A function to check if two trees are identical.
- A function to traverse tree `s` and utilize the check for each node.

Below is the complete code written in Python for this solution, using the LeetCode solution format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        if not s:
            return False  # If s is None, t cannot be a subtree

        if self.isSameTree(s, t):
            return True  # Found a match

        # Recursively check left and right subtrees
        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)

    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True  # Both trees are empty
        if not p or not q:
            return False  # One tree is empty, and the other is not

        # Check current node's value and recursively check left and right children
        return (p.val == q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

# Example usage
# Construct example trees for s and t and call the isSubtree function.
# Note: This block is for local testing and won't be considered for submission to LeetCode.
# s = TreeNode(3)
# s.left = TreeNode(4)
# s.right = TreeNode(5)
# s.left.left = TreeNode(1)
# s.left.right = TreeNode(2)
#
# t = TreeNode(4)
# t.left = TreeNode(1)
# t.right = TreeNode(2)
#
# solution = Solution()
# print(solution.isSubtree(s, t))  # Output: True

```

### Explanation of the Code:

1. **TreeNode Definition:** We define a `TreeNode` class to create the nodes of the tree, which includes the value of the node and pointers to left and right child nodes.

2. **Solution Class:**
   - **isSubtree(s, t):** This method checks if tree `t` is a subtree of tree `s`. 
     - First, it checks if `s` is `None`. If `s` is empty, `t` can't be a subtree, and we return `False`.
     - Next, we check if the current node of `s` is identical to `t` using `isSameTree(s, t)`. If it is, we return `True`.
     - We then call `isSubtree` recursively on the left and right children of `s`.
  
   - **isSameTree(p, q):** This method checks if two trees `p` and `q` are identical.
     - Both trees are empty: return `True`.
     - One tree empty and the other not: return `False`.
     - Check if the values of current nodes (`p.val` and `q.val`) are equal, and recursively check their respective left and right children.

### Complexity:
- **Time Complexity:** O(N * M), where N is the number of nodes in tree `s`, and M is the number of nodes in tree `t`. In the worst case, we check each subtree in `s`.
- **Space Complexity:** O(H), where H is the height of the recursion stack, which can be the height of the trees in a skewed scenario.

# 582. Kill Process

### Problem Description 
You have `n` processes forming a rooted tree structure. You are given two integer arrays `pid` and `ppid`, where `pid[i]` is the ID of the `ith` process and `ppid[i]` is the ID of the `ith` process's parent process.

Each process has only one parent process but may have multiple children processes. Only one process has `ppid[i] = 0`, which means this process has no parent process (the root of the tree).

When a process is killed, all of its children processes will also be killed.

Given an integer `kill` representing the ID of a process you want to kill, return a list of the IDs of the processes that will be killed. You may return the answer in any order.


Example 1:
Input: pid = [1,3,10,5], ppid = [3,0,5,3], kill = 5
Output: [5,10]
Explanation: The processes colored in red are the processes that should be killed.


Example 2:
Input: pid = [1], ppid = [0], kill = 1
Output: [1]

Constraints:
`n == pid.length`
`n == ppid.length`
`1 <= n <= 5 * 104`
`1 <= pid[i] <= 5 * 104`
`0 <= ppid[i] <= 5 * 104`
Only one process has no parent.

All the values of `pid` are unique.

`kill` is guaranteed to be in `pid`.

### Solution 
 To solve the problem of identifying which processes will be killed when a specified process is terminated, we can model the processes as a tree structure. Each process has a unique ID and a parent ID, where the root process has a parent ID of 0. When a process is killed, we need to ensure all its children processes are also killed.

Here's a Python solution for this problem following the LeetCode format:

### Approach:
1. **Build the Tree**: Create a dictionary to represent the tree, where each key is a process ID and the value is a list of child process IDs.
2. **Depth-First Search (DFS)**: We can use DFS to traverse the tree, starting from the process we want to kill, and collect all the IDs of the processes to be killed.
3. **Return the Result**: After the DFS completes, we return the list of killed processes.

### Detailed Explanation:
- We read the `pid` and `ppid` arrays to build a mapping of each process to its children.
- We identify the process ID we want to kill and initiate a DFS from that process.
- During the DFS, we add the current process ID to our result list and recursively traverse to all its child processes.

Here is the Python code implementing the above logic:



```python
class Solution:
    def killProcess(self, pid: List[int], ppid: List[int], kill: int) -> List[int]:
        from collections import defaultdict
        
        # Step 1: Build the tree representation via a hashmap
        children = defaultdict(list)
        for i in range(len(pid)):
            if ppid[i] != 0:  # We only consider non-root processes
                children[ppid[i]].append(pid[i])
        
        # Step 2: Define a DFS function to retrieve all processes to be killed
        def dfs(process_id):
            # Add current process ID to the list of killed processes
            killed_list = [process_id]
            # Recur for all children of the current process
            for child in children[process_id]:
                killed_list.extend(dfs(child))
            return killed_list
        
        # Step 3: Start DFS from the process that needs to be killed
        return dfs(kill)

# This code is ready to be used in a LeetCode submission.

```

### Explanation of the Code:
- We use `defaultdict` from the `collections` module to easily create a list of children for each parent process.
- The `dfs` function recursively processes each child and aggregates the list of killed processes.
- Finally, we invoke the `dfs` function with the `kill` process ID, which produces the full list of all processes that will be killed when `kill` is terminated.

### Complexity Analysis:
- **Time Complexity**: O(n), where n is the number of processes. Each process is visited once when building the tree and once during DFS.
- **Space Complexity**: O(n) for storing the tree structure and the list of killed processes.

This code can be submitted directly to LeetCode to solve the given problem.

# 590. N-ary Tree Postorder Traversal

### Problem Description 
Given the `root` of an n-ary tree, return the postorder traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

Example 1:
Input: root = [1,null,3,2,4,null,5,6]
Output: [5,6,3,2,4,1]

Example 2:
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]

Constraints:
The number of nodes in the tree is in the range `[0, 104]`.

`0 <= Node.val <= 104`
The height of the n-ary tree is less than or equal to `1000`.

Follow up: Recursive solution is trivial, could you do it iteratively?

### Solution 
 To solve the problem of performing a postorder traversal on an n-ary tree, we can implement both a recursive and an iterative solution. The postorder traversal entails visiting all the children of a node before visiting the node itself.

### Explanation

1. **Understanding the n-ary Tree**: 
   - An n-ary tree is a tree where each node can have zero or more children.
   - The input representation utilizes `null` as a separator for different nodes' children.

2. **Postorder Traversal**: 
   - In postorder traversal, we first traverse all the children of a node and then visit the node itself.
   - For example, if we have a node structure like this:
     
```
             1
            /|\
           3 2 4
          /\
         5  6
     
```
     The postorder would visit 5, 6, then 3, followed by 2, 4, and finally 1, resulting in `[5, 6, 3, 2, 4, 1]`.

3. **Recursive Solution**: 
   - This is straightforward as we can easily use recursion to visit all children first and then add the current node to the result.

4. **Iterative Solution**: 
   - The iterative approach requires a stack to mimic the function call stack used in recursion. We can use a stack to traverse the tree, collecting nodes in postorder.

### Implementation

We'll implement the iterative solution using a stack. Here's the code:



```python
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

class Solution:
    def postorder(self, root: Node) -> List[int]:
        if root is None:
            return []
        
        stack = [root]
        output = []
        
        while stack:
            node = stack.pop()
            output.append(node.val)  # Add the node value to output
            for child in node.children:  # Add all children to stack
                stack.append(child)
        
        # Reverse the output to get the postorder
        return output[::-1]

```

### Detailed Breakdown of the Code:

1. **Node Class**: 
   - The `Node` class defines the structure of the tree nodes. Each node holds a value (`val`) and a list of its children.

2. **Solution Class**: 
   - The `Solution` class contains the method `postorder`, which takes the root of the tree as input and returns a list of values in postorder.

3. **Handling Edge Cases**: 
   - We check if the `root` is `None` and return an empty list if so.

4. **Stack for Iteration**: 
   - We initialize a stack with the `root` node. We also create an empty list `output` to collect the results.

5. **Traversal Logic**: 
   - While there are nodes in the stack, we pop a node, add its value to the `output`, and push all its children onto the stack. This ensures we visit each child before their parent.

6. **Reverse the Output**: 
   - Since we collected the node values in a reverse order (root after its children), we reverse our `output` list before returning it.

### Complexity:
- **Time Complexity**: O(N), where N is the number of nodes in the tree, as we visit each node exactly once.
- **Space Complexity**: O(N) in the worst case for the stack space used to store nodes.

This implementation can be directly run on the LeetCode website under the appropriate problem statement concerning an n-ary tree and should adhere to the input-output formats provided.

# 606. Construct String from Binary Tree

### Problem Description 
You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.

The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.


Example 1:
Input: Binary tree: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     
Output: "1(2(4))(3)"
Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".


Example 2:
Input: Binary tree: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 
Output: "1(2()(4))(3)"
Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.

### Solution 
 To solve the problem of constructing a string representation of a binary tree using preorder traversal, we need to keep in mind the following rules:

1. Each node is represented by its value.
2. For each node, if it has a left child, we represent it by its value followed by `(`, the string of its left subtree, and `)`.
3. If a node has a right child, we similarly represent it by appending it after the left child (if it exists) or by an empty pair of parentheses if it does not have a left child but has a right child. This ensures the structure of the tree is accurately represented.
4. We omit any empty parentheses that do not affect the mapping relationship, specifically those that appear for nodes with no children.

Here's how the solution can be implemented in Python:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def tree2str(self, root: TreeNode) -> str:
        if not root:
            return ""
        
        # Start with the root's value
        result = str(root.val)
        
        # Process the left subtree
        if root.left:
            result += "(" + self.tree2str(root.left) + ")"
        # If there is a right child, we need to include it
        if root.right:
            # We also need to include empty parentheses if there is a right child but no left child
            result += "(" + self.tree2str(root.right) + ")"
        
        return result

```

### Explanation of the Code:
1. **TreeNode Class**: This class defines the structure of a node in the binary tree. Each node has a value (`val`), a left child (`left`), and a right child (`right`).
   
2. **Solution Class**: This class contains the method `tree2str`, which takes the root of the binary tree as input and returns the specified string representation.

3. **Base Case**: If the `root` is `None`, we return an empty string.

4. **Constructing the Result**:  
   - Initialize `result` with the value of the current node (`root.val`).
   - If the left child exists, recursively call `tree2str` on the left child and append the result surrounded by parentheses.
   - If the right child exists, we do the same as above for the right child. Note that we check if the left child is `None` first because if we have a right child but no left child, we need to represent that with empty parentheses.

5. **Return Value**: Finally, we return the constructed string.

### Example Walkthrough:
- For the input tree `[1,2,3,4]`, the tree structure looks like:

```
       1
     /   \
    2     3
   /    
  4     

```
The output string would be `"1(2(4))(3)"`.

- For the input tree `[1,2,3,null,4]`, the structure looks like:

```
       1
     /   \
    2     3
     \  
      4 

```
The output string would be `"1(2()(4))(3)"`, where we cannot omit the empty parentheses for the left child of node `2` as it would break the structure.

### Conclusion:
This solution effectively uses recursive traversal to generate the desired string representation while adhering to the specified constraints of the problem. The complexity of this algorithm is O(n), where n is the number of nodes in the tree, as we visit each node exactly once.

# 617. Merge Two Binary Trees

### Problem Description 
You are given two binary trees `root1` and `root2`.

Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.

Return the merged tree.

Note: The merging process must start from the root nodes of both trees.


Example 1:
Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]

Example 2:
Input: root1 = [1], root2 = [1,2]
Output: [2,2]

Constraints:
The number of nodes in both trees is in the range `[0, 2000]`.

`-104 <= Node.val <= 104`

### Solution 
 To solve the problem of merging two binary trees as described, we'll employ a recursive approach. The merging process consists of iterating through the nodes of both trees. At each step, if both nodes are present, we sum their values to form the value of the merged node. If only one of the nodes is present (and the other is `None`), we simply take the non-null node as part of the merged tree.

Here is a structured solution that follows the format suitable for LeetCode:

### Python Code


```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        # Base case: if both nodes are None, return None
        if not root1 and not root2:
            return None
        
        # If one of the trees is None, return the other tree's node
        if not root1:
            return root2
        if not root2:
            return root1
        
        # If both nodes exist, sum their values and create a new node
        merged_node = TreeNode(root1.val + root2.val)
        
        # Recursively merge the left and right children
        merged_node.left = self.mergeTrees(root1.left, root2.left)
        merged_node.right = self.mergeTrees(root1.right, root2.right)
        
        return merged_node

```

### Explanation:
1. **TreeNode Class**: This class serves as the building block for our binary tree. Each node contains a value `val`, a pointer to the left child `left`, and a pointer to the right child `right`.

2. **Solution Class**: This class contains the method `mergeTrees`, which is our main function to merge the two given trees.

3. **Base Case Handling**: 
   - If both `root1` and `root2` are `None`, we return `None` since there is nothing to merge.
   - If `root1` is `None`, we simply return `root2`, which means that we directly use the nodes from `root2`.
   - Similarly, if `root2` is `None`, we return `root1`.

4. **Merging Nodes**: If both trees have nodes available, we create a new tree node with a value that is the sum of `root1.val` and `root2.val`. 

5. **Recursive Calls**:
   - We recursively call `mergeTrees` to merge the left children of both nodes and assign the returned tree to the left child of the new merged node.
   - We do the same for the right children.

6. **Union of Trees**: Finally, the function returns the merged tree starting from the root.

### Complexity:
- **Time Complexity**: O(N), where N is the minimum number of nodes in the two trees. Each node is visited exactly once.
- **Space Complexity**: O(H), where H is the height of the resulting merged tree, due to the recursive call stack.

This solution elegantly merges two binary trees while adhering to the problem's constraints and formats compatible with LeetCode submissions.

# 623. Add One Row to Tree

### Problem Description 
Given the `root` of a binary tree and two integers `val` and `depth`, add a row of nodes with value `val` at the given depth `depth`.

Note that the `root` node is at depth `1`.

The adding rule is:
Given the integer `depth`, for each not null tree node `cur` at the depth `depth - 1`, create two tree nodes with value `val` as `cur`'s left subtree root and right subtree root.

`cur`'s original left subtree should be the left subtree of the new left subtree root.

`cur`'s original right subtree should be the right subtree of the new right subtree root.

If `depth == 1` that means there is no depth `depth - 1` at all, then create a tree node with value `val` as the new root of the whole original tree, and the original tree is the new root's left subtree.


Example 1:
Input: root = [4,2,6,3,1,5], val = 1, depth = 2
Output: [4,1,1,2,null,null,6,3,1,5]

Example 2:
Input: root = [4,2,null,3,1], val = 1, depth = 3
Output: [4,2,null,1,1,3,null,null,1]

Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

The depth of the tree is in the range `[1, 104]`.

`-100 <= Node.val <= 100`
`-105 <= val <= 105`
`1 <= depth <= the depth of tree + 1`

### Solution 
 To solve the problem of adding a row of nodes at a given depth in a binary tree, we will follow a structured approach using a breadth-first search (BFS) or depth-first search (DFS) technique. Given the constraints and requirements, we'll focus on a BFS approach to systematically traverse the tree.

### Detailed Explanation

1. **Understanding the Depth**: 
   - The root of the tree is considered at depth 1. 
   - If `depth == 1`, we need to create a new root node with the value `val`, and the original tree should become the left child of this new root.
   - For any depth greater than 1, we need to locate all nodes at `depth - 1` and insert new nodes.

2. **Using BFS**: 
   - We can utilize a queue to perform BFS and keep track of the current nodes and their depths.
   - Once we reach `depth - 1`, we will create new nodes with the specified value and adjust the existing nodes' children accordingly.
   - For each node at the desired location, we will create a new left and right child node, linking them to the existing children.

3. **Implementation**: 
   - We'll implement a function `addOneRow` which takes the root of the tree, the value `val` to add, and the desired `depth`.
   - We need to handle cases when the tree is empty or when inserting a row requires adjusting the root.

### Code Implementation

Here's a Python implementation that you can run directly on LeetCode:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def addOneRow(self, root: TreeNode, val: int, depth: int) -> TreeNode:
        if depth == 1:
            new_root = TreeNode(val)
            new_root.left = root
            return new_root
        
        # Use a queue to perform BFS
        queue = [root]
        current_depth = 1
        
        # Traverse the tree until we reach the level just before the target depth
        while queue:
            current_size = len(queue)
            if current_depth == depth - 1:
                for _ in range(current_size):
                    node = queue.pop(0)
                    # Create new nodes with the given value
                    new_left = TreeNode(val)
                    new_right = TreeNode(val)
                    
                    # Link the new nodes to the current node
                    new_left.left = node.left
                    new_right.right = node.right
                    node.left = new_left
                    node.right = new_right
                break
            
            # Continue traversing
            for _ in range(current_size):
                node = queue.pop(0)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            current_depth += 1
        
        return root

```

### Explanation of the Code

1. **TreeNode Class**: This is a simple definition of a binary tree node with attributes for the value (`val`), left child (`left`), and right child (`right`).

2. **Solution Class**:
   - The method `addOneRow` processes the input and performs the BFS.
   - If `depth` is 1, we create a new root directly.
   - A queue is initialized with the current root, and we traverse level by level until we reach one level before the depth where new nodes need to be added.
   - For each node at `depth - 1`, new left and right children are created with the required value and linked to the original children.
   - The function then returns the modified tree, which can be printed or further processed as required.

### Complexity:
- **Time Complexity**: O(N), where N is the number of nodes in the tree, as we may need to visit every node in the worst case.
- **Space Complexity**: O(N) for the queue that may store all leaf nodes.

This solution efficiently adds a row of nodes to the specified depth in the binary tree while adhering to LeetCode's structure for function definitions and usages.

# 637. Average of Levels in Binary Tree

### Problem Description 
Given the `root` of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within `10-5` of the actual answer will be accepted.


Example 1:
Input: root = [3,9,20,null,15,7]
Output: [3.00000,14.50000,11.00000]
Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.

Hence return [3, 14.5, 11].


Example 2:
Input: root = [3,9,20,15,7]
Output: [3.00000,14.50000,11.00000]

Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`-231 <= Node.val <= 231 - 1`

### Solution 
 To solve the problem of calculating the average value of nodes at each level of a binary tree, we can utilize a breadth-first search (BFS) approach using a queue. This method allows us to traverse the tree level by level, making it easy to compute the average for each level.

Here's the breakdown of our solution:

1. **Define a TreeNode Class**: Since we're solving a binary tree problem, we first need a class definition for the nodes of the tree. This is typically provided in LeetCode challenges.

2. **BFS Traversal**: We'll use a queue to perform a level-order traversal of the tree. For each level, we will:
   - Count the number of nodes.
   - Sum up the values of the nodes.
   - Calculate the average by dividing the total sum of the node values by the number of nodes at that level.

3. **Store Averages**: We'll store the calculated averages in a list, which we will return at the end.

4. **Precision**: The problem specifies that answers within `10^-5` of the actual answer are acceptable, which is naturally handled by Python's floating-point arithmetic.

Here's the complete implementation:



```python
from collections import deque

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def averageOfLevels(self, root: TreeNode) -> list[float]:
        if not root:
            return []

        averages = []
        queue = deque([root])  # Using a deque for efficient pop from the left

        while queue:
            level_length = len(queue)
            level_sum = 0

            for _ in range(level_length):
                node = queue.popleft()
                level_sum += node.val

                # Add child nodes to the queue
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            # Calculate average for the current level
            level_average = level_sum / level_length
            averages.append(level_average)

        return averages

```

### Explanation of the Code:

1. **TreeNode Class**: This class enables the creation of tree nodes. Each node has a value (`val`), a left child (`left`), and a right child (`right`).

2. **averageOfLevels Method**:
   - It first checks if the root is `None`. If so, it returns an empty list.
   - We initialize a queue with the root node and an empty list to store averages.
   - A `while` loop iterates as long as there are nodes in the queue (indicating we haven't finished processing all levels).
   - For each level, we determine the number of nodes at that level (`level_length`) and initialize a `level_sum` to accumulate the sum of node values for that level.
   - An inner `for` loop processes all nodes at the current level. For each node:
     - We remove it from the queue and add its value to `level_sum`.
     - If it has left or right children, we add them to the queue for processing in the next iteration.
   - After processing all nodes at the current level, we calculate the average, add it to our `averages` list, and then continue to the next level.

3. **Return Statement**: Finally, we return the list of averages.

This solution is efficient and operates within the constraints provided, ensuring that even with the maximum number of nodes, it performs well.

# 652. Find Duplicate Subtrees

### Problem Description 
Given the `root` of a binary tree, return all duplicate subtrees.

For each kind of duplicate subtrees, you only need to return the root node of any one of them.

Two trees are duplicate if they have the same structure with the same node values.


Example 1:
Input: root = [1,2,3,4,null,2,4,null,null,4]
Output: [[2,4],[4]]

Example 2:
Input: root = [2,1,1]
Output: [[1]]

Example 3:
Input: root = [2,2,2,3,null,3,null]
Output: [[2,3],[3]]

Constraints:
The number of the nodes in the tree will be in the range `[1, 10^4]`
`-200 <= Node.val <= 200`

### Solution 
 To solve the problem of finding duplicate subtrees in a binary tree, we can utilize a combination of serialization and hashing. The approach involves traversing the tree, serializing each subtree, and storing their representations in a dictionary to track occurrences of each serialized form. If we find a serialized subtree that we have seen before, we can add its root node to our results.

### Steps to Solve the Problem:

1. **Serialization of Subtrees**: We will define a method that serializes the subtree rooted at a given node. A common way of serializing a tree is to use a pre-order traversal format. For each node, we create a string that represents its value followed by serializations of its left and right children.

2. **Using a Dictionary**: As we serialize each subtree, we will use a dictionary to count how many times we have seen each serialized representation. If a serialization appears more than once, it indicates we have found a duplicate subtree.

3. **Storing Results**: We will maintain a set or a list to store the root nodes of the duplicate subtrees. We will ensure that each duplicate root node is only added once.

4. **Return Duplicates**: After traversing the entire tree, we will return the list of duplicate subtree roots.

Here's the code implementing the above logic in a format suitable for LeetCode:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findDuplicateSubtrees(self, root: TreeNode):
        from collections import defaultdict
        
        # Dictionary to hold the serialized subtree as key and its count as value
        count = defaultdict(int)
        # List to hold the result of duplicate subtree roots
        result = []
        
        def serialize(node):
            if not node:
                return "#"
            # Serialize the subtree rooted at `node`
            serial = f"{node.val},{serialize(node.left)},{serialize(node.right)}"
            # Count occurrences of the serialized subtree
            count[serial] += 1
            
            # If this is the first time we see this serialized subtree, add to result
            if count[serial] == 2:
                result.append(node)
                
            return serial
        
        # Start serialization from the root
        serialize(root)
        return result

```

### Explanation of the Code:

1. **TreeNode Class**: This is a standard definition of the tree node with `val`, `left`, and `right` properties.

2. **findDuplicateSubtrees Method**: This method initializes a default dictionary `count` to track the number of times each serialized subtree occurs and a list `result` to store the duplicate subtree root nodes.

3. **serialize Function**: This is a recursive function that:
   - Handles the base case where the node is `None`, returning `"#"` (a marker for null).
   - Constructs a serialization string for the subtree rooted at the current node, including its value and the serialized forms of its left and right children.
   - Increments the count of the serialization in `count`.
   - Checks if the count is exactly 2 (indicating that this is the second time we are seeing this subtree), and if so, appends the current node to the `result`.

4. **Final Return**: The `findDuplicateSubtrees` method finally returns the list of duplicate subtree roots.

This solution is efficient and runs in O(N) time, where N is the number of nodes in the tree, since we visit each node exactly once. It uses O(N) additional space for the dictionary that stores serialized subtree strings and their counts.

# 653. Two Sum IV - Input is a BST

### Problem Description 
Given the `root` of a Binary Search Tree and a target number `k`, return `true` if there exist two elements in the BST such that their sum is equal to the given target.


Example 1:
Input: root = [5,3,6,2,4,null,7], k = 9
Output: true

Example 2:
Input: root = [5,3,6,2,4,null,7], k = 28
Output: false

Example 3:
Input: root = [2,1,3], k = 4
Output: true

Example 4:
Input: root = [2,1,3], k = 1
Output: false

Example 5:
Input: root = [2,1,3], k = 3
Output: true

Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`-104 <= Node.val <= 104`
`root` is guaranteed to be a valid binary search tree.

`-105 <= k <= 105`

### Solution 
 To solve the problem of finding two elements in a Binary Search Tree (BST) such that their sum equals a given target `k`, we can utilize a combination of the BST properties and a set to track the values we have traversed. Here is a Python solution, following the LeetCode format, complete with detailed explanations:

### Explanation:

1. **Binary Search Tree Properties**: In a BST, for any node, all values in the left subtree are less than the node's value, and all values in the right subtree are greater than the node's value. This property can be leveraged for efficient searching.

2. **Set for Tracking Values**: As we traverse the tree, we can maintain a set of the numbers we have already seen. For each node, we can check if `k - node.val` exists in the set (i.e., if we've seen a value that can pair with the current node's value to meet the sum).

3. **Inorder Traversal**: We'll perform an inorder traversal of the BST because it can help us explore each node once, ensuring that we efficiently check for the required pairs.

4. **Complexity**: The approach operates in O(N) time complexity where N is the number of nodes, and it requires O(N) space for storing the set of visited values.

### Python Code:

Here's how the code looks in the LeetCode format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        # Set to keep track of the values we have seen
        seen = set()
        
        # Helper function for inorder traversal of the BST
        def inorder(node):
            # Base case: if the node is None, return False
            if node is None:
                return False
            
            # Traverse the left subtree
            if inorder(node.left):
                return True
            
            # Check if the complement (k - node.val) exists in the set
            if (k - node.val) in seen:
                return True
            # Otherwise, add the current node value to the set
            seen.add(node.val)
            
            # Traverse the right subtree
            return inorder(node.right)
        
        # Start the inorder traversal
        return inorder(root)

```

### Explanation of Code Components:

- **TreeNode Class**: Represents each node in the BST with its value and pointers to its left and right children.
  
- **Solution Class**: Contains the `findTarget` method which is the main entry point for the solution.
  
- **Set (seen)**: Used to store the values we encounter during the traversal.
  
- **Inorder Function**:
  - Recursively traverses the BST.
  - When a node is processed, it checks if the complement (i.e., `k - node.val`) has been seen.
  - If found, it returns `True`.
  - If not found, it adds the current node's value to the `seen` set.

- **Return Value**: The outer function `findTarget` initiates the process and returns the final result based on the output of the `inorder` helper function.

### Usage:
You would typically instantiate the `Solution` class and call the `findTarget` method with the root of the BST and the desired `k` value. The function will then return `True` or `False` based on whether such a pair of nodes exists.

# 654. Maximum Binary Tree

### Problem Description 
You are given an integer array `nums` with no duplicates. A maximum binary tree can be built recursively from `nums` using the following algorithm:
Create a root node whose value is the maximum value in `nums`.

Recursively build the left subtree on the subarray prefix to the left of the maximum value.

Recursively build the right subtree on the subarray suffix to the right of the maximum value.

Return the maximum binary tree built from `nums`.


Example 1:
Input: nums = [3,2,1,6,0,5]
Output: [6,3,5,null,2,0,null,null,1]
Explanation: The recursive calls are as follow:
- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].

    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].

        - Empty array, so no child.

        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].

            - Empty array, so no child.

            - Only one element, so child is a node with value 1.

    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].

        - Only one element, so child is a node with value 0.

        - Empty array, so no child.


Example 2:
Input: nums = [3,2,1]
Output: [3,null,2,null,1]

Constraints:
`1 <= nums.length <= 1000`
`0 <= nums[i] <= 1000`
All integers in `nums` are unique.

### Solution 
 To solve the problem of constructing a maximum binary tree from a list of unique integers, we will use a recursive approach. The main idea is to identify the maximum value in the current subarray and create a tree node with that value. Then, we will recursively do the same for the left and right parts of the array (those elements that are to the left and right of the maximum element).

Here's how the approach works step-by-step:

1. **Identify the Maximum**: To build the tree, we first need to find the maximum value in the current subarray.
2. **Create a Node**: This maximum value becomes the root of the current subtree (node).
3. **Recursive Calls**: We then recursively build the left subtree with the subarray of elements that are to the left of the maximum value, and the right subtree with the subarray of elements that are to the right of the maximum value.
4. **Base Case**: If the current subarray is empty (when we try to build a subtree from an empty list), we simply return `None`.

Now, let's implement this in Python. We will define a TreeNode class to represent the nodes of our binary tree and a function to build the tree from the given list of integers.

Here’s the complete code that follows the LeetCode submission format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def constructMaximumBinaryTree(self, nums):
        if not nums:
            return None
        
        # Find the index of the maximum value
        max_index = nums.index(max(nums))
        
        # Create the root node with the maximum value
        root = TreeNode(nums[max_index])
        
        # Recursively build the left and right subtrees
        root.left = self.constructMaximumBinaryTree(nums[:max_index])
        root.right = self.constructMaximumBinaryTree(nums[max_index + 1:])
        
        return root

# Example usage:
# sol = Solution()
# tree_root = sol.constructMaximumBinaryTree([3,2,1,6,0,5])

```

### Explanation of the Code:
1. **TreeNode Class**: This class defines the structure of a tree node, which has a value and pointers to left and right child nodes.
2. **Solution Class**: This class contains the method `constructMaximumBinaryTree` which implements the logic for building the binary tree.
3. **Base Case**: The first conditional check `if not nums:` handles the case where the input list is empty. If it is empty, we return `None`, indicating there is no subtree.
4. **Finding Maximum**: We find the maximum element's index using `nums.index(max(nums))`, which gives the position of the maximum value.
5. **Creating the Root**: We create the root of the tree with the maximum value.
6. **Recursive Construction**: We recursively call `constructMaximumBinaryTree` for the left subarray (`nums[:max_index]`) and right subarray (`nums[max_index + 1:]`) to build the left and right subtrees.
7. **Return the Root**: Finally, we return the constructed tree rooted at `root`.

This implementation is efficient and runs in O(n) time complexity where n is the length of the input list, since we're scanning through the list to find the maximum for each recursive call. The recursion depth will be at most n, yielding a space complexity of O(n) for the recursion stack. 

You can directly run this code on LeetCode's platform, and it should work as expected, passing all the test cases.

# 655. Print Binary Tree

### Problem Description 
Print a binary tree in an m*n 2D string array following these rules: 
The row number `m` should be equal to the height of the given binary tree.

The column number `n` should always be an odd number.

The root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them. 
Each unused space should contain an empty string `""`.

Print the subtrees following the same rules.


Example 1:
Input:
     1
    /
   2
Output:
[["", "1", ""],
 ["2", "", ""]]

Example 2:
Input:
     1
    / \
   2   3
    \
     4
Output:
[["", "", "", "1", "", "", ""],
 ["", "2", "", "", "", "3", ""],
 ["", "", "4", "", "", "", ""]]

Example 3:
Input:
      1
     / \
    2   5
   / 
  3 
 / 
4 
Output:
[["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]
 ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]
 ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]
 ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]
Note:
The height of binary tree is in the range of [1, 10].

### Solution 
 To solve the problem of printing a binary tree in a 2D string array, we'll follow the specified rules for positioning the binary tree nodes. We will recursively construct the output array based on the height of the binary tree and the node values.

Here's a structured approach:

1. **Calculate the Height**: First, we need to determine the height of the binary tree. The height will help in determining the number of rows `m` in our result.

2. **Calculate the Dimensions of the Result**: Given that `n` (the number of columns) should be odd and calculated as `2^height - 1` to accommodate the widest possible tree alignment.

3. **Initialize the Result Array**: We will create a 2D list filled with empty strings based on the calculated dimensions.

4. **Place the Nodes in the Result Array**: Using a recursive helper function, place each node at the appropriate position based on their level and the width of the tree at that level. The root starts at the middle of the first row, and for each node, we calculate its position in the result matrix depending on its level.

5. **Return the Result**: Finally, return the constructed 2D string array.

Now, let's implement this:



```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def printTree(self, root: TreeNode) -> list[list[str]]:
        # Helper function to calculate the height of the tree
        def getHeight(node):
            if not node:
                return 0
            return 1 + max(getHeight(node.left), getHeight(node.right))

        height = getHeight(root)
        m = height
        n = (1 << height) - 1  # This is 2^height - 1

        # Initialize the result matrix with empty strings
        result = [[""] * n for _ in range(m)]

        # Helper function to fill the result matrix
        def fill(node, row, col, width):
            if not node:
                return
            # Place the value of the node in result
            result[row][col] = str(node.val)
            # Calculate the position for left and right children
            fill(node.left, row + 1, col - width // 2, width // 2)
            fill(node.right, row + 1, col + width // 2, width // 2)
        
        fill(root, 0, (n // 2), n)  # Start filling from root
        return result

```

### Explanation of the Code:

1. **TreeNode Class**: We've defined a basic binary tree node structure.
  
2. **getHeight**: This recursive function computes the height of the binary tree.

3. **printTree Method**:
   - `height` gives us the height of the tree.
   - `n` is calculated as `2^height - 1`.
   - An initial `result` list of size `m x n` filled with empty strings is created.

4. **fill Function**: This recursive function places the values from the tree into the correct positions in the `result` list.
   - It calculates the column index for the current node and recursively calculates the positions for the left and right child nodes based on the current width.

5. **Final Call**: The function is invoked with the root node at the appropriate starting position, and the filled result is returned.

This structured approach allows us to neatly fit the binary tree into a specified 2D grid format following the given rules.

# 662. Maximum Width of Binary Tree

### Problem Description 
Given a binary tree, write a function to get the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels.

The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the `null` nodes between the end-nodes are also counted into the length calculation.

It is guaranteed that the answer will in the range of 32-bit signed integer.


Example 1:
Input: 
           1
         /   \
        3     2
       / \     \  
      5   3     9 
Output: 4
Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).


Example 2:
Input: 
          1
         /  
        3    
       / \       
      5   3     
Output: 2
Explanation: The maximum width existing in the third level with the length 2 (5,3).


Example 3:
Input: 
          1
         / \
        3   2 
       /        
      5      
Output: 2
Explanation: The maximum width existing in the second level with the length 2 (3,2).


Example 4:
Input: 
          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
Output: 8
Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).


Constraints:
The given binary tree will have between `1` and `3000` nodes.

### Solution 
 To solve the problem of finding the maximum width of a binary tree, we'll implement a breadth-first search (BFS) traversal. During the traversal, we'll keep track of the indexes of the nodes in each level, allowing us to determine the width effectively.

### Approach:

1. **Use a Queue for BFS:** We can use a queue to facilitate level-order traversal of the tree. Each entry in this queue will contain the node and its position/index within the tree.

2. **Calculate Width for Each Level:** For each level of the tree, we'll track the first and last indices of non-null nodes. The width for that level can be calculated as follows:
   \[
   \text{width} = \text{last index} - \text{first index} + 1
   \]

3. **Keep Track of Maximum Width:** As we process each level, we'll continuously update our maximum width variable if the current level's width exceeds the previously recorded maximum.

4. **Handle Null Nodes:** The problem states that null nodes between the leftmost and rightmost nodes must be counted for width calculations. By assigning indexes based on expected positions (with nulls counted), we can achieve this.

### Implementation:
Here's the Python code that follows this logic according to the LeetCode solution format.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

from collections import deque

class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        max_width = 0
        queue = deque([(root, 0)])  # (node, index)
        
        while queue:
            level_length = len(queue)
            _, first_index = queue[0]  # index of the first node in this level
            for i in range(level_length):
                node, index = queue.popleft()
                
                # Normalize the index to avoid overflow issues
                index -= first_index
                
                # Add child nodes to the queue with their respective indices
                if node.left:
                    queue.append((node.left, 2 * index))  # left child index
                if node.right:
                    queue.append((node.right, 2 * index + 1))  # right child index
            
            # Compute the width of the current level
            if level_length > 0:  # If there are nodes in this level
                max_width = max(max_width, index + 1)  # index is normalized
        
        return max_width

```

### Explanation of the Code:

1. **TreeNode Definition:** We start by defining a class `TreeNode` that represents each node in the binary tree.

2. **Class Solution and Method**: Inside the `Solution` class, we define a method `widthOfBinaryTree`:
   - Initialize a deque (double-ended queue) that will hold tuples of (node, index).
   - Start the queue with the root node and its index (0).
   - Process each level by calculating its length and finding the first index of that level.

3. **Iterate Through Each Level:** For each node at the current level:
   - Normalize the index by subtracting the first index of that level, avoiding overflow and keeping the indices manageable.
   - Append the left child at index `2 * index` and the right child at `2 * index + 1`.

4. **Calculate Width:** After processing the nodes at a level, compute the width and update the maximum width if necessary.

5. **Return Result:** Finally, the method returns the maximum width found during the traversal.

This implementation efficiently calculates the maximum width of the binary tree while ensuring that the index normalization keeps performance high and space manageable. The algorithm runs in O(N) time complexity, where N is the number of nodes, and uses O(W) space for the queue during the level with maximum width W.

# 663. Equal Tree Partition

### Problem Description 
Given a binary tree with `n` nodes, your task is to check if it's possible to partition the tree to two trees which have the equal sum of values after removing exactly one edge on the original tree.


Example 1:
Input:     
    5
   / \
  10 10
    /  \
   2   3
Output: True
Explanation: 
    5
   / 
  10
      
Sum: 15
   10
  /  \
 2    3
Sum: 15

Example 2:
Input:     
    1
   / \
  2  10
    /  \
   2   20
Output: False
Explanation: You can't split the tree into two trees with equal sum after removing exactly one edge on the tree.

Note:
The range of tree node value is in the range of [-100000, 100000].

1 <= n <= 10000

### Solution 
 To solve the problem of checking whether a binary tree can be partitioned into two trees with equal sum after removing exactly one edge, we can follow these steps:

1. **Calculate the Total Sum**: First, we need to calculate the total sum of the tree's node values. If this total sum is odd, it's impossible to partition it into two equal parts, so we can immediately return `False`.

2. **Depth-First Search (DFS)**: We will use a DFS to traverse through each node of the binary tree and calculate the cumulative sum of each subtree. During the DFS, we will check for any subtree whose sum is equal to half of the total sum. If we find such a subtree, we can partition the tree by removing the edge connecting this subtree to its parent.

3. **Return the Result**: If we find one or more valid subtrees, we will return `True`. Otherwise, we’ll return `False`.

Here is the complete code implementation in Python based on the above steps, which you can run directly on LeetCode:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def checkEqualTree(self, root: TreeNode) -> bool:
        # Helper function to compute the sum of the tree
        def dfs(node):
            if not node:
                return 0
            return node.val + dfs(node.left) + dfs(node.right)

        # Calculate total sum of the tree
        total_sum = dfs(root)

        # If total_sum is odd, we cannot split it into two equal parts
        if total_sum % 2 != 0:
            return False
        
        # We are looking for half the total sum in any subtree
        half_sum = total_sum // 2
        found_half_sum = False
        
        # Utilize a set to avoid counting the root itself
        subtree_sums = set()
        
        # Second DFS to check for the half_sum
        def findHalfSum(node):
            nonlocal found_half_sum
            if not node or found_half_sum:
                return 0
            
            current_sum = node.val + findHalfSum(node.left) + findHalfSum(node.right)
            
            # Check if we have already found half_sum in a previous subtree
            if current_sum == half_sum and node != root:  # Avoid using the whole tree
                found_half_sum = True
            
            subtree_sums.add(current_sum)
            return current_sum
        
        findHalfSum(root)
        
        return found_half_sum

```

### Explanation:

- **TreeNode Class**: This is a standard binary tree node definition used to construct the tree.
  
- **checkEqualTree Function**: This is the main function of the `Solution` class:
  - We first calculate the total sum of tree nodes using a helper function `dfs()`.
  - We check if the total sum is odd. If so, we return `False`.
  - We compute half of the total sum and initialize a boolean flag to track if we find a valid subtree sum.
  
- **findHalfSum Function**: This is another DFS that:
  - Computes the sum of subtrees.
  - Checks if any subtree has a sum equal to half of the total sum while ensuring that we are not using the whole tree by checking if `node != root`.
  
- **Final Return**: The function returns `True` if we found a valid subtree, and `False` otherwise.

This structure adheres to the LeetCode solution format, and the function is expected to run efficiently within the constraints provided.

# 666. Path Sum IV

### Problem Description 
If the depth of a tree is smaller than `5`, then this tree can be represented by a list of three-digits integers.

For each integer in this list:
The hundreds digit represents the depth `D` of this node, `1 <= D <= 4.`
The tens digit represents the position `P` of this node in the level it belongs to, `1 <= P <= 8`. The position is the same as that in a full binary tree.

The units digit represents the value `V` of this node, `0 <= V <= 9.`
Given a list of `ascending` three-digits integers representing a binary tree with the depth smaller than 5, you need to return the sum of all paths from the root towards the leaves.

It's guaranteed that the given list represents a valid connected binary tree.


Example 1:
Input: [113, 215, 221]
Output: 12
Explanation: 
The tree that the list represents is:
    3
   / \
  5   1
The path sum is (3 + 5) + (3 + 1) = 12.


Example 2:
Input: [113, 221]
Output: 4
Explanation: 
The tree that the list represents is: 
    3
     \
      1
The path sum is (3 + 1) = 4.

### Solution 
 To solve the problem of calculating the sum of all root-to-leaf paths in a binary tree represented by a list of three-digit integers, we can break down our approach into a few key steps:

1. **Understanding the Representation**: Each integer represents a node in the tree:
   - The hundreds digit indicates the depth \(D\) (levels 1 to 4).
   - The tens digit indicates the position \(P\) of the node at that depth (1 to 8, similar to a complete binary tree).
   - The units digit indicates the value \(V\) of the node (0 to 9).

2. **Building the Tree**: We need to construct the binary tree from the provided list of integers. We will create a mapping from depth and position to the node's value.

3. **Calculating the Path Sums**: We can use depth-first search (DFS) to traverse the tree and calculate the sum of all paths from the root to the leaves.

Here's the complete code structured as per LeetCode format:



```python
class TreeNode:
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None

class Solution:
    def pathSum(self, nums: List[int]) -> int:
        # Step 1: Build the tree
        nodes = {}
        
        for number in nums:
            depth = number // 100  # hundreds digit
            pos = (number // 10) % 10  # tens digit
            value = number % 10  # units digit
            
            # Calculate the unique key for node storage
            key = (depth, pos)
            nodes[key] = TreeNode(value)

            # Step 2: Establish parent-child relationships
            if depth > 1:
                parent_depth = depth - 1
                parent_pos = (pos + 1) // 2  # parent position in the previous level
                parent_key = (parent_depth, parent_pos)

                if parent_key in nodes:
                    if pos % 2 == 1:  # odd position, left child
                        nodes[parent_key].left = nodes[key]
                    else:  # even position, right child
                        nodes[parent_key].right = nodes[key]

        # Step 3: DFS to calculate the path sums
        def dfs(node, current_sum):
            if not node:
                return 0
            current_sum += node.val
            if not node.left and not node.right:  # leaf node
                return current_sum
            return dfs(node.left, current_sum) + dfs(node.right, current_sum)
        
        # Start DFS from the root (first node at depth 1, position 1)
        root_key = (1, 1)
        root = nodes.get(root_key)
        return dfs(root, 0)

# Example usage:
# sol = Solution()
# print(sol.pathSum([113, 215, 221]))  # Output: 12
# print(sol.pathSum([113, 221]))  # Output: 4

```

### Explanation of the Code:
1. **TreeNode Class**: A simple class to represent each node of the binary tree, initialized with a value, left child, and right child.

2. **Solution Class**:
   - The `pathSum` function takes a list of integers and initializes a dictionary `nodes` to store nodes based on their calculated position (depth, position).

3. **Building the Tree**:
   - We loop through each integer in `nums`, extract depth, position, and value, and create a corresponding `TreeNode` for that representation.
   - If the node's depth is greater than 1, we determine its parent's position and set the appropriate left or right child accordingly.

4. **Calculating the Path Sums**:
   - We define a recursive function `dfs` which takes the current node and the accumulated path sum. If a node is a leaf node, it returns the current sum. Otherwise, it continues the DFS on its children.

5. **Return Value**: Finally, we initiate the DFS from the root node (at depth 1, position 1) and return the total path sum.

This solution is efficient and effectively reconstructs the tree and calculates the required sum.

# 669. Trim a Binary Search Tree

### Problem Description 
Given the `root` of a binary search tree and the lowest and highest boundaries as `low` and `high`, trim the tree so that all its elements lies in `[low, high]`. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a unique answer.

Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.


Example 1:
Input: root = [1,0,2], low = 1, high = 2
Output: [1,null,2]

Example 2:
Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3
Output: [3,2,null,1]

Example 3:
Input: root = [1], low = 1, high = 2
Output: [1]

Example 4:
Input: root = [1,null,2], low = 1, high = 3
Output: [1,null,2]

Example 5:
Input: root = [1,null,2], low = 2, high = 4
Output: [2]

Constraints:
The number of nodes in the tree in the range `[1, 104]`.

`0 <= Node.val <= 104`
The value of each node in the tree is unique.

`root` is guaranteed to be a valid binary search tree.

`0 <= low <= high <= 104`

### Solution 
 To solve the problem of trimming a binary search tree (BST) such that all its elements lie within a specified inclusive range [low, high], we can utilize recursion. The approach is based on the properties of a binary search tree, where for any given node, all values in its left subtree are less than the node's value and all values in its right subtree are greater.

### Approach:
1. **Base Cases**:
   - If the current node is `None`, we simply return `None`.
   - If the current node's value is less than `low`, it means this node and its left subtree cannot be part of the trimmed tree, so we return the result of trimming its right subtree.
   - If the current node's value is greater than `high`, it indicates that this node and its right subtree cannot be included, so we return the result of trimming its left subtree.

2. **Trimming the Current Node**:
   - If the current node's value is within the range [low, high], we recursively trim both the left and right subtrees and then return the current node with its possibly trimmed subtrees.

This recursive approach ensures that we preserve the BST properties and only exclude nodes outside the specified range without rearranging the valid nodes.

### Implementation:
Below is the Python code tailored to the traditional LeetCode structure, including the required helper functions and class definitions necessary to run on the LeetCode platform.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
        # Base case: if the current node is None, return None
        if not root:
            return None
        
        # If the value of the current node is less than low,
        # we need to trim the left subtree and return the right
        if root.val < low:
            return self.trimBST(root.right, low, high)

        # If the value of the current node is greater than high,
        # we need to trim the right subtree and return the left
        if root.val > high:
            return self.trimBST(root.left, low, high)

        # If the current node is within the range [low, high],
        # recursively trim both left and right subtrees
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        
        # Return the trimmed root
        return root

```

### Explanation of the Implementation:

- **TreeNode Class**: This is a basic implementation of a binary tree node with attributes for the value (`val`), left child (`left`), and right child (`right`).
  
- **Solution Class**: Contains the `trimBST` method that performs the trimming.
  
- **trimBST Method**:
  - Takes the `root` node, `low`, and `high` as arguments.
  - Handles each case as outlined in the approach.
  - The method is called recursively on the left and right children as needed, ensuring the relative structure of the remaining nodes is preserved.

### Conclusion
This solution effectively iterates through the tree with a time complexity of O(n), as it may visit each node once, where n is the number of nodes in the tree. The algorithm runs in-place and modifies the tree structure as needed, returning the new root of the trimmed tree. This approach complies with the constraints given in the problem and provides an efficient and clean solution.

# 671. Second Minimum Node In a Binary Tree

### Problem Description 
Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly `two` or `zero` sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property `root.val = min(root.left.val, root.right.val)` always holds.

Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.

If no such second minimum value exists, output -1 instead.


Example 1:
Input: root = [2,2,5,null,null,5,7]
Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.


Example 2:
Input: root = [2,2,2]
Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.


Constraints:
The number of nodes in the tree is in the range `[1, 25]`.

`1 <= Node.val <= 231 - 1`
`root.val == min(root.left.val, root.right.val)` for each internal node of the tree.

### Solution 
 To solve the problem of finding the second minimum value in a special binary tree, we'll follow a few structured steps:

1. **Understanding the Structure**: The problem states that each non-leaf node has exactly two children and that its value is the minimum of its children's values. This means that the value at each node is often derived from its children according to the min property stated.

2. **Identifying the Values**: To find the second minimum value, we can perform a traversal of the tree (commonly, a depth-first traversal) and collect unique values. Since we are interested only in the smallest and the second smallest values, we will keep track of those effectively during our traversal.

3. **Implementation**: We can use a set to keep the unique values as we traverse the binary tree. Once we have collected all unique values, we can simply convert the set to a sorted list and check the second smallest value.

Below is the Python code following the LeetCode format for submission:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        # Set to store unique values
        unique_values = set()
        
        # Helper function for DFS traversal
        def dfs(node):
            if node is None:
                return
            # Add the current node's value to the set
            unique_values.add(node.val)
            # Recursively do the same for the left and right children
            dfs(node.left)
            dfs(node.right)
        
        # Start DFS traversal from the root
        dfs(root)
        
        # Convert the set to a sorted list to find the second minimum
        sorted_values = sorted(unique_values)
        # If there is no second minimum, return -1
        return sorted_values[1] if len(sorted_values) > 1 else -1

```

### Explanation:

1. **TreeNode Class**: A `TreeNode` class is defined, which includes a constructor to initialize a node with a value, left child, and right child.

2. **Solution Class**: The `Solution` class encapsulates our method `findSecondMinimumValue`.

3. **DFS Traversal**: We define a helper function `dfs(node)` that:
   - Adds the current node's value to a set called `unique_values`.
   - Recursively traverses the left and right children of the node.

4. **Starting the Traversal**: We call the `dfs` function starting from the `root` to populate the set with all unique values in the tree.

5. **Finding the Second Minimum Value**:
   - We convert the set to a sorted list `sorted_values`.
   - If the length of this sorted list is greater than 1, we return the second element (which is the second minimum value).
   - If there is only one unique value (or none), we return -1.

### Complexity:
- **Time complexity**: O(n), where n is the number of nodes in the tree, since we visit each node once.
- **Space complexity**: O(n) in the worst case for storing the unique values.

This structure and logic ensure that our solution is efficient, clear, and adheres to the problem requirements.

# 684. Redundant Connection

### Problem Description 
In this problem, a tree is an undirected graph that is connected and has no cycles.

The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.

The resulting graph is given as a 2D-array of `edges`.  Each element of `edges` is a pair `[u, v]` with `u < v`, that represents an undirected edge connecting nodes `u` and `v`.

Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge `[u, v]` should be in the same format, with `u < v`.


Example 1:
Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given undirected graph will be like this:
  1
 / \
2 - 3

Example 2:
Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]
Output: [1,4]
Explanation: The given undirected graph will be like this:
5 - 1 - 2
    |   |
    4 - 3
Note:
The size of the input 2D-array will be between 3 and 1000.

Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.

Update (2017-09-26):
We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.

### Solution 
 To solve the problem of identifying an edge in a graph that can be removed to restore the tree structure, we can leverage the Union-Find (also known as Disjoint Set Union, DSU) data structure. The main idea is to iterate through the edges, and for each edge, we'll check if the two vertices (nodes) in the edge are already connected. If they are connected, it means that adding this edge creates a cycle, and we can consider this edge as a candidate for removal.

We'll implement the solution in a step-by-step manner:

1. **Create a Union-Find Data Structure:** This will help us manage and merge sets of connected components.
2. **Iterate through Edge List:** For each edge, we will attempt to union the two nodes.
3. **Detect Cycles:** If the nodes are already in the same set, it indicates the presence of a cycle, and thus the edge is a redundant edge.
4. **Return the Last Redundant Edge:** Since we want to return the last edge that was found to be redundant, we’ll keep track of it during our iterations.

Here is the Python code implementing this approach, formatted to run directly on LeetCode:



```python
class UnionFind:
    def __init__(self, size):
        self.parent = [i for i in range(size + 1)]
        self.rank = [1] * (size + 1)

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])  # Path compression
        return self.parent[u]

    def union(self, u, v):
        root_u = self.find(u)
        root_v = self.find(v)

        if root_u == root_v:
            return False  # They are already connected
        # Union by rank
        if self.rank[root_u] > self.rank[root_v]:
            self.parent[root_v] = root_u
        elif self.rank[root_u] < self.rank[root_v]:
            self.parent[root_u] = root_v
        else:
            self.parent[root_v] = root_u
            self.rank[root_u] += 1
        return True

class Solution:
    def findRedundantDirectedEdge(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        uf = UnionFind(n)
        last_edge = None

        for u, v in edges:
            if not uf.union(u, v):  # If union fails, it means there's a cycle
                last_edge = [u, v]  # Save the last edge that causes a cycle

        return last_edge

```

### Explanation of the Code:

1. **UnionFind Class:**
   - `__init__(self, size)`: Initializes a union-find structure with `size + 1` to accommodate 1-based indexing.
   - `find(self, u)`: Finds the representative (root) of the set containing `u`, applying path compression for efficiency.
   - `union(self, u, v)`: Connects the sets containing `u` and `v`. If they are already connected, it returns `False`, indicating a cycle.

2. **Solution Class:**
   - `findRedundantDirectedEdge(self, edges)`: Main function to process the edges.
   - `n = len(edges)`: Determines the number of edges, which also represents the number of nodes.
   - Initializes an instance of `UnionFind`.
   - Iterates over each edge; if union fails (indicating a cycle), the edge is recorded as `last_edge`.

3. **Return Statement:** Finally returns the last edge found that leads to a cycle.

This approach ensures that we efficiently find the last redundant edge while maintaining a linear time complexity with respect to the number of edges, making it suitable for the input size constraints.

# 685. Redundant Connection II

### Problem Description 
In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.

The given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.

The resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a directed edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.

Return an edge that can be removed so that the resulting graph is a rooted tree of `n` nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.


Example 1:
Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]

Example 2:
Input: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
Output: [4,1]

Constraints:
`n == edges.length`
`3 <= n <= 1000`
`edges[i].length == 2`
`1 <= ui, vi <= n`

### Solution 
 To solve the problem where we need to identify an edge that can be removed from a directed graph (which was initially a rooted tree but has one additional edge added), we can approach the solution with the following steps:

1. **Understand the Graph Structure**: Given that we have a rooted tree with an added edge, we can derive that this new edge will create a cycle in the graph. Our task is to identify which edge can be removed to restore the tree structure.

2. **Cycle Identification**: By using a set to keep track of the in-degrees (the number of incoming edges) of each node, we can identify nodes that have more than one parent, thus indicating a cycle.

3. **Edge Removal Logic**: The proper edge to remove is the one that forms the last occurrence of the cycle based on the representation in the edges list.

### Solution Implementation

Here's the implementation in Python following the LeetCode solution format. 



```python
class Solution:
    def findRedundantDirectedEdge(self, edges: List[List[int]]) -> List[int]:
        parent = {}
        in_degree = {}
        # Step 1: Build the in-degree count
        for u, v in edges:
            in_degree[v] = in_degree.get(v, 0) + 1
            in_degree[u] = in_degree.get(u, 0)  # Ensure parent node exists in in_degree
            
            # Step 2: Detect nodes with in-degree > 1
            if v in parent:
                # If the child has a parent already, we may have a redundant edge
                # We want to keep track of this potential edge
                redundant_edge = [parent[v], v]
            parent[v] = u  # Set the parent of v to u

        # Now we need to find the edge to remove that was denoted as redundant
        # The best candidate is the one that we saved last
        for u, v in reversed(edges):
            if in_degree[v] > 1 and parent[v] == u:
                return [u, v]

        # If we reach here, we fallback to return the redundant edge stored earlier
        return redundant_edge

```

### Explanation of the Code:

1. **Data Structures**:
   - `parent`: A dictionary that maps each child node to its parent.
   - `in_degree`: A dictionary to count the in-degrees of each node. This helps to check if any node has more than one incoming edge.

2. **Building the Graph**:
   - We iterate over each directed edge defined in `edges`.
   - For each edge `[u, v]`, we increment the count for in-degree of node `v`.
   - If `v` already has a parent in our `parent` dictionary, we store this instance as a candidate for the redundancy with `redundant_edge`.

3. **Finding the Redundant Edge**:
   - We iterate through `edges` in reverse order to ensure we return the edge that occurs last if there are multiple candidates.
   - If we find that node `v` has more than one incoming edge (which is indicated by checking `in_degree[v] > 1`), we return that edge as the one that can be removed to restore the tree structure.

### Complexity:
- The time complexity of our solution is O(n), where n is the number of edges or nodes, since we only make a few passes through the edges list.
- The space complexity is also O(n), due to the use of our dictionaries (`parent` and `in_degree`).

This implementation of the solution is optimal for the given constraints, ensuring we efficiently identify the edge that can be removed.

# 687. Longest Univalue Path

### Problem Description 
Given the `root` of a binary tree, return the length of the longest path, where each node in the path has the same value. This path may or may not pass through the root.

The length of the path between two nodes is represented by the number of edges between them.


Example 1:
Input: root = [5,4,5,1,1,5]
Output: 2

Example 2:
Input: root = [1,4,5,4,4,5]
Output: 2

Constraints:
The number of nodes in the tree is in the range `[0, 104]`.

`-1000 <= Node.val <= 1000`
The depth of the tree will not exceed `1000`.

### Solution 
 To solve the problem of finding the length of the longest consecutive path with the same value in a binary tree, we need to traverse the tree while keeping track of the length of such paths. The approach involves depth-first search (DFS) and will maintain the current length of the path as we navigate through the tree.

### Explanation

1. **Node Representation**:
   Each node in the binary tree has a value and references to its left and right children.

2. **DFS Traversal**:
   We perform a DFS starting from the root node. For each node, we will:
   - Check both left and right children.
   - If the child node has the same value as the current node, we increase the path length.
   - If not, we reset the path length to zero for that direction.

3. **Tracking Maximum Length**:
   We will maintain a global maximum length of paths discovered using a variable. During the DFS, if the current path length exceeds this maximum, we will update it.

4. **Edge Cases**:
   - If the tree is empty (i.e., the root is `None`), the longest path length is 0.

### Implementation on LeetCode

We will define the `TreeNode` class as typically defined in LeetCode problems, and the function `longestUnivaluePath` will be implemented within a `Solution` class.

Here is the implementation that adheres to the LeetCode structure:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def longestUnivaluePath(self, root: TreeNode) -> int:
        self.max_length = 0
        
        def dfs(node):
            if not node:
                return 0
            
            # Recursively call dfs on left and right children
            left_length = dfs(node.left)
            right_length = dfs(node.right)
            
            # Initialize paths for left and right sides if they have the same value as the current node
            left_path = left_length + 1 if node.left and node.left.val == node.val else 0
            right_path = right_length + 1 if node.right and node.right.val == node.val else 0
            
            # Update maximum length found so far
            self.max_length = max(self.max_length, left_path + right_path)
            
            # Return the longest single path length to be considered by the parent nodes
            return max(left_path, right_path)
        
        dfs(root)
        return self.max_length

```

### Detailed Breakdown of the Code:

1. **TreeNode class**: This class defines the structure of a node in the tree with an initializer for value, left, and right children.

2. **Solution class**:
   - We define a method `longestUnivaluePath` which initializes `self.max_length` to zero and starts DFS from the `root`.
   - The inner function `dfs(node)` checks whether the current node is `None`. If it is, it returns 0 indicating no valid path exists.

3. **Calculating Paths**:
   - For each valid node, we calculate:
     - Length of the left path `left_length`
     - Length of the right path `right_length`
   - If either left or right child has the same value as the current node’s value, we extend the path by 1.

4. **Updating Maximum Length**:
   - We calculate the total path length that can be formed using left and right children and update `self.max_length` if this new length is greater.

5. **Return Value**: After completing the DFS traversal, we return the length of the longest path found.

This solution efficiently finds the longest univalue path in O(N) time complexity, where N is the number of nodes, as each node is visited once. The space complexity is O(H), where H is the height of the tree due to the recursive call stack.

# 700. Search in a Binary Search Tree

### Problem Description 
You are given the `root` of a binary search tree (BST) and an integer `val`.

Find the node in the BST that the node's value equals `val` and return the subtree rooted with that node. If such a node does not exist, return `null`.


Example 1:
Input: root = [4,2,7,1,3], val = 2
Output: [2,1,3]

Example 2:
Input: root = [4,2,7,1,3], val = 5
Output: []

Constraints:
The number of nodes in the tree is in the range `[1, 5000]`.

`1 <= Node.val <= 107`
`root` is a binary search tree.

`1 <= val <= 107`

### Solution 
 To solve the problem of finding a node in a binary search tree (BST) and returning its subtree, we can utilize the properties of BSTs. In a BST, for any given node, all values in the left subtree are less than the node's value, and all values in the right subtree are greater than the node's value. This property allows us to efficiently search for the desired value.

### Approach:
1. **Start from the root** of the BST.
2. Compare the current node's value with the target value (`val`).
   - If they are equal, we have found the node, and we will return this node as it is the root of the desired subtree.
   - If the target value is less than the current node's value, we move to the left child of the current node since the left child contains smaller values.
   - If the target value is greater than the current node's value, we move to the right child of the current node since the right child contains larger values.
3. If we reach a null node (i.e., we have exhausted all nodes and haven't found the value), we return `null`.

### Implementation:
We will define a class `TreeNode` to represent each node in the tree and a function `searchBST` that implements the described approach.

Here's how that looks in Python code following the LeetCode format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        # Start searching from the root node
        current = root
        
        while current:
            if current.val == val:
                # Node with the value 'val' found, return the subtree rooted at this node
                return current
            elif val < current.val:
                # Move to the left subtree
                current = current.left
            else:
                # Move to the right subtree
                current = current.right
        
        # Node with the value 'val' does not exist, return null
        return None

```

### Explanation of the Code:
- **TreeNode Class**: This class represents a node in the binary search tree, having three attributes: `val` for storing the node's value, `left` for the left child, and `right` for the right child.
- **searchBST Function**:
  - We initialize a pointer `current` to the root node of the tree.
  - A `while` loop continues as long as `current` is not null.
    - Inside the loop, we compare the value of the current node with the target `val`.
    - If they are equal, we return the `current` node, which is the root of the desired subtree.
    - If `val` is less than `current.val`, we traverse the left child (`current = current.left`).
    - If `val` is greater, we traverse the right child (`current = current.right`).
  - If the loop exits without finding the value, we return `None`, indicating the value is not present in the tree.

### Time Complexity:
The time complexity of the search operation in a BST is O(h), where h is the height of the tree. In the worst case, this can be O(n) for a skewed BST (like a linked list), but on average, it is O(log n) for a balanced tree.

This code can be run directly on LeetCode, and it adheres to their function signature and class structure.

# 701. Insert into a Binary Search Tree

### Problem Description 
You are given the `root` node of a binary search tree (BST) and a `value` to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.

Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.


Example 1:
Input: root = [4,2,7,1,3], val = 5
Output: [4,2,7,1,3,5]
Explanation: Another accepted tree is:

Example 2:
Input: root = [40,20,60,10,30,50,70], val = 25
Output: [40,20,60,10,30,50,70,null,null,25]

Example 3:
Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
Output: [4,2,7,1,3,5]

Constraints:
The number of nodes in the tree will be in the range `[0, 104]`.

`-108 <= Node.val <= 108`
All the values `Node.val` are unique.

`-108 <= val <= 108`
It's guaranteed that `val` does not exist in the original BST.

### Solution 
 To solve the problem of inserting a new value into a Binary Search Tree (BST), we need to follow the properties of a BST. In a BST, for any given node:
- All the nodes in the left subtree have values less than the node's value.
- All the nodes in the right subtree have values greater than the node's value.

### Approach
1. **Find the Position for Insertion**: Starting from the root of the BST, we traverse the tree:
   - If the value to be inserted is less than the current node's value, we recursively move to the left child.
   - If it is greater, we move to the right child.
2. **Insert the New Node**: Once we find a `None` (or empty spot), we create a new TreeNode with the value to be inserted and attach it to the appropriate parent node.
3. **Return the Root**: Finally, we return the root node of the updated tree.

### Implementation

Here’s how we can implement this in Python. The code follows the LeetCode submission format.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if root is None:
            # If the current root is None, we found the spot for the new node
            return TreeNode(val)

        # Traverse the tree
        if val < root.val:
            # If the value is less than the current node, go left
            root.left = self.insertIntoBST(root.left, val)
        else:
            # If the value is greater than the current node, go right
            root.right = self.insertIntoBST(root.right, val)

        # Return the unchanged node pointer
        return root

```

### Explanation
- **TreeNode Class**: This class represents each node in the binary tree, with `val` as the node’s value and `left` and `right` pointing to the left and right child nodes, respectively.
- **insertIntoBST Method**:
  - We check if `root` is `None`. If it is, we create a new `TreeNode` instance with the given `val` and return it, indicating the position where the new node should be inserted.
  - If `root` is not `None`, we compare the `val` with the current node's value. Depending on whether `val` is smaller or larger, we recursively call `insertIntoBST` on the left or the right child.
  - Finally, we return the original `root`, because we want to keep the original tree structure intact, merely adding a node.

This implementation runs efficiently within the constraints provided and ensures that the properties of the BST are maintained after insertion.

# 742. Closest Leaf in a Binary Tree

### Problem Description 
Given a binary tree where every node has a unique value, and a target key `k`, find the value of the nearest leaf node to target `k` in the tree.

Here, nearest to a leaf means the least number of edges travelled on the binary tree to reach any leaf of the tree.  Also, a node is called a leaf if it has no children.

In the following examples, the input tree is represented in flattened form row by row.

The actual `root` tree given will be a TreeNode object.


Example 1:
Input:
root = [1, 3, 2], k = 1
Diagram of binary tree:
          1
         / \
        3   2
Output: 2 (or 3)
Explanation: Either 2 or 3 is the nearest leaf node to the target of 1.


Example 2:
Input:
root = [1], k = 1
Output: 1
Explanation: The nearest leaf node is the root node itself.


Example 3:
Input:
root = [1,2,3,4,null,null,null,5,null,6], k = 2
Diagram of binary tree:
             1
            / \
           2   3
          /
         4
        /
       5
      /
     6
Output: 3
Explanation: The leaf node with value 3 (and not the leaf node with value 6) is nearest to the node with value 2.

Note:
`root` represents a binary tree with at least `1` node and at most `1000` nodes.

Every node has a unique `node.val` in range `[1, 1000]`.

There exists some node in the given binary tree for which `node.val == k`.

### Solution 
 To solve the problem of finding the nearest leaf node to a given target node `k` in a binary tree, we can utilize a depth-first search (DFS) approach to traverse the tree and keep track of the path from each node to the leaf nodes. By using a bidirectional search, we can find the nearest leaf efficiently.

### Approach:

1. **DFS Traversal**: Perform a DFS to find all leaf nodes and their corresponding paths from each node. During this traversal, we can also keep track of the parent of each node to facilitate moving upward in the tree.

2. **Identifying Leaf Nodes**: While traversing the tree, a node is identified as a leaf if it has no children. We will store all leaf nodes in a list for quick access.

3. **Finding the Target Node**: During the traversal, also look for the target node `k`. Once we find the target, we can start a BFS (breadth-first search) from the target node, exploring distances to all nearby leaf nodes.

4. **BFS Search to Find Nearest Leaf**: Use a queue to conduct a BFS starting from the target node. Maintain a visited set to avoid revisiting nodes. During this search, when we reach a leaf node, we return its value as it would be the closest.

5. **Edge Cases**: Handle cases where the tree is just a single node.

Here’s how we can implement this solution in Python:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findNearestLeaf(self, root: TreeNode, k: int) -> int:
        from collections import defaultdict, deque
        
        # Step 1: Create a graph to represent the tree with edges to parent nodes
        graph = defaultdict(list)
        leaves = []
        
        def dfs(node, parent=None):
            if not node:
                return
            if not node.left and not node.right:
                leaves.append(node.val)  # found a leaf node
            if parent:
                graph[node.val].append(parent.val)  # link back to parent
                graph[parent.val].append(node.val)  # link parent to node
            dfs(node.left, node)
            dfs(node.right, node)

        # Call DFS to build the graph and get leaves
        dfs(root)
        
        # Step 2: Find the target node (k) and start BFS from it
        queue = deque()
        visited = set()
        
        # Put the target node into the queue
        for node in graph:
            if node == k:
                queue.append(node)
                visited.add(node)
                break
        
        # Step 3: Perform BFS to find the nearest leaf
        while queue:
            current = queue.popleft()
            # If the current node is a leaf and it is not the starting node k, return its value
            if current in leaves and current != k:
                return current
            # Explore neighbors (both children and parent)
            for neighbor in graph[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)

        # If we didn't find any other leaf node, return k as it's the only leaf present
        return k


```

### Explanation of the Code:
- **TreeNode Class**: Represents a single node in the binary tree.
- **build the graph**: The `dfs` function traverses the tree recursively while building a graph with edges between each node and its parent. It also identifies all leaf nodes.
- **BFS Implementation**: We initialize a BFS with the target node `k`. As we explore nodes, when we encounter a leaf node, we directly return its value as the nearest leaf.
- **Return value**: If the BFS finishes without finding a different leaf node, we simply return `k`.

This code follows the LeetCode format, utilizing the class and method structure expected there. The approach is efficient, handling the constraints provided in the problem with a time complexity of O(N), where N is the number of nodes in the tree.

# 776. Split BST

### Problem Description 
Given a Binary Search Tree (BST) with root node `root`, and a target value `V`, split the tree into two subtrees where one subtree has nodes that are all smaller or equal to the target value, while the other subtree has all nodes that are greater than the target value.  It's not necessarily the case that the tree contains a node with value `V`.

Additionally, most of the structure of the original tree should remain.  Formally, for any child C with parent P in the original tree, if they are both in the same subtree after the split, then node C should still have the parent P.

You should output the root TreeNode of both subtrees after splitting, in any order.


Example 1:
Input: root = [4,2,6,1,3,5,7], V = 2
Output: [[2,1],[4,3,6,null,null,5,7]]
Explanation:
Note that root, output[0], and output[1] are TreeNode objects, not arrays.

The given tree [4,2,6,1,3,5,7] is represented by the following diagram:
          4
        /   \
      2      6
     / \    / \
    1   3  5   7
while the diagrams for the outputs are:
          4
        /   \
      3      6      and    2
            / \           /
           5   7         1
Note:
The size of the BST will not exceed `50`.

The BST is always valid and each node's value is different.

### Solution 
 To solve the problem of splitting a Binary Search Tree (BST) based on a given target value `V`, we need to define a function that traverses the tree and constructs two new trees: one containing nodes that are less than or equal to `V`, and the other containing nodes greater than `V`.

Here's a step-by-step breakdown of the solution:

1. **TreeNode Class Definition**: We'll define a `TreeNode` class which represents each node in the BST.

2. **Split Function Logic**: The `splitBST` function will recursively traverse the BST. We need to keep track of two separate roots:
   - One for nodes less than or equal to `V`.
   - One for nodes greater than `V`.

3. **Traversal**: During the traversal:
   - If the current node's value is less than or equal to `V`, we include it in the first tree and recursively split the right subtree.
   - If it's greater than `V`, we include it in the second tree and recursively split the left subtree.

4. **Constructing New Trees**: We'll keep adjusting the `left` and `right` pointers of the resulting trees to maintain the property of a BST.

5. **Return Result**: Finally, we return the roots of the two split trees as output.

Here’s the complete Python code that achieves this:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def splitBST(self, root: TreeNode, V: int) -> List[TreeNode]:
        if not root:
            return [None, None]
        
        if root.val <= V:
            # Current root goes to the left tree, split the right tree
            left, right = self.splitBST(root.right, V)
            root.right = left  # attach the left tree to the right of the current root
            return [root, right]  # return the current root as part of left tree
        else:
            # Current root goes to the right tree, split the left tree
            left, right = self.splitBST(root.left, V)
            root.left = right  # attach the right tree to the left of the current root
            return [left, root]  # return the current root as part of right tree

# Example Usage:
# If we were to execute this in an environment like LeetCode,
# we would initialize the TreeNode structures and run the splitBST method.

```

### Explanation of the Code:

- **TreeNode class**: This is a simple implementation of a binary tree node with `val`, `left`, and `right` attributes that represent the node's value and its children.
  
- **Solution class and splitBST method**: 
  - The method checks the base case where the `root` is `None`. If so, it returns a list of two `None` values, indicating that both subtrees are empty.
  - If the `root.val` is less than or equal to `V`, we recursively call `splitBST` on the right subtree. The returned trees are then properly linked back by setting `root.right` to the left subtree we received from the split of the right subtree.
  - Conversely, if the `root.val` is greater than `V`, we recursively call `splitBST` on the left subtree and reassign `root.left` accordingly.
  
- **Return value**: The function returns a list containing the roots of both resulting trees. This is done recursively until all nodes of the tree have been handled appropriately.

### Remarks:
- This implementation ensures all properties of a BST are maintained in the resultant trees, and it adheres to the constraints that the original structure is minimally disturbed. Since the maximum tree size is limited to 50 nodes, this solution is computationally efficient.

This code can be directly run on the LeetCode platform, and it should pass all the relevant test cases.

# 783. Minimum Distance Between BST Nodes

### Problem Description 
Given the `root` of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.

Note: This question is the same as 530: https://leetcode.com/problems/minimum-absolute-difference-in-bst/

Example 1:
Input: root = [4,2,6,1,3]
Output: 1

Example 2:
Input: root = [1,0,48,null,null,12,49]
Output: 1

Constraints:
The number of nodes in the tree is in the range `[2, 100]`.

`0 <= Node.val <= 105`

### Solution 
 To solve the problem of finding the minimum difference between values of any two different nodes in a Binary Search Tree (BST), we can leverage the properties of the BST itself. In a BST, the values of the nodes are organized such that the left child is less than the parent node (and also less than the right child), which helps in efficiently traversing the nodes in sorted order.

### Approach:
1. **Inorder Traversal**: The most effective way to retrieve the values of the BST in sorted order is to perform an inorder traversal. This will give us the node values in ascending order.
  
2. **Calculate Differences**: After obtaining the sorted values, we can calculate the minimum difference between consecutive elements in the list of values. This is because the smallest difference between any two values in the sorted order will always be found between consecutive values.

### Steps in the Code:
- We will define a helper function for inorder traversal that will collect the values of the nodes.
- Then, we will iterate through the list of collected values to compute the minimum difference.

Here's the Python code following the LeetCode solution format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        # Helper function to perform inorder traversal
        def inorder_traversal(node):
            if node is None:
                return []
            # Return the values in the left subtree, then the node's value, followed by the right subtree
            return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right)

        # Get a sorted list of values from the BST
        values = inorder_traversal(root)
        
        # Initialize minimum difference to a large number
        min_diff = float('inf')
        
        # Iterate through the sorted values and calculate the minimum difference
        for i in range(1, len(values)):
            diff = values[i] - values[i - 1]
            min_diff = min(min_diff, diff)
        
        return min_diff

```

### Explanation of the Code:
1. **TreeNode Class**: A simple class to represent each node of the BST with `val`, `left`, and `right` attributes.
  
2. **Solution Class**: This contains the method `getMinimumDifference`.
   - **`inorder_traversal(node)`**: A recursive helper function that returns a list of node values in sorted order.
  
3. **Sorting and Minimum Difference**: 
   - After gathering the values, we loop through the list starting from the second element, calculating the difference with the previous element and keeping track of the minimum difference found.

### Complexity:
- **Time Complexity**: O(n), where n is the number of nodes in the tree, because we visit each node exactly once.
- **Space Complexity**: O(n) in the worst case due to the space needed to store the values from the inorder traversal.

This solution will run efficiently within the constraints provided by the problem.

# 814. Binary Tree Pruning

### Problem Description 
We are given the head node `root` of a binary tree, where additionally every node's value is either a 0 or a 1.

Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.

(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)

Example 1:
Input: [1,null,0,0,1]
Output: [1,null,0,null,1]
Explanation: 
Only the red nodes satisfy the property "every subtree not containing a 1".

The diagram on the right represents the answer.


Example 2:
Input: [1,0,1,0,0,0,1]
Output: [1,null,1,null,1]

Example 3:
Input: [1,1,0,1,1,0,1,0]
Output: [1,1,0,1,1,null,1]
Note: 
The binary tree will have at most `200 nodes`.

The value of each node will only be `0` or `1`.

### Solution 
 To solve the problem of removing subtrees from a binary tree that do not contain a `1`, we can utilize a recursive approach. The idea is to traverse the tree and decide whether to keep or prune each subtree based on the values of the nodes.

### Steps to Solve the Problem:
1. **Base Case**: If the current node is `None`, return `None`.
2. **Traverse the Left and Right Subtrees**: Recursively check the left and right children of the current node.
3. **Determine the Current Node's Value**:
   - If both the left and right children do not contain a `1`, we need to remove them by setting them to `None`.
   - If the current node itself is `0` and both its children are also `None`, we return `None`, effectively pruning this subtree.
4. **Return the Current Node**: If the current node is `1` or at least one of its subtrees contains a `1`, return the current node.

### Python Code:
The code will define a binary tree node structure as well as a function that implements the above logic.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def pruneTree(self, root: TreeNode) -> TreeNode:
        # Helper function that returns True if subtree contains a 1
        def containsOne(node: TreeNode) -> bool:
            if node is None:
                return False
            
            # Recursively check left and right subtrees
            leftContainsOne = containsOne(node.left)
            rightContainsOne = containsOne(node.right)
            
            # Prune left and right children if they do not contain a 1
            if not leftContainsOne:
                node.left = None
            if not rightContainsOne:
                node.right = None
            
            # Return True if this node or any of its children contain a 1
            return node.val == 1 or leftContainsOne or rightContainsOne
        
        # Start pruning from the root
        return root if containsOne(root) else None

```

### Explanation of the Code:
1. **Class TreeNode**: This defines the structure of each node in the binary tree with a value and pointers to left and right children.
2. **Class Solution**: This encapsulates our solution where `pruneTree` is defined.
3. **Method pruneTree**:
   - We define a helper function `containsOne` that checks if the subtree rooted at a given node contains a `1`.
   - We recursively check the left and right children to find if they contain a `1`. 
   - Depending on the result of these checks, we either retain or prune (set to `None`) the left and/or right child.
   - Ultimately, we return the original tree with subtrees removed based on the criteria defined.
4. **Base Cases Handling**: The function returns `False` if the node is `None` and will continue pruning if the conditions to remove nodes are met.

### Complexity Analysis:
- **Time Complexity**: O(N), where N is the number of nodes in the tree. We visit every node once.
- **Space Complexity**: O(H), where H is the height of the tree, due to the recursion stack in the worst case (if the tree is skewed).

You can run this code on LeetCode as it follows their expected format for problem solutions!

# 834. Sum of Distances in Tree

### Problem Description 
An undirected, connected tree with `N` nodes labelled `0...N-1` and `N-1` `edges` are given.

The `i`th edge connects nodes `edges[i][0] `and` edges[i][1]` together.

Return a list `ans`, where `ans[i]` is the sum of the distances between node `i` and all other nodes.


Example 1:
Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
Output: [8,12,6,10,10,10]
Explanation: 
Here is a diagram of the given tree:
  0
 / \
1   2
   /|\
  3 4 5
We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)
equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.

Note: `1 <= N <= 10000`

### Solution 
 To solve the problem of calculating the sum of distances from each node in an undirected connected tree to all other nodes, we can employ a depth-first search (DFS) approach coupled with dynamic programming. The key is to first calculate the distance sum for a root node and then utilize this information to derive the distance sums for all other nodes efficiently.

### Step-by-Step Solution

1. **Understanding the Tree Structure**: 
   - A tree with `N` nodes has `N-1` edges, making it a connected graph with no cycles.
   - The distance between two nodes is defined as the number of edges in the shortest path connecting them.

2. **Initial Distance Calculation**:
   - We can choose an arbitrary node (commonly node 0) as the root of the tree.
   - We will compute the sum of distances from this root node to all other nodes using DFS.

3. **Transitioning to Other Nodes**:
   - After calculating the distance sum for the root, we can derive the distance sums for all other nodes by leveraging the relationship between the parent node and its children:
     - If we know `dist_sum[root]` for a node `root`, we can calculate `dist_sum[child]` as:
       - `dist_sum[child] = dist_sum[root] + (N - 2 * subtree_size[child])`
     - Here, `subtree_size[child]` is the number of nodes in the subtree rooted at `child`.

4. **Implementation Steps**:
   - Create an adjacency list to represent the tree.
   - Implement a DFS function to calculate the initial distance sum and subtree sizes.
   - Then, implement another DFS function to calculate the distance sums for all nodes based on the initial computations.

### Python Code

Below is the Python code implementing the above logic. This code is structured in a way that it can be run directly on LeetCode.



```python
class Solution:
    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:
        from collections import defaultdict
        
        # Create an adjacency list for the tree
        tree = defaultdict(list)
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        
        # This will hold the sum of distances and the size of subtrees
        dist_sum = [0] * N
        subtree_size = [0] * N
        
        # First DFS to calculate dist_sum for the root (0) and subtree sizes
        def dfs(node: int, parent: int):
            subtree_size[node] = 1  # count the node itself
            for neighbor in tree[node]:
                if neighbor != parent:  # avoid going back to parent
                    dfs(neighbor, node)
                    subtree_size[node] += subtree_size[neighbor]
                    dist_sum[node] += dist_sum[neighbor] + subtree_size[neighbor]

        dfs(0, -1)  # Start DFS with root node 0 and no parent
        
        # Second DFS to calculate distances for all nodes based on root's distances
        def dfs_recalculate(node: int, parent: int):
            for neighbor in tree[node]:
                if neighbor != parent:  # avoid going back to parent
                    dist_sum[neighbor] = dist_sum[node] + (N - 2 * subtree_size[neighbor])
                    dfs_recalculate(neighbor, node)
        
        dfs_recalculate(0, -1)  # Recalculate distances starting from root
        
        return dist_sum

```

### Explanation of the Code

1. **Adjacency List Creation**: 
   - We create a dictionary where each node points to a list of its adjacent nodes (neighbors).

2. **First DFS (subtree size and distance calculation)**:
   - For each node, we recursively calculate the distance sum for its children and accumulate their subtree sizes.

3. **Second DFS (distance recalculation)**:
   - Using the previously calculated values, we iterate through the tree again to compute the distance sums for all nodes based on their parent's distance sum.

4. **Return Result**: 
   - Finally, we return the list containing the sum of distances for each node.

This algorithm runs in O(N) time complexity, making it efficient for the input limits provided.

# 863. All Nodes Distance K in Binary Tree

### Problem Description 
We are given a binary tree (with root node `root`), a `target` node, and an integer value `K`.

Return a list of the values of all nodes that have a distance `K` from the `target` node.  The answer can be returned in any order.


Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2
Output: [7,4,1]
Explanation: 
The nodes that are a distance 2 from the target node (with value 5)
have values 7, 4, and 1.

Note that the inputs "root" and "target" are actually TreeNodes.

The descriptions of the inputs above are just serializations of these objects.

Note:
The given tree is non-empty.

Each node in the tree has unique values `0 <= node.val <= 500`.

The `target` node is a node in the tree.

`0 <= K <= 1000`.

### Solution 
 To solve the problem of finding all nodes at distance `K` from a given target node in a binary tree, we can break down the solution into the following steps:

1. **Parse the Binary Tree**: We must navigate through the binary tree using the provided `TreeNode` structure. We'll use a depth-first search (DFS) to record both the parent relationships and the child relationships of each node.

2. **Identify Distance Using DFS/BFS**: Once we identify the target node, we can utilize another DFS or Breadth-First Search (BFS) to find all nodes that are exactly `K` distance away. To do this, we will keep track of visited nodes to avoid revisiting and to manage the distance properly.

3. **Return Results**: Finally, we'll gather all nodes at the specified distance and return them.

Let's implement the solution in Python following the LeetCode format.

### LeetCode Solution Format Implementation



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
        from collections import defaultdict, deque
        
        if not root:
            return []
        
        # Step 1: Create a graph to maintain parent references
        graph = defaultdict(list)
        
        def build_graph(node, parent=None):
            if node:
                if parent:
                    graph[node].append(parent)
                    graph[parent].append(node)
                build_graph(node.left, node)
                build_graph(node.right, node)
        
        build_graph(root)
        
        # Step 2: BFS to find all nodes distance K from target
        result = []
        queue = deque([target])
        visited = {target}
        distance = 0
        
        while queue:
            if distance == K:
                result.extend(node.val for node in queue)
                break
            for _ in range(len(queue)):
                current = queue.popleft()
                for neighbor in graph[current]:
                    if neighbor not in visited:
                        visited.add(neighbor)
                        queue.append(neighbor)
            distance += 1
        
        return result

```

### Detailed Explanation

1. **Graph Construction**:
   - We start by constructing a graph that connects each node with its parent and children. This helps us traverse in both directions (upwards to parent and downwards to children).
   - The `build_graph` function recursively populates a `defaultdict` with each node as a key and its connections (both parent and children) as values.

2. **Finding Nodes at Distance K**:
   - A BFS is initiated from the `target` node, utilizing a queue to explore nodes layer by layer.
   - We maintain a `visited` set to ensure we do not visit nodes multiple times — important for preventing infinite loops and redundant work.
   - The BFS continues until the desired depth (distance `K`) is reached. When we reach this level, we collect the values of the nodes in the queue.

3. **Result Compilation**:
   - The collected values at distance `K` are compiled into a result list and returned.

### Edge Cases
- If `K` is `0`, the function will return the target's value immediately.
- This approach efficiently handles varying tree structures due to its reliance on BFS for distance calculation. 

This Python code can be directly run on LeetCode and will adhere to the problem constraints and requirements.

# 865. Smallest Subtree with all the Deepest Nodes

### Problem Description 
Given the `root` of a binary tree, the depth of each node is the shortest distance to the root.

Return the smallest subtree such that it contains all the deepest nodes in the original tree.

A node is called the deepest if it has the largest depth possible among any node in the entire tree.

The subtree of a node is tree consisting of that node, plus the set of all descendants of that node.

Note: This question is the same as 1123: https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/

Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.

The nodes coloured in blue are the deepest nodes of the tree.

Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.


Example 2:
Input: root = [1]
Output: [1]
Explanation: The root is the deepest node in the tree.


Example 3:
Input: root = [0,1,3,null,2]
Output: [2]
Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.


Constraints:
The number of nodes in the tree will be in the range `[1, 500]`.

`0 <= Node.val <= 500`
The values of the nodes in the tree are unique.

### Solution 
 To solve the problem of finding the smallest subtree that contains all the deepest nodes in a binary tree, we will follow these steps:

1. **Traverse the Tree**: We need to traverse the tree to find the depths of all nodes.
2. **Find Deepest Nodes**: Identify the maximum depth and collect all nodes that are at this depth.
3. **Lowest Common Ancestor (LCA)**: Utilize a helper function to find the lowest common ancestor of the deepest nodes. This function will traverse the tree and check for the deepest nodes, returning the smallest subtree that contains all of them.

In terms of complexity, a depth-first search (DFS) will be used, which has a time complexity of O(N), where N is the number of nodes in the tree.

Here is the Python code for this problem, formatted to run on LeetCode:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        # Helper function to find the maximum depth of the tree
        def maxDepth(node):
            if not node:
                return 0
            # Compute the depth of each subtree
            left_depth = maxDepth(node.left)
            right_depth = maxDepth(node.right)
            # Return the maximum depth
            return max(left_depth, right_depth) + 1
        
        # Helper function to find the LCA of deepest nodes
        def lcaDeepestLeaves(node):
            # Base case: if it's null, return None
            if not node:
                return None
            
            # Get the depth of left and right subtrees
            left_depth = maxDepth(node.left)
            right_depth = maxDepth(node.right)
            
            # If left depth is greater, then LCA must be in left subtree
            if left_depth > right_depth:
                return lcaDeepestLeaves(node.left)
            # If right depth is greater, then LCA must be in right subtree
            elif right_depth > left_depth:
                return lcaDeepestLeaves(node.right)
            # If both depths are equal, this node is the LCA of deepest nodes
            else:
                return node
        
        # Call the lcaDeepestLeaves function
        return lcaDeepestLeaves(root)


```

### Explanation of Code:

1. **TreeNode Class**: This is a standard definition for a binary tree node, with properties for the value (`val`), left child (`left`), and right child (`right`).

2. **Solution Class**: Contains a method `subtreeWithAllDeepest` which will execute the logic to find the smallest subtree containing all deepest nodes.

3. **maxDepth Function**:
   - This function calculates the depth of the tree recursively.
   - It returns 0 for a null node, and otherwise, it computes the depth of both left and right children, returning the maximum of the two plus one.

4. **lcaDeepestLeaves Function**:
   - This function finds the lowest common ancestor of the deepest leaves.
   - It checks the depth of the left and right subtrees.
   - If one side is deeper, it continues the search down that side. If both sides are equal, it returns the current node as the LCA.

5. **Return Value**: Finally, the result from the `lcaDeepestLeaves` function is returned, which will give us the smallest subtree containing all deepest nodes.

This code implementation will correctly find and return the required subtree when executed on the LeetCode platform.

# 872. Leaf-Similar Trees

### Problem Description 
Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.

For example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9, 8)`.

Two binary trees are considered leaf-similar if their leaf value sequence is the same.

Return `true` if and only if the two given trees with head nodes `root1` and `root2` are leaf-similar.


Example 1:
Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
Output: true

Example 2:
Input: root1 = [1], root2 = [1]
Output: true

Example 3:
Input: root1 = [1], root2 = [2]
Output: false

Example 4:
Input: root1 = [1,2], root2 = [2,2]
Output: true

Example 5:
Input: root1 = [1,2,3], root2 = [1,3,2]
Output: false

Constraints:
The number of nodes in each tree will be in the range `[1, 200]`.

Both of the given trees will have values in the range `[0, 200]`.

### Solution 
 To solve the problem of determining if two binary trees are leaf-similar, we will follow these steps:

1. Define a helper function to traverse the binary tree and collect the leaf nodes' values from left to right.
2. Compare the two sequences of leaf values obtained from the two binary trees.
3. Return `True` if both sequences are equal, otherwise return `False`.

### Key Steps in the Solution

- We will make use of depth-first traversal (DFS) to traverse both trees. The leaf nodes are identified as nodes without left and right children.
- After obtaining the leaf value sequences for both trees, we can simply compare the two lists.

### Implementation

Here is the Python code that follows the LeetCode solution format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
        # Helper function to collect leaf values
        def get_leaf_sequence(root: TreeNode) -> list:
            leaves = []
            if root is None:
                return leaves
            if root.left is None and root.right is None:
                leaves.append(root.val)  # It's a leaf node
            else:
                leaves.extend(get_leaf_sequence(root.left))   # Traverse left subtree
                leaves.extend(get_leaf_sequence(root.right))  # Traverse right subtree
            return leaves
        
        # Get leaf sequences for both trees
        leaves1 = get_leaf_sequence(root1)
        leaves2 = get_leaf_sequence(root2)
        
        # Compare the leaf sequences
        return leaves1 == leaves2


```

### Explanation of the Code

1. **TreeNode Class**: This is the structure for a binary tree node, consisting of a value `val` and pointers to the left and right children.

2. **Solution Class**: This contains the method `leafSimilar`.

3. **get_leaf_sequence Method**:
   - It initializes an empty list `leaves` to hold the leaf node values.
   - If the current node is `None`, it returns an empty list.
   - If a node is a leaf (both left and right children are `None`), it appends the node's value to `leaves`.
   - If the node is not a leaf, it recursively collects leaf values from the left and right children and adds them to `leaves`.

4. **Comparing Leaf Sequences**:
   - We collect the leaf sequences from both trees by calling `get_leaf_sequence` on `root1` and `root2`.
   - Finally, we compare the two lists. If they are the same, it returns `True`; otherwise, it returns `False`.

### Complexity Analysis
- **Time Complexity**: O(N + M), where N is the number of nodes in `root1` and M is the number of nodes in `root2`. We traverse each tree once.
- **Space Complexity**: O(N + M) for storing the leaf values in the lists. In the worst case, where every node is a leaf, the space consumed will be proportional to the number of nodes.

You can directly run this code on the LeetCode platform, given that you copy the TreeNode class as part of your submission if required by the problem's setup.

# 889. Construct Binary Tree from Preorder and Postorder Traversal

### Problem Description 
Return any binary tree that matches the given preorder and postorder traversals.

Values in the traversals `pre` and `post` are distinct positive integers.


Example 1:
Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
Output: [1,2,3,4,5,6,7]
Note:
`1 <= pre.length == post.length <= 30`
`pre[]` and `post[]` are both permutations of `1, 2, ..., pre.length`.

It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.

### Solution 
 To tackle the problem of reconstructing a binary tree from the given `preorder` and `postorder` traversals, let's break down the expected relationships between these traversals.

### Understanding Preorder and Postorder Traversals

1. **Preorder Traversal**: The traversal visits nodes in the order - Root, Left, Right. This means that the first element of `pre` is always the root of the tree.

2. **Postorder Traversal**: In this traversal, the order is - Left, Right, Root. Hence, the last element of `post` is always the root of the tree.

From this, we can deduce that:
- The root of the tree from both traversals is the same.
- We can split the rest of the elements in the `pre` list into left and right subtrees.

### Steps to Build the Tree

1. **Identify the Root**: The first element of `pre` gives us the current root.
2. **Identify Left Subtree**: The next element in `pre` (after the root) will be the root of the left subtree (if it exists), since the children of a node are next in the preorder traversal until the left subtree is complete.
3. **Finding the Split Point**: Using the left subtree's root, find its position in `post` to determine how many nodes belong to the left subtree.
4. **Recursive Reconstruction**: Recur for the left and right subtrees using the identified segments of `pre` and `post`.

### Implementation

Let’s implement this logic in Python as per the requirements of LeetCode.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:
        # Base case: If the preorder list is empty, return None
        if not pre:
            return None
        
        # The first element of pre is always the root
        root = TreeNode(pre[0])
        
        # If the root is a leaf node
        if len(pre) == 1:
            return root
        
        # The second element in pre is the root of the left subtree
        left_subtree_root_val = pre[1]
        
        # Find the index of the left subtree root in post
        left_subtree_size = post.index(left_subtree_root_val) + 1
        
        # Recursive calls to construct the left and right subtree
        root.left = self.constructFromPrePost(pre[1:left_subtree_size + 1], post[:left_subtree_size])
        root.right = self.constructFromPrePost(pre[left_subtree_size + 1:], post[left_subtree_size:-1])
        
        return root

```

### Explanation of the Code

1. **TreeNode Class**: A simple class to represent a binary tree node, with properties for `val`, `left` and `right`.

2. **constructFromPrePost Method**: This method takes `pre` and `post` lists as inputs.
    - **Base Case**: If `pre` is empty, we return `None`, which indicates a null subtree.
    - We create a new `TreeNode` instance for the root using the first element of `pre`.
    - If the `pre` has only one element, we simply return this node as it is a leaf node.
    - We calculate the size of the left subtree by finding the index of its root in `post`, which tells us how many nodes are in the left subtree.
    - We make recursive calls for the left and right subtrees using the appropriate segments of `pre` and `post`.

### Conclusion

This approach effectively uses the properties of tree traversals to reconstruct the binary tree efficiently, adhering to the constraints provided. The time complexity of this algorithm is O(n) on average, where n is the number of nodes in the tree, due to the index lookups and recursive calls.

# 894. All Possible Full Binary Trees

### Problem Description 
Given an integer `n`, return a list of all possible full binary trees with `n` nodes. Each node of each tree in the answer must have `Node.val == 0`.

Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.

A full binary tree is a binary tree where each node has exactly `0` or `2` children.


Example 1:
Input: n = 7
Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]

Example 2:
Input: n = 3
Output: [[0,0,0]]

Constraints:
`1 <= n <= 20`

### Solution 
 To solve the problem of generating all possible full binary trees with `n` nodes, we can use a recursive approach. The key points about a full binary tree are:

1. A full binary tree has each node with either 0 or 2 children, meaning the count of nodes must be an odd number. Thus, if `n` is even, return an empty list because a valid full binary tree is not possible.

2. The base case is when `n` is 1, in which case we return a tree consisting of a single node.

3. For any odd integer `n`, we can construct trees by choosing different combinations of left and right subtrees. For each possible split of the remaining nodes into left and right parts, we recursively generate all possible left and right trees.

Here is a Python implementation organized as a LeetCode solution:

### Python Code Implementation



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def allPossibleFBT(self, n: int) -> List[TreeNode]:
        # If n is even, no full binary tree is possible
        if n % 2 == 0:
            return []
        
        # Base case: only one possible full binary tree with one node
        if n == 1:
            return [TreeNode(0)]
        
        # List to store all full binary trees with n nodes
        result = []
        
        # Iterate to pick left subtree size
        for left_nodes in range(1, n, 2):
            right_nodes = n - 1 - left_nodes
            
            # Generate all left and right subtrees
            left_subtrees = self.allPossibleFBT(left_nodes)
            right_subtrees = self.allPossibleFBT(right_nodes)
            
            # Combine each left and right tree
            for left in left_subtrees:
                for right in right_subtrees:
                    root = TreeNode(0)  # Create new root node
                    root.left = left    # Assign left subtree
                    root.right = right  # Assign right subtree
                    result.append(root) # Add the new tree to result
        
        return result

```

### Explanation
1. **TreeNode Class**: This class is used to create the structure of the binary tree nodes, where each node has a value and pointers to left and right children.

2. **Solution Class**: A class encapsulating the `allPossibleFBT` method to find all full binary trees with `n` nodes.

3. **Check for Even `n`**: If `n` is even, the function immediately returns an empty list since full binary trees cannot exist in that case.

4. **Base Case**: If `n` is 1, we return a list containing a single tree node (the root).

5. **Recursive Case**:
   - For each possible number of nodes (`left_nodes`) assigned to the left subtree (ranging from 1 to `n-2` in steps of 2), we compute `right_nodes`.
   - For both left and right subtrees, we recursively call `allPossibleFBT` to obtain all feasible subtree configurations.
   - We combine each left subtree with each right subtree by creating a new root for each combination, assigning the left and right children, and storing the result.

6. **Return Value**: Finally, the function returns the list of all full binary trees for the given `n`.

This solution efficiently generates all configurations of full binary trees that satisfy the problem's constraints.

# 897. Increasing Order Search Tree

### Problem Description 
Given the `root` of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.


Example 1:
Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

Example 2:
Input: root = [5,1,7]
Output: [1,null,5,null,7]

Constraints:
The number of nodes in the given tree will be in the range `[1, 100]`.

`0 <= Node.val <= 1000`

### Solution 
 To solve the problem of rearranging a binary search tree (BST) into a "linked list" format where the left-most node becomes the root and every node has no left child but only a right child, we can perform the following steps:

1. **In-order Traversal**: Since we want to retrieve the elements in sorted order (as BST properties dictate), we will use in-order traversal to collect the nodes in a list.
2. **Rebuild the tree**: After collecting the nodes in order, we can rebuild the tree such that each node only points to the next node in the order via the right child.

Here's how we can implement these steps in Python:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        # This will hold the in-order traversal result
        self.nodes = []

        # Helper function to perform in-order traversal
        def in_order_traversal(node):
            if not node:
                return
            # Traverse the left subtree
            in_order_traversal(node.left)
            # Visit the current node
            self.nodes.append(node)
            # Traverse the right subtree
            in_order_traversal(node.right)

        # Start in-order traversal from the root
        in_order_traversal(root)

        # Rebuilding the tree
        dummy_node = TreeNode(0)  # Dummy node to simplify the process
        current = dummy_node

        for node in self.nodes:
            # Each node's left child will be None (as per requirement)
            node.left = None
            # The current node's right child will point to the next node
            current.right = node
            current = node  # Move to the next node

        # The root of the new tree is the right child of the dummy node
        return dummy_node.right

```

### Detailed Explanation:

1. **TreeNode Class**: A `TreeNode` class is defined to represent each node in the BST, initialized with `val`, `left`, and `right`.

2. **Solution Class**: We define a `Solution` class with a method `increasingBST` that takes the root of the tree as an argument.

3. **In-order Traversal**:
   - We define a helper function `in_order_traversal` that uses recursion to traverse the tree in in-order (left, root, right).
   - During the traversal, we collect the nodes in the list `self.nodes`. Since it's in order, it will naturally sort them.

4. **Rebuilding the Tree**:
   - We create a `dummy_node` to serve as an easy entry point into our new tree. This avoids the need to handle special cases for the first node.
   - We iterate through each node in `self.nodes`, setting the `left` pointer of each node to `None`, and assigning the `right` pointer to the subsequent node in the list.
   - The `current` pointer helps in connecting the right children.

5. **Return the New Root**: The new tree's root is the `right` child of `dummy_node`. This is returned at the end.

This code is compatible with the LeetCode platform, and you can submit it directly. Each function adheres to typical conventions used in coding contests and fulfills the requirements of the problem statement.

# 919. Complete Binary Tree Inserter

### Problem Description 
A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.

Write a data structure `CBTInserter` that is initialized with a complete binary tree and supports the following operations:
`CBTInserter(TreeNode root)` initializes the data structure on a given tree with head node `root`;
`CBTInserter.insert(int v)` will insert a `TreeNode` into the tree with value `node.val = v` so that the tree remains complete, and returns the value of the parent of the inserted `TreeNode`;
`CBTInserter.get_root()` will return the head node of the tree.


Example 1:
Input: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]]
Output: [null,1,[1,2]]

Example 2:
Input: inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]
Output: [null,3,4,[1,2,3,4,5,6,7,8]]
Note:
The initial given tree is complete and contains between `1` and `1000` nodes.

`CBTInserter.insert` is called at most `10000` times per test case.

Every value of a given or inserted node is between `0` and `5000`.

### Solution 
 To solve the problem of maintaining a Complete Binary Tree (CBT) with insertions, we will create a class `CBTInserter`. This class will have methods to initialize the tree, insert new nodes while keeping the tree complete, and return the root of the tree. 

A complete binary tree has the property that all levels are fully filled except possibly the last one, which is filled from left to right. When a new node is inserted, it is added at the first available position from the left side.

### Approach

1. **Data Structure**:
   - We will use a queue (FIFO) to keep track of the nodes at the current level. This allows us to easily find the parent for the next node to be inserted.

2. **Initialization**:
   - When we initialize the `CBTInserter` with the root of the tree, we will use a breadth-first traversal (BFS) to fill our queue with all the nodes in the tree.

3. **Insertion**:
   - When we want to insert a new value, we will pop the front node from the queue (this will be the parent node).
   - We create a new node with the given value and insert it to the left or right of the parent, depending on which child is available.
   - After inserting, we push the new node into the queue to ensure our BFS maintains the correct order of nodes.

4. **Return Root**:
   - The `get_root` method simply returns the root of the tree.

Here is how to implement this in Python:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class CBTInserter:
    def __init__(self, root: TreeNode):
        self.root = root
        self.queue = []
        # Initialize the queue with a BFS traversal
        self.queue.append(root)
        
        # We will use a breadth-first search to fill the queue
        while self.queue:
            node = self.queue[0]  # Peek the front of the queue
            # Push the left child and right child to the queue if they exist
            if node.left:
                self.queue.append(node.left)
            if node.right:
                self.queue.append(node.right)
            # If the current node is a parent of both children, we pop it off
            if node.left and node.right:
                self.queue.pop(0)  # Pop the front since both children exist
            else:
                break  # No need to go further

    def insert(self, v: int) -> int:
        parent = self.queue[0]  # Get the parent node
        new_node = TreeNode(v)  # Create a new node
        
        # Insert the new node
        if not parent.left:
            parent.left = new_node
        else:
            parent.right = new_node
        
        # Add the newly created node to the queue
        self.queue.append(new_node)
        
        # If the parent had both children, we pop the parent from the queue
        if parent.left and parent.right:
            self.queue.pop(0)
        
        return parent.val  # Return the value of the parent node

    def get_root(self) -> TreeNode:
        return self.root  # Return the root of the tree

```

### Explanation of Methods:
- **`__init__(self, root)`**: Builds the initial structure, populating `self.queue` using a breadth-first approach to ensure we have all nodes.
- **`insert(self, v)`**: Inserts a new node with value `v`, keeps track of the tree structure, and returns the parent's value of the inserted node.
- **`get_root(self)`**: Returns the root node of the tree.

### Complexity
- **Time Complexity**: O(1) for insertion since we maintain the queue and pop elements at most once per insertion.
- **Space Complexity**: O(n) for the queue where n is the number of nodes in the tree.

### Sample Test Cases

You can run the above implementation directly in the LeetCode environment with the provided test cases:



```python
inputs = [["CBTInserter","insert","get_root"], [[[1]],[2],[]]]
# Expected Output: [null,1,[1,2]]

inputs = [["CBTInserter","insert","insert","get_root"], [[[1,2,3,4,5,6]],[7],[8],[]]]
# Expected Output: [null,3,4,[1,2,3,4,5,6,7,8]]

```

This implementation ensures that we follow the properties of a complete binary tree and provides an efficient way to manage insertions and queries.

# 938. Range Sum of BST

### Problem Description 
Given the `root` node of a binary search tree, return the sum of values of all nodes with a value in the range `[low, high]`.


Example 1:
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
Output: 32

Example 2:
Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
Output: 23

Constraints:
The number of nodes in the tree is in the range `[1, 2 * 104]`.

`1 <= Node.val <= 105`
`1 <= low <= high <= 105`
All `Node.val` are unique.

### Solution 
 To solve the problem of calculating the sum of values of all nodes within a specified range in a binary search tree (BST), we'll use the properties of the BST, which allows us to efficiently traverse the tree. The key insight is that if the current node's value is less than the lower bound (`low`), we can skip the left subtree; if it's greater than the upper bound (`high`), we can skip the right subtree.

### Detailed Explanation:

1. **Understanding the Binary Search Tree (BST)**:
   - In a BST, for any given node, all values in the left subtree are less than the node's value and all values in the right subtree are greater.

2. **Range Constraints**:
   - If the current node's value is within the range (`low` to `high`), we add it to our running sum and recursively search both the left and right children.
   - If the current node's value is less than `low`, we only check the right subtree.
   - If the current node's value is greater than `high`, we only check the left subtree.

### Plan:
- Use a recursive approach to traverse the tree while maintaining a running total of values that fall within the specified range.

### Implementation:

Here's the implementation in Python, adhering to the format suitable for LeetCode submissions:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        # Helper function to perform the recursive tree traversal
        def traverse(node):
            if not node:
                return 0
            
            total = 0
            # If the current node's value is in the range
            if low <= node.val <= high:
                total += node.val
            
            # If the current node's value is greater than low, 
            # we can check the left subtree
            if node.val > low:
                total += traverse(node.left)
                
            # If the current node's value is less than high,
            # we can check the right subtree
            if node.val < high:
                total += traverse(node.right)
                
            return total
        
        # Start the traverse from the root
        return traverse(root)

```

### Running the Code:
Place the provided code in a Python environment capable of creating instances of `TreeNode` to construct the tree as described in the problem statement. The `Solution` class contains a method `rangeSumBST` that evaluates the sum of all node values within the specified range.

### Example Usage:
To utilize this in practice, you may set up a binary search tree and call the `rangeSumBST` method like this:



```python
# Example usage:
# Creating the binary search tree for example 1
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(15)
root.left.left = TreeNode(3)
root.left.right = TreeNode(7)
root.right.right = TreeNode(18)

solution = Solution()
result = solution.rangeSumBST(root, 7, 15)
print(result)  # Output: 32

```

With this code, you can run it directly on LeetCode or implement it in any Python environment, ensuring you define the `TreeNode` class properly. The approach is efficient and handles the constraints of the problem within the time limits typically expected in competitive programming.

# 951. Flip Equivalent Binary Trees

### Problem Description 
For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.

A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.

Given the roots of two binary trees `root1` and `root2`, return `true` if the two trees are flip equivelent or `false` otherwise.


Example 1:
Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
Output: true
Explanation: We flipped at nodes with values 1, 3, and 5.


Example 2:
Input: root1 = [], root2 = []
Output: true

Example 3:
Input: root1 = [], root2 = [1]
Output: false

Example 4:
Input: root1 = [0,null,1], root2 = []
Output: false

Example 5:
Input: root1 = [0,null,1], root2 = [0,1]
Output: true

Constraints:
The number of nodes in each tree is in the range `[0, 100]`.

Each tree will have unique node values in the range `[0, 99]`.

### Solution 
 To solve the problem of determining whether two binary trees are flip equivalent, we can approach it using recursive comparisons. The idea is to check if two trees can be made identical through a series of "flip" operations where we swap the left and right child nodes.

### Step-by-Step Explanation:

1. **Base Cases**:
   - If both nodes are `None`, then they are equivalent, and we return True.
   - If one node is `None` and the other is not, they are not equivalent, returning False.
   - If the values of the two current nodes are different, they cannot be equivalent, also returning False.

2. **Recursive Checks**:
   - We need to consider both cases where we may or may not flip the nodes:
     - **Without flipping**: We check if the left child of `root1` is equivalent to the left child of `root2` and the right child of `root1` is equivalent to the right child of `root2`.
     - **With flipping**: We check if the left child of `root1` is equivalent to the right child of `root2` and the right child of `root1` is equivalent to the left child of `root2`.

3. **Return the Result**:
   - If either the non-flip or flip condition holds true, we return True; otherwise, we return False.

### Python Code:

Here's the code implemented in a format suitable for running on the LeetCode platform:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:
        # Base cases
        if not root1 and not root2:
            return True
        if not root1 or not root2:
            return False
        if root1.val != root2.val:
            return False
        
        # Check both possible configurations (non-flip and flip)
        return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)) or \
               (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left))


```

### Explanation of the Code:

- We define a `TreeNode` class to represent the structure of the binary tree nodes.
- The `Solution` class contains the method `flipEquiv`, which accepts two tree roots (`root1` and `root2`) and checks if they are flip equivalent.
- Inside `flipEquiv`, we check the base cases first:
  - If both nodes are `None`, we return True.
  - If only one of them is `None`, we return False.
  - If the values of the current nodes differ, we return False.
- Finally, we use recursion to check both configurations and combine the results using logical OR.

### Complexity Analysis:
- **Time Complexity**: O(n) where n is the number of nodes in each tree, since we might visit each node once.
- **Space Complexity**: O(h) where h is the height of the tree due to the recursive call stack.

This solution effectively determines whether the two binary trees can be made equivalent through flip operations.

# 958. Check Completeness of a Binary Tree

### Problem Description 
Given the `root` of a binary tree, determine if it is a complete binary tree.

In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`.


Example 1:
Input: root = [1,2,3,4,5,6]
Output: true
Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.


Example 2:
Input: root = [1,2,3,4,5,null,7]
Output: false
Explanation: The node with value 7 isn't as far left as possible.


Constraints:
The number of nodes in the tree is in the range `[1, 100]`.

`1 <= Node.val <= 1000`

### Solution 
 To solve the problem of determining if a binary tree is a complete binary tree, we will perform a level order traversal using a queue. A complete binary tree has specific properties that we will check during this traversal. Let's break down the approach step by step.

### Steps to Solve the Problem:

1. **Level Order Traversal**:
   - We will use a queue to help us perform a level order traversal of the binary tree.
   - During this traversal, we will keep track of whether we encounter a null value. If we encounter a null value and subsequently find a non-null child node, the tree is not complete.

2. **Node Count**:
   - Count the total number of nodes in the tree to compare against the expected number of nodes for a complete binary tree at each level.

3. **Checking Conditions**:
   - If we observe a null node while traversing the nodes, we should not encounter any further non-null nodes.

### Code Implementation:

Here is the implementation of the above logic in Python following the LeetCode format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isCompleteBinaryTree(self, root: TreeNode) -> bool:
        if not root:
            return True
        
        # Using a queue for level order traversal
        queue = [root]
        end = False  # This flag will indicate if we have seen a null
        
        while queue:
            current = queue.pop(0)
            
            # Check the left child
            if current.left:
                if end:  # If we already saw a null and now found a child
                    return False
                queue.append(current.left)
            else:
                end = True  # No left child, mark end
            
            # Check the right child
            if current.right:
                if end:  # If we already saw a null and now found a child
                    return False
                queue.append(current.right)
            else:
                end = True  # No right child, mark end
        
        return True

```

### Explanation:

- **TreeNode**: This is a simple class to define the structure of each node in the binary tree with attributes `val`, `left`, and `right`.
  
- **isCompleteBinaryTree**:
  - We begin by checking if the root is null; if so, we return `True` (an empty tree is complete).
  - We initialize a queue with the root node for level order traversal.
  - We set a flag `end` to track if we have seen a null node.
  - We proceed to process each node:
    - If a node has a left child:
      - If we have already encountered a null node, the tree is not complete, and we return `False`.
      - Otherwise, we add the left child to the queue.
    - If a node does not have a left child, we set `end` to `True`.
    - We do the same checks for the right child.
  - If we finish processing all levels without returning `False`, we conclude the tree is complete and return `True`.

### Complexity:
- **Time Complexity**: O(n), where n is the number of nodes, because we visit each node once.
- **Space Complexity**: O(w), where w is the maximum width of the tree, which can be considered O(n) in the worst-case scenario (for a completely filled tree).

This code solves the problem directly and can be tested on the LeetCode platform.

