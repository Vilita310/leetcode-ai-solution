# 965. Univalued Binary Tree

### Problem Description 
A binary tree is univalued if every node in the tree has the same value.

Return `true` if and only if the given tree is univalued.


Example 1:
Input: [1,1,1,1,1,null,1]
Output: true

Example 2:
Input: [2,2,2,5,2]
Output: false
Note:
The number of nodes in the given tree will be in the range `[1, 100]`.

Each node's value will be an integer in the range `[0, 99]`.

### Solution 
 To solve the problem of determining if a binary tree is univalued (i.e., all nodes in the tree have the same value), we can use a depth-first search (DFS) traversal approach. 

### Detailed Explanation:

1. **Understanding a Binary Tree**: A binary tree consists of nodes, each having a value and potentially up to two children (left and right). The tree is represented as a starting node, called the root.

2. **Univalued Property**: The tree is univalued if every node has the same value. For example, a tree like this:
   
```
       1
      / \
     1   1
    / \
   1   1
   
```
   is univalued, while a tree like this:
   
```
       2
      / \
     2   2
    / \
   5   2
   
```
   is not because of the "5" node.

3. **Approach**:
   - We can traverse the tree using either recursive DFS or iterative DFS using a stack.
   - During the traversal, we will check if every value matches the value of the root node. If we find any node with a different value, we return `False`. If we complete the traversal without finding any discrepancies, we return `True`.

4. **Implementation**: Here is the solution in Python, formatted according to LeetCode requirements.

### Python Code:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isUnivalTree(self, root: TreeNode) -> bool:
        # Helper function to perform DFS
        def dfs(node, value):
            # If we reach a None node, return True
            if not node:
                return True
            # Check if the current node's value matches the given value
            if node.val != value:
                return False
            # Recursively check left and right subtrees
            return dfs(node.left, value) and dfs(node.right, value)

        # Start DFS from the root node
        return dfs(root, root.val) if root else True

```

### Key Points:

- **TreeNode Class**: This is the class definition for our tree nodes, with an initializer to set the value and left/right children.
- **isUnivalTree Method**: This is the main method to check if the tree is univalued.
  - It initiates a depth-first traversal starting from the `root` using the `dfs` helper function.
- **dfs Function**: 
  - It checks if the current node is `None` (base case for recursion).
  - It checks if the node's value matches the value of the root.
  - It recursively checks the left and right children.
- **Edge Cases**: If the tree is empty (`root` is `None`), we return `True`, indicating that an empty tree is trivially univalued.

This code will run efficiently for the constraints provided (up to 100 nodes), and it properly checks the univalued property of the binary tree as required.

# 968. Binary Tree Cameras

### Problem Description 
Given a binary tree, we install cameras on the nodes of the tree. 
Each camera at a node can monitor its parent, itself, and its immediate children.

Calculate the minimum number of cameras needed to monitor all nodes of the tree.


Example 1:
Input: [0,0,null,0,0]
Output: 1
Explanation: One camera is enough to monitor all nodes if placed as shown.


Example 2:
Input: [0,0,null,0,null,0,null,null,0]
Output: 2
Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.

Note:
The number of nodes in the given tree will be in the range `[1, 1000]`.

Every node has value 0.

### Solution 
 To solve the problem of placing cameras in a binary tree to monitor all nodes, we can use a depth-first search (DFS) approach with a post-order traversal. The idea is to traverse the tree and decide the camera placement based on the states of each node and its children. 

### States for Each Node:
1. **0**: The node is not monitored.
2. **1**: The node has a camera.
3. **2**: The node is monitored but does not have a camera.

### Approach:
1. Implement a recursive DFS function that evaluates each node.
2. Depending on the states of its children, determine what state the current node should be in.
3. Count the number of cameras needed based on the rules:
   - If a child is not monitored (state 0), we need to place a camera at the current node (increment camera count).
   - If a child has a camera (state 1), the current node is monitored, and we do not need to place a camera here.
   - If a child is monitored but does not have a camera (state 2), the current node is also monitored.

4. The root node must eventually be checked to ensure it is monitored, and if it isn't (state 0), we place a camera on it.

### Code Implementation:
Hereâ€™s how the implementation looks in Python, following the LeetCode format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def minCameraCover(self, root: TreeNode) -> int:
        self.camera_count = 0
        
        # Helper function for DFS traversal
        def dfs(node):
            if not node:
                return 2  # If the node is null, it's considered monitored (state 2)

            left = dfs(node.left)
            right = dfs(node.right)

            # If either child is not monitored, we place a camera here
            if left == 0 or right == 0:
                self.camera_count += 1
                return 1  # Current node has camera (state 1)

            # If either child has a camera, current node is monitored
            if left == 1 or right == 1:
                return 2  # Current node is monitored (state 2)

            return 0  # Current node is not monitored (state 0)

        # Start DFS from the root
        if dfs(root) == 0:
            self.camera_count += 1  # If root is not monitored, add a camera

        return self.camera_count

```

### Explanation of the Code:
- We define a `TreeNode` class for the nodes of the binary tree.
- We create a `Solution` class that contains the `minCameraCover` method.
- Inside `minCameraCover`, we initialize a `camera_count` to keep track of the number of cameras used.
- The `dfs` function processes each node recursively. For each node, it checks the states of its children:
  - If either child is not monitored (state 0), we place a camera at the current node and increment the camera count.
  - If one of the children has a camera (state 1), then the current node is covered.
  - If both children are monitored without cameras (state 2), the current node is not monitored, returning state 0.
- After DFS completes, we check if the root itself is monitored, and if not, we add one more camera.
- Finally, the method returns the total camera count.

This algorithm efficiently determines the minimum number of cameras needed to monitor each node in the binary tree using a post-order traversal method with a time complexity of O(n), where n is the number of nodes in the tree.

# 971. Flip Binary Tree To Match Preorder Traversal

### Problem Description 
You are given the `root` of a binary tree with `n` nodes, where each node is uniquely assigned a value from `1` to `n`. You are also given a sequence of `n` values `voyage`, which is the desired pre-order traversal of the binary tree.

Any node in the binary tree can be flipped by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:
Flip the smallest number of nodes so that the pre-order traversal of the tree matches `voyage`.

Return a list of the values of all flipped nodes. You may return the answer in any order. If it is impossible to flip the nodes in the tree to make the pre-order traversal match `voyage`, return the list `[-1]`.


Example 1:
Input: root = [1,2], voyage = [2,1]
Output: [-1]
Explanation: It is impossible to flip the nodes such that the pre-order traversal matches voyage.


Example 2:
Input: root = [1,2,3], voyage = [1,3,2]
Output: [1]
Explanation: Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.


Example 3:
Input: root = [1,2,3], voyage = [1,2,3]
Output: []
Explanation: The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.


Constraints:
The number of nodes in the tree is `n`.

`n == voyage.length`
`1 <= n <= 100`
`1 <= Node.val, voyage[i] <= n`
All the values in the tree are unique.

All the values in `voyage` are unique.

### Solution 
 To solve the problem of matching a binary tree's pre-order traversal to a specified sequence by flipping nodes, we can employ a depth-first search (DFS) approach.

### Explanation of the Solution

1. **Tree Structure**: 
   We will define a binary tree node structure using a class, which contains values and pointers to left and right children.

2. **Traversal Approach**: 
   We will perform a pre-order traversal on the binary tree. In a typical pre-order traversal:
   - Visit the current node
   - Recursively visit the left subtree
   - Recursively visit the right subtree
   
   However, in this problem, if the current node doesn't match the current index of the `voyage`, we must check if we can flip the node's left and right children (i.e., swap them) to try and achieve a match. If flipping leads to a match, we log that node as flipped.

3. **Flipping Logic**: 
   - If the left child node matches the expected node from `voyage`, we continue down the left subtree.
   - If it does not match but the right child does, we will flip the current node, consider it flipped, and proceed with the right subtree.
   - If neither matches, it indicates that it's impossible to match the current state with `voyage`.

4. **Edge Cases**: 
   - If at any point we cannot match values, we return `[-1]`.
   - If the traversal completes successfully with records of which nodes were flipped, we return that list.

### Implementation

Let's implement this in Python, following the LeetCode format.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def flipMatchVoyage(self, root: TreeNode, voyage: list[int]) -> list[int]:
        self.index = 0  # Index in the voyage list
        self.flipped = []  # List to store flipped node values
        self.possible = True  # Flag to indicate if a match is still possible
        
        def dfs(node):
            if not node:
                return
            
            if self.index >= len(voyage) or node.val != voyage[self.index]:
                self.possible = False
                return
            
            self.index += 1
            
            # If there's a left child, check if it should be flipped based on voyage
            if node.left and self.index < len(voyage) and node.left.val != voyage[self.index]:
                # We flip if the left child does not match the voyage
                self.flipped.append(node.val)  # Record the current node as flipped
                node.left, node.right = node.right, node.left  # Flip the children
            
            # Continue DFS on both children, left first
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)  # Start DFS
        return self.flipped if self.possible else [-1]  # Return result based on possible flag

```

### Conclusion

In this code:
- We use a `dfs` helper function to explore the tree recursively.
- It keeps track of the current index in `voyage`, checks for matches, and flips nodes when necessary.
- If the tree can be matched with `voyage`, we return the list of flipped nodes; otherwise, we return `[-1]`. 

This efficient approach adheres to the constraints provided while ensuring all possible flipping combinations are considered. The time complexity is O(n) where n is the number of nodes, as each node is visited once.

# 979. Distribute Coins in Binary Tree

### Problem Description 
You are given the `root` of a binary tree with `n` nodes where each `node` in the tree has `node.val` coins and there are `n` coins total.

In one move, we may choose two adjacent nodes and move one coin from one node to another. (A move may be from parent to child, or from child to parent.)
Return the number of moves required to make every node have exactly one coin.


Example 1:
Input: root = [3,0,0]
Output: 2
Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.


Example 2:
Input: root = [0,3,0]
Output: 3
Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.


Example 3:
Input: root = [1,0,2]
Output: 2

Example 4:
Input: root = [1,0,0,null,3]
Output: 4

Constraints:
The number of nodes in the tree is `n`.

`1 <= n <= 100`
`0 <= Node.val <= n`
The sum of `Node.val` is `n`.

### Solution 
 To solve the problem of redistributing coins in a binary tree so that each node has exactly one coin, we can use a Depth First Search (DFS) approach. We need to traverse the tree while tracking how many excess or deficit coins each node has. The main idea is to count the total number of moves required to balance the coins across the nodes.

For each node:
- If a node has more than one coin, we need to move the excess coins to its children (or up to its parent).
- If a node has fewer than one coin, we need to receive coins from its parent or children.

The total number of moves is essentially the sum of the absolute values of excess or deficit coins at each node (taking care to not count moves redundantly). For each node, when we calculate the excess (or deficit) in the coins, we also consider the moves needed to balance the child nodes before returning back up the tree.

Here's how we can implement this solution in Python, formatted for the LeetCode platform:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def distributeCoins(self, root: TreeNode) -> int:
        # This variable stores the total moves required
        moves = 0

        def dfs(node: TreeNode) -> int:
            nonlocal moves   # We access the outer scope variable moves
            
            if not node:   # If the current node is None, return 0
                return 0
            
            # Recur for left and right subtrees to get the coins balance
            left = dfs(node.left)
            right = dfs(node.right)
            
            # Calculate the total coins (including current node)
            total_coins = left + right + node.val
            
            # Calculate how many moves are needed to balance this node 
            # Since we need 1 coin per node, nodes that aren't balanced will
            # contribute their excess (or deficit) to the moves
            moves += abs(left) + abs(right)

            # Return the number of excess coins the current node will have
            # If total_coins > 1, this node can give some coins away,
            # if total_coins < 1, this node needs coins.
            return total_coins - 1

        # Start DFS from the root
        dfs(root)
        
        # Return the total number of moves
        return moves

# Example usage:
# Creating the binary tree from the example [3,0,0]
root = TreeNode(3)
root.left = TreeNode(0)
root.right = TreeNode(0)

# Create an instance of Solution and call the method
solution = Solution()
print(solution.distributeCoins(root))  # Output: 2

```

### Explanation:
1. **TreeNode Class**: This class defines the structure of each node in the binary tree.
2. **Solution Class**: This contains our main method `distributeCoins`.
3. **DFS Function**:
   - It recursively traverses the tree.
   - For each node, it calculates how many excess coins are produced by the left and right subtrees.
   - It keeps track of the total moves needed by accumulating the absolute values of the excess from the child nodes. 
   - After operating on child nodes, it computes the total coins at the current node and determines how many moves will be needed based on the deficit or surplus coins.
4. **Final Return**: After the DFS traversal, the required moves are returned from the `distributeCoins` method.

This approach ensures that we efficiently calculate the required moves using a single depth-first traversal of the tree.

# 987. Vertical Order Traversal of a Binary Tree

### Problem Description 
Given the `root` of a binary tree, calculate the vertical order traversal of the binary tree.

For each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.

The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.

Return the vertical order traversal of the binary tree.


Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: [[9],[3,15],[20],[7]]
Explanation:
Column -1: Only node 9 is in this column.

Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.

Column 1: Only node 20 is in this column.

Column 2: Only node 7 is in this column.


Example 2:
Input: root = [1,2,3,4,5,6,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
Column -2: Only node 4 is in this column.

Column -1: Only node 2 is in this column.

Column 0: Nodes 1, 5, and 6 are in this column.

          1 is at the top, so it comes first.

          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.

Column 1: Only node 3 is in this column.

Column 2: Only node 7 is in this column.


Example 3:
Input: root = [1,2,3,4,6,5,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
This case is the exact same as example 2, but with nodes 5 and 6 swapped.

Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.


Constraints:
The number of nodes in the tree is in the range `[1, 1000]`.

`0 <= Node.val <= 1000`

### Solution 
 To solve the problem of vertical order traversal in a binary tree, we need to keep track of the relative column and row positions of each node as we traverse the tree. The approach will utilize a breadth-first search (BFS) strategy, typically implemented using a queue. Here is the detailed explanation and the solution in the LeetCode format.

### Solution Explanation

1. **Data Structure**:
   - We'll use a dictionary `column_map` that maps each column index to a list of tuples. Each tuple will contain the row index and the node's value. This allows us to easily sort nodes by their positions.

2. **Traversal**:
   - We perform a BFS traversal starting from the root of the tree. For each node:
     - We will push its left child to the queue with column index decreased by 1 and row index increased by 1.
     - We will push its right child to the queue with column index increased by 1 and row index increased by 1.

3. **Sorting and Preparing the Output**:
   - After the traversal, the dictionary will contain all nodes grouped by their column index.
   - To get the final output, we need to sort the columns, and for each column, sort the nodes first by their row index and then by the node value.

4. **Edge Cases**:
   - The algorithm will handle cases where multiple nodes are at the same position by sorting them according to their values in the list.

### Implementation

Here is the complete Python code that implements the above logic:



```python
from collections import defaultdict, deque

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []

        # A map of column index to list of (row index, node value)
        column_map = defaultdict(list)
        # Queue for BFS: contains tuples (node, row, col)
        queue = deque([(root, 0, 0)])  # (node, row, column)

        while queue:
            node, row, col = queue.popleft()
            column_map[col].append((row, node.val))

            if node.left:
                queue.append((node.left, row + 1, col - 1))
            if node.right:
                queue.append((node.right, row + 1, col + 1))

        # Prepare the output list
        result = []
        for col in sorted(column_map.keys()):
            # Sort by row first, and then by value
            result.append([val for row, val in sorted(column_map[col])])

        return result

```

### Key Points:
- **Data Structures**: A `defaultdict` for the column mapping and a `deque` for BFS traversal.
- **Complexity**: The time complexity is O(N log N), where N is the number of nodes, due to the sorting step for the output, while space complexity is O(N) due to the storage of the `column_map`.
- **Sorting Mechanism**: Both the column sorting and the tuple sorting ensure that we maintain the correct vertical order traversal as specified.

This complete implementation follows the LeetCode structure, ensuring that it can be copied and run directly on their platform.

# 988. Smallest String Starting From Leaf

### Problem Description 
Given the `root` of a binary tree, each node has a value from `0` to `25` representing the letters `'a'` to `'z'`: a value of `0` represents `'a'`, a value of `1` represents `'b'`, and so on.

Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root.

(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, `"ab"` is lexicographically smaller than `"aba"`.  A leaf of a node is a node that has no children.)

Example 1:
Input: [0,1,2,3,4,3,4]
Output: "dba"

Example 2:
Input: [25,1,3,1,3,0,2]
Output: "adz"

Example 3:
Input: [2,2,1,null,1,0,null,0]
Output: "abc"
Note:
The number of nodes in the given tree will be between `1` and `8500`.

Each node in the tree will have a value between `0` and `25`.

### Solution 
 To solve the problem of finding the lexicographically smallest string starting from a leaf of a binary tree and ending at the root, we can use Depth First Search (DFS) to explore all paths from the leaves to the root. Here's the detailed explanation and the code implementation in the LeetCode format.

### Problem Explanation:

1. **Representation of the Binary Tree**: Each node in the tree contains a value between `0` and `25`, which corresponds to letters `a` to `z`. A value of `0` represents `a`, `1` represents `b`, and so forth.
  
2. **Leaf Nodes**: Leaf nodes are defined as nodes that do not have left or right children. Our task is to find the path from any leaf node to the root and construct strings based on the node values.

3. **Lexicographical Order**: When comparing strings, we need to ensure that we return the smallest string in lexicographical order. For instance, `"ab"` is smaller than `"aba"`.

### Approach:

1. Use Depth First Search (DFS) to traverse the tree from the root down to the leaves.
2. While traversing, construct the string from the leaf back to the root.
3. Use a variable to keep track of the smallest string encountered during the traversal.

### Code Implementation:

Here is the implementation of the above approach in Python:



```python
# Definition for the binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def smallestFromLeaf(self, root: TreeNode) -> str:
        # This will hold the smallest string found
        self.smallest = None
        
        # Depth First Search (DFS) function
        def dfs(node: TreeNode, path: str):
            if not node:
                return
            
            # Prepend the character corresponding to current node's value
            path = chr(node.val + ord('a')) + path
            
            # If we reach a leaf node, we compare the path to the smallest found
            if not node.left and not node.right:
                if self.smallest is None or path < self.smallest:
                    self.smallest = path
            
            # Continue DFS on the left and right children
            dfs(node.left, path)
            dfs(node.right, path)
        
        # Start DFS from the root
        dfs(root, "")
        
        # Return the smallest string found
        return self.smallest if self.smallest is not None else ""

# Example usage:
# You would typically instantiate the tree and call Solution().smallestFromLeaf(root)

```

### Explanation of the Code:

1. **TreeNode Class**: Represents a single node in the binary tree. Each node has a value and optional left and right children.

2. **Solution Class and Method**: We define a `Solution` class with the method `smallestFromLeaf`. This method initializes a variable `self.smallest` to track the smallest string.

3. **DFS Function**: The nested `dfs` function:
    - Checks if the current node is `None`. If it is, it returns.
    - Prepares a string `path` that consists of the character corresponding to the current node's value.
    - If the node is a leaf, it compares the current `path` with `self.smallest` and updates if it's smaller.
    - Recursively visits the left and right children of the current node.

4. **Traversal Initiation**: We start the DFS traversal from the root, passing an empty string as the initial path.

5. **Return Statement**: Finally, the method returns the smallest string found, or an empty string if no paths were found.

This code can be directly run on the LeetCode website, ensuring that it adheres to their expectations for tree operations and string manipulation.

# 993. Cousins in Binary Tree

### Problem Description 
In a binary tree, the root node is at depth `0`, and children of each depth `k` node are at depth `k+1`.

Two nodes of a binary tree are cousins if they have the same depth, but have different parents.

We are given the `root` of a binary tree with unique values, and the values `x` and `y` of two different nodes in the tree.

Return `true` if and only if the nodes corresponding to the values `x` and `y` are cousins.


Example 1:
Input: root = [1,2,3,4], x = 4, y = 3
Output: false

Example 2:
Input: root = [1,2,3,null,4,null,5], x = 5, y = 4
Output: true

Example 3:
Input: root = [1,2,3,null,4], x = 2, y = 3
Output: false

Constraints:
The number of nodes in the tree will be between `2` and `100`.

Each node has a unique integer value from `1` to `100`.

### Solution 
 To solve the problem of determining if two nodes in a binary tree are cousins, we need to perform a level-order traversal (or breadth-first search) of the tree, tracking the depth of each node and its parent. Here's how we can achieve this step-by-step:

1. **Understanding Cousins**: Two nodes are cousins if:
   - They are at the same depth in the tree (i.e., they are the same distance from the root).
   - They have different parents.

2. **Tree Traversal**: We will use a queue to perform a level-order traversal of the tree. We'll store both the node and its parent in the queue as we traverse.

3. **Depth Tracking**: As we traverse, we will keep track of the level (or depth) of each node.

4. **Node Value Tracking**: When we find the values `x` and `y`, we will record their corresponding depths and parents.

5. **Cousin Check**: Finally, we check if the depths of `x` and `y` are the same and if their parents are different.

Below is the Python code implementing this logic following the LeetCode solution format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        from collections import deque
        
        # Queue for BFS (node, parent)
        queue = deque([(root, None)])   
        # Variables to hold the depth and parent of x and y
        x_depth = y_depth = -1
        x_parent = y_parent = None
        
        # Initialize depth
        depth = 0
        
        # Perform level-order traversal
        while queue:
            for _ in range(len(queue)):
                node, parent = queue.popleft()
                
                # Check if the current node is x or y
                if node.val == x:
                    x_depth, x_parent = depth, parent
                elif node.val == y:
                    y_depth, y_parent = depth, parent
                
                # Add the children to the queue
                if node.left:
                    queue.append((node.left, node))
                if node.right:
                    queue.append((node.right, node))
                
            # After processing one level, increment the depth
            depth += 1
            
            # If we've found both x and y, we can break early
            if x_depth != -1 and y_depth != -1:
                break
        
        # Check if x and y are cousins
        return x_depth == y_depth and x_parent != y_parent

```

### Explanation of the Code:
- **TreeNode Class**: Defines the structure of each node in the binary tree.
- **Solution Class**: Contains the method `isCousins`.
- **isCousins Method**:
   1. Initialize a queue to facilitate level-order traversal.
   2. Keep track of the depth of the tree and the parent of the nodes found with values `x` and `y`.
   3. Traverse the tree level by level using a while loop. For each node processed, check if it matches `x` or `y`.
   4. If both nodes have been found, break out of the loop early to avoid unnecessary additional traversal.
   5. Finally, check if the nodes are cousins based on their recorded depths and parents, and return the result.

### Time Complexity:
The algorithm runs in O(N) time where N is the number of nodes in the tree since each node is visited once.

### Space Complexity:
The space complexity is O(W) where W is the maximum width of the tree, which can be at most N in the worst case, such as a complete binary tree.

# 998. Maximum Binary Tree II

### Problem Description 
We are given the `root` node of a maximum tree: a tree where every node has a value greater than any other value in its subtree.

Just as in the previous problem, the given tree was constructed from an list `A` (`root = Construct(A)`) recursively with the following `Construct(A)` routine:
If `A` is empty, return `null`.

Otherwise, let `A[i]` be the largest element of `A`.  Create a `root` node with value `A[i]`.

The left child of `root` will be `Construct([A[0], A[1], ..., A[i-1]])`
The right child of `root` will be `Construct([A[i+1], A[i+2], ..., A[A.length - 1]])`
Return `root`.

Note that we were not given A directly, only a root node `root = Construct(A)`.

Suppose `B` is a copy of `A` with the value `val` appended to it.  It is guaranteed that `B` has unique values.

Return `Construct(B)`.


Example 1:
Input: root = [4,1,3,null,null,2], val = 5
Output: [5,4,null,1,3,null,null,2]
Explanation: A = [1,4,2,3], B = [1,4,2,3,5]

Example 2:
Input: root = [5,2,4,null,1], val = 3
Output: [5,2,4,null,1,null,3]
Explanation: A = [2,1,5,4], B = [2,1,5,4,3]

Example 3:
Input: root = [5,2,3,null,1], val = 4
Output: [5,2,4,null,1,3]
Explanation: A = [2,1,5,3], B = [2,1,5,3,4]

Constraints:
`1 <= B.length <= 100`

### Solution 
 To solve the problem of inserting a new value into a maximum binary tree, we will first need to reconstruct the original array from the given tree. We can then insert the new value into this array and create a new maximum tree using that modified array.

Here's how we can approach this step by step:

### Step 1: Reconstruct the Array
We will traverse the maximum tree and create a list `A` of values based on the nodes of the tree. We'll use a pre-order traversal technique to collect the values.

### Step 2: Insert the New Value
After reconstructing the array `A`, we will append the new value `val` to `A`, resulting in `B`.

### Step 3: Construct the New Maximum Tree
We will implement a recursive function that constructs the maximum tree from the modified list `B` just like how the original tree was constructed.

Here's the implementation of the above steps in a LeetCode compatible format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
        # Step 1: Reconstruct the original array A from the max tree
        def getValues(node: TreeNode, values: list):
            if not node:
                return
            values.append(node.val)
            getValues(node.left, values)
            getValues(node.right, values)

        A = []  # This will hold the values of the current maximum tree
        getValues(root, A)
        
        # Step 2: Append the new value to A to create B
        B = A + [val]

        # Step 3: Construct the new maximum tree from B
        def constructMaxTree(nums: list) -> TreeNode:
            if not nums:
                return None

            max_val = max(nums)
            max_index = nums.index(max_val)

            root = TreeNode(max_val)
            root.left = constructMaxTree(nums[:max_index])  # Left part
            root.right = constructMaxTree(nums[max_index + 1:])  # Right part
            return root

        return constructMaxTree(B)

```

### Explanation of the Code:

1. **TreeNode Definition**: We define a simple `TreeNode` class representing each node of the tree.

2. **Solution Class**: The main class where the solution logic is implemented.

3. **getValues Function**: This helper function recursively traverses the tree in a pre-order manner. Whenever it encounters a node, it appends its value to the `values` list.

4. **insertIntoMaxTree Method**:
   - We first initialize an empty list `A` to hold values and call `getValues` to populate it from the tree.
   - Next, we create a new list `B` by appending the new value `val` to `A`.
   - Lastly, we call the `constructMaxTree` function to build the new maximum tree.

5. **constructMaxTree Function**: This recursive function creates the maximum tree from the list of values. It finds the maximum value to be the root, splits the list into left and right subarrays, and constructs left and right subtrees recursively.

This code can be directly run on LeetCode after you define the `TreeNode` class, as shown, and implement the `insertIntoMaxTree` method within the `Solution` class. The complexity of the solution is O(n) for the reconstruction and construction processes, making it efficient given the constraints.

# 1008. Construct Binary Search Tree from Preorder Traversal

### Problem Description 
Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.

It is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases.

A binary search tree is a binary tree where for every node, any descendant of `Node.left` has a value strictly less than `Node.val`, and any descendant of `Node.right` has a value strictly greater than `Node.val`.

A preorder traversal of a binary tree displays the value of the node first, then traverses `Node.left`, then traverses `Node.right`.


Example 1:
Input: preorder = [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]

Example 2:
Input: preorder = [1,3]
Output: [1,null,3]

Constraints:
`1 <= preorder.length <= 100`
`1 <= preorder[i] <= 108`
All the values of `preorder` are unique.

### Solution 
 To address the problem of constructing a binary search tree (BST) from a given preorder traversal array, we can utilize a recursive approach. Let's outline the solution step-by-step, then provide the Python code formatted for direct execution on LeetCode.

### Steps to Solve the Problem:

1. **Understanding Preorder Traversal**: The first item in the preorder array represents the root of the tree. The subsequent elements can be partitioned into two groups: those that are less than the root value (which will form the left subtree) and those that are greater than the root value (which will form the right subtree).

2. **Recursive Construction**: 
   - We will define a recursive function that:
     - Takes a slice of the preorder array as the current subtree.
     - The first element of this slice will be the root.
     - It will partition the rest of the elements into left and right subtrees.
     - It will repeat this process until all elements are placed in the tree.

3. **Base and Recursive Cases**: The base case for our recursion will be when the current slice of the preorder list is empty. The recursive case will involve determining the position of the elements to form the left and right subtrees based on the value of the root.

4. **TreeNode Definition**: We will define a class `TreeNode` to represent each node in the tree, which contains a value and pointers to the left and right children.

### Implementation:

Hereâ€™s the Python code that implements the above logic:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def bstFromPreorder(self, preorder):
        # Helper function to recursively construct the BST
        def build_bst(preorder, bound):
            if not preorder or preorder[0] > bound:
                return None
            
            # The first element is always the root of the current subtree
            root_val = preorder.pop(0)
            root = TreeNode(root_val)
            
            # All values that are less than root_val will go to the left
            root.left = build_bst(preorder, root_val)
            # All values that are greater than root_val will go to the right
            root.right = build_bst(preorder, bound)
            
            return root
        
        # Call the helper function with an infinite bound for the initial call
        return build_bst(preorder, float('inf'))

```

### Explanation of the Code:

1. **TreeNode Class**: This class initializes a node with a value, and pointers to its left and right children.

2. **Solution Class**: This class contains the method `bstFromPreorder`, which is the main method to construct the BST.
  
3. **build_bst Function**: This recursive helper function does the heavy lifting.
   - It checks if the preorder list is empty or if the first value exceeds the currently allowed upper bound (`bound`).
   - If valid, it takes the first value from the list as the root and creates a `TreeNode`.
   - It then recursively constructs the left child (with the current root value as the new bound) and the right child (with the same upper bound).
  
4. **Initial Call**: The function starts with an infinitely large bound to allow any value for the initial root.

### Testing:
When you run the function with the given examples, it will construct the tree and return the root. The produced binary search tree will have the properties required by the initial problem statement. 

This code is structured in a way that's compatible with the LeetCode environment, allowing you to run it without modifications.

# 1022. Sum of Root To Leaf Binary Numbers

### Problem Description 
You are given the `root` of a binary tree where each node has a value `0` or `1`.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is `0 -> 1 -> 1 -> 0 -> 1`, then this could represent `01101` in binary, which is `13`.

For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.

Return the sum of these numbers. The answer is guaranteed to fit in a 32-bits integer.


Example 1:
Input: root = [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22

Example 2:
Input: root = [0]
Output: 0

Example 3:
Input: root = [1]
Output: 1

Example 4:
Input: root = [1,1]
Output: 3

Constraints:
The number of nodes in the tree is in the range `[1, 1000]`.

`Node.val` is `0` or `1`.

### Solution 
 To solve the problem of summing up the binary numbers represented by the root-to-leaf paths in a binary tree, we can use a depth-first search (DFS) approach. 

Hereâ€™s a step-by-step explanation of the algorithm:

1. **Understanding the Tree Structure**: Each node in the tree can either be `0` or `1`. The path from the root to any leaf node can be interpreted as a binary number, where the root is the most significant bit.

2. **Binary Number Representation**: As we traverse down the tree, we can maintain an integer value that represents the binary number formed from the path. When we move from a parent node to a child node, we can shift the current value left (equivalent to multiplying it by 2) and then add the child nodeâ€™s value.

3. **Base Case**: When we reach a leaf node (a node with no children), we will store its complete integer value which represents the binary number formed from the path.

4. **Recursive Traversal**: We will perform a DFS starting from the root and on reaching a leaf node we will add its value to a cumulative sum.

5. **Return Value**: After finishing the traversal of the tree, we return the cumulative sum.

Hereâ€™s the actual implementation of the above approach, formatted to run on LeetCode:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        def dfs(node: TreeNode, current_sum: int) -> int:
            if not node:  # base case: if node is None
                return 0
            
            # Update the current sum as a binary number
            current_sum = current_sum * 2 + node.val
            
            # If we're at a leaf node, return the current sum
            if not node.left and not node.right:
                return current_sum
            
            # Continue DFS traversal down the children
            left_sum = dfs(node.left, current_sum)
            right_sum = dfs(node.right, current_sum)
            
            # Return the sum of both left and right children
            return left_sum + right_sum
        
        return dfs(root, 0)  # Start DFS with initial sum as 0

```

### Explanation of the Code:

1. **TreeNode Definition**: We begin by defining the `TreeNode` class, which describes the structure of the tree nodes.

2. **Solution Class**: The `Solution` class contains the method `sumNumbers`, which initializes the DFS traversal.

3. **DFS Function**: The nested `dfs` function takes two parameters: the current node and the path sum (`current_sum`):
   - If the current node is `None`, we return `0`.
   - Otherwise, we calculate the current sum by shifting it left (multiplying by `2`) and adding the current node's value.
   - If we reach a leaf node, we return the `current_sum`.
   - If not, we recursively call `dfs` for the left and right children and return their combined sums.

4. **Return the Final Result**: The result of `dfs(root, 0)` is the total sum of all the binary numbers represented by root-to-leaf paths.

This solution efficiently traverses the tree and calculates the sum in a single pass, making it optimal and suitable for the given problem constraints.

# 1026. Maximum Difference Between Node and Ancestor

### Problem Description 
Given the `root` of a binary tree, find the maximum value `V` for which there exist different nodes `A` and `B` where `V = |A.val - B.val|` and `A` is an ancestor of `B`.

A node `A` is an ancestor of `B` if either: any child of `A` is equal to `B`, or any child of `A` is an ancestor of `B`.


Example 1:
Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]
Output: 7
Explanation: We have various ancestor-node differences, some of which are given below :
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.


Example 2:
Input: root = [1,null,2,null,0,3]
Output: 3

Constraints:
The number of nodes in the tree is in the range `[2, 5000]`.

`0 <= Node.val <= 105`

### Solution 
 To solve the problem of finding the maximum difference between ancestor and descendant values in a binary tree, we can use a depth-first search (DFS) approach.

The idea is to traverse the tree, keeping track of the minimum and maximum values encountered from the root to the current node. Whenever we visit a node, we calculate the possible differences between the current node's value and the minimum and maximum values seen so far. This way, we can update our maximum difference anytime we visit a new node.

Here is the step-by-step explanation and the Python code following LeetCode's format:

### Step-by-Step Explanation:

1. **Tree Structure**: We will define a TreeNode class to represent each node of the binary tree. Each node has a value and pointers to its left and right children.
  
2. **DFS Function**: We will implement a recursive function that:
   - Takes a node, the current minimum value, and the current maximum value as parameters.
   - Updates the minimum and maximum values based on the current node's value.
   - Recursively calls itself for the left and right children of the current node to traverse the entire tree.
   - At each node, calculates the difference between the current node's value and the minimum and maximum values encountered so far.

3. **Maximum Difference**: We maintain a variable to store the maximum difference found. This variable gets updated as we find larger differences during the DFS traversal.

4. **Base Case**: If the node is `None`, we return early as there are no values to process.

### Python Code:

Here is how this approach can be implemented in Python:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxAncestorDiff(self, root: TreeNode) -> int:
        def dfs(node, min_val, max_val):
            if not node:
                return max_val - min_val
            
            # Update the min and max values encountered so far
            min_val = min(min_val, node.val)
            max_val = max(max_val, node.val)
            
            # Recursively call for left and right children
            left_diff = dfs(node.left, min_val, max_val)
            right_diff = dfs(node.right, min_val, max_val)
            
            return max(left_diff, right_diff)

        # Initial call with the value of root as both min and max
        return dfs(root, root.val, root.val)

# Example usage
# root = TreeNode(8)
# root.left = TreeNode(3)
# root.right = TreeNode(10)
# root.left.left = TreeNode(1)
# root.left.right = TreeNode(6)
# root.left.right.left = TreeNode(4)
# root.left.right.right = TreeNode(7)
# root.right.right = TreeNode(14)
# root.right.right.left = TreeNode(13)
# solution = Solution()
# print(solution.maxAncestorDiff(root))  # This would print 7

```

### Explanation of the Code:

- **TreeNode Class**: This class is a representation of each node in the binary tree.
- **Solution Class**: Contains the `maxAncestorDiff` function, which initializes the DFS.
- **DFS Function**: Takes the current node, and the current minimum and maximum values. It returns the maximum difference found in the subtrees, updating min and max values at each step.
- **Initial Call**: We start the DFS with the root value as both the `min_val` and `max_val`, ensuring we capture the full range of ancestor values.

This code can be directly copied and run on LeetCode for this specific problem.

# 1028. Recover a Tree From Preorder Traversal

### Problem Description 
We run a preorder depth-first search (DFS) on the `root` of a binary tree.

At each node in this traversal, we output `D` dashes (where `D` is the depth of this node), then we output the value of this node.  If the depth of a node is `D`, the depth of its immediate child is `D + 1`.  The depth of the `root` node is `0`.

If a node has only one child, that child is guaranteed to be the left child.

Given the output `S` of this traversal, recover the tree and return its `root`.


Example 1:
Input: S = "1-2--3--4-5--6--7"
Output: [1,2,5,3,4,6,7]

Example 2:
Input: S = "1-2--3---4-5--6---7"
Output: [1,2,5,3,null,6,null,4,null,7]

Example 3:
Input: S = "1-401--349---90--88"
Output: [1,401,null,349,88,90]

Constraints:
The number of nodes in the original tree is in the range `[1, 1000]`.

`1 <= Node.val <= 109`

### Solution 
 To solve the problem of recovering a binary tree from a given preorder DFS traversal string, we need to parse the string `S` which contains node values and depth indicators (dashes) representing the structure of the tree. The depth of each node is indicated by the number of dashes before the node's value. 

Here's a step-by-step breakdown of the approach:

1. **Initialization**: Start by initializing a stack to keep track of the nodes and their respective depths as we parse through the string.

2. **Parse the String**: As we iterate through the string, we will count the number of dashes to determine the depth of the current node. Any number after the dashes relates to a node value.

3. **Tree Construction**: Using the depth information, we will:
   - If the current depth is greater than the depth of the last node in our stack, this means we are adding a left child to the last node in the stack.
   - If the current depth is less than the depth of the last node in our stack, we will backtrack up the stack until we find a node at the correct depth to attach the current node as its right child.

4. **Return Value**: Finally, return the root of the constructed tree.

Here's how this solution can be implemented in Python following the LeetCode solution format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def recoverFromPreorder(self, S: str) -> TreeNode:
        stack = []
        i = 0
        n = len(S)
        
        while i < n:
            # Count the level (depth) based on dashes
            depth = 0
            while i < n and S[i] == '-':
                depth += 1
                i += 1
            
            # Read the node value
            val = 0
            while i < n and S[i].isdigit():
                val = val * 10 + int(S[i])
                i += 1
            
            # Create a new TreeNode with the value we just parsed
            current_node = TreeNode(val)
            
            # If this is a new node at the tree's current depth
            if depth == len(stack):
                # Attach to the left of the last node in the stack
                if stack:
                    stack[-1].left = current_node
            else:
                # We are in a different depth, so we need to `pop` from the stack
                while depth < len(stack):
                    stack.pop()
                
                # Attach to the right of the last node in the stack
                if stack:
                    stack[-1].right = current_node
            
            # Add the current node to the stack
            stack.append(current_node)
        
        # The first node is the root
        return stack[0]

```

### Explanation of the Code:
- **TreeNode Class**: A basic TreeNode class is defined to represent each node of the binary tree.
- **recoverFromPreorder Method**: This is the main method that performs the reconstruction of the tree from the given string.
  - We initialize a `stack` to keep track of the current path in the tree.
  - We iterate through the string `S`, counting dashes to determine the depth and reading the numeric value for each TreeNode.
  - Depending on the depth of the current node relative to the previous nodes in the stack, we either create a left child or a right child appropriately.
  - Finally, the root of the tree (the first node added to the stack) is returned.

### Complexity:
The time complexity of this algorithm is O(N), where N is the length of the string `S`, since we must process each character once. The space complexity is O(N) in the worst case due to the stack holding the nodes. 

With this implementation, you can directly run the code on the LeetCode platform to solve the problem.

# 1038. Binary Search Tree to Greater Sum Tree

### Problem Description 
Given the `root` of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.

As a reminder, a binary search tree is a tree that satisfies these constraints:
The left subtree of a node contains only nodes with keys less than the node's key.

The right subtree of a node contains only nodes with keys greater than the node's key.

Both the left and right subtrees must also be binary search trees.

Note: This question is the same as 538: https://leetcode.com/problems/convert-bst-to-greater-tree/

Example 1:
Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

Example 2:
Input: root = [0,null,1]
Output: [1,null,1]

Example 3:
Input: root = [1,0,2]
Output: [3,3,2]

Example 4:
Input: root = [3,2,4,1]
Output: [7,9,4,10]

Constraints:
The number of nodes in the tree is in the range `[1, 100]`.

`0 <= Node.val <= 100`
All the values in the tree are unique.

`root` is guaranteed to be a valid binary search tree.

### Solution 
 To solve the problem of converting a Binary Search Tree (BST) into a Greater Tree, we need to traverse the tree in reverse order (i.e., right-to-left) in order to accumulate the sums of the node values. This will ensure that when processing a node, we have already added all values greater than it.

### Step-by-step Explanation:

1. **Understanding the Problem**: The goal is to transform the original BST so that each node's value is replaced with the sum of its original value plus all values greater than its original value.

2. **Traversal Method**: We'll use a reverse in-order traversal (right, node, left) since in a BST, the right subtree contains values greater than the current node.

3. **Maintain a Running Total**: During the traversal, we'll maintain a running total which holds the sum of all previously visited nodes (which are the greater values). For each node visited, we will update its value by adding this running total to its original value, and then update the running total with the new value of this node.

4. **Implementing the Transformation**: We will define a recursive function to perform this transformation.

### Python Code:

Here is the Python implementation that follows the LeetCode submission format.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        self.running_total = 0
        
        def reverse_inorder(node: TreeNode):
            if not node:
                return
            
            # Traverse the right subtree first
            reverse_inorder(node.right)
            
            # Update the node's value
            self.running_total += node.val
            node.val = self.running_total
            
            # Traverse the left subtree
            reverse_inorder(node.left)
        
        reverse_inorder(root)
        return root

```

### Explanation of the Code:

1. **TreeNode Class**: This is a standard class definition for a node in a binary tree with an initializer to set its value and child nodes.

2. **Solution Class**: This class contains the method `convertBST` that takes the root of the binary search tree and returns the transformed tree.

3. **Running Total Initialization**: We define an instance variable `self.running_total` to keep track of the cumulative sum during the traversal.

4. **Reverse In-order Function**: The nested function `reverse_inorder` performs the in-order traversal. It:
   - Recursively processes the right child (handling greater values).
   - Updates the current node's value with the running total, then adds the current node's original value to the running total.
   - Finally, it processes the left child.

5. **Execution**: We call `reverse_inorder` starting from the root, and once the traversal is complete, the root of the transformed tree is returned.

### Complexity Analysis:
- **Time Complexity**: O(n), where n is the number of nodes in the tree. Each node is visited exactly once.
- **Space Complexity**: O(h), where h is the height of the tree, due to the recursive call stack. In the worst case for a skewed tree, this can be O(n).

This code follows the required format and can be directly submitted on the LeetCode platform to solve the problem.

# 1104. Path In Zigzag Labelled Binary Tree

### Problem Description 
In an infinite binary tree where every node has two children, the nodes are labelled in row order.

In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.

Given the `label` of a node in this tree, return the labels in the path from the root of the tree to the node with that `label`.


Example 1:
Input: label = 14
Output: [1,3,4,14]

Example 2:
Input: label = 26
Output: [1,2,6,10,26]

Constraints:
`1 <= label <= 10^6`

### Solution 
 To solve the problem of finding the path from the root of an infinite binary tree to a specified node by its label, we need to understand the structure of the binary tree and how the nodes are labeled. The binary tree has the following characteristics:

1. **Rows in the Tree**:
   - Each row in the tree has labels that follow specific rules for odd and even rows. 
   - In odd-numbered rows, nodes are labeled from left to right.
   - In even-numbered rows, nodes are labeled from right to left.

2. **Labeling Scheme**:
   - The labeling of the nodes can be visualized as:
     - Row 1:          1
     - Row 2:        2   3
     - Row 3:      4   5   6   7
     - Row 4:    8   9  10  11  12  13  14  15
     - Row 5:  16  17  18  19  20  21  22  23
     - And so on.

3. **Path to a Node**:
   - To find the path to a given label, we need to determine its row and the position within that row. 
   - Each node's parent can be calculated based on its label, and we will trace back from the node to the root.

### Approach:

1. **Determine the Row**:
   - For any given label, calculate the row using a loop that sums up the number of nodes in each row until we exceed the label.

2. **Trace Back Path**:
   - Once we find the row, we can calculate the parent node by the logic:
     - For odd rows: `parent_label = label // 2`
     - For even rows: We have to account for the reverse labeling, involving finding the "mirror" position in the row.

3. **Construct the Path**:
   - We keep halving the label (and adjusting for even rows) until we reach the root and construct the path by collecting labels.

### Implementation:

Hereâ€™s the Python code solution implemented in the format suitable for LeetCode:



```python
class Solution:
    def pathInZigZagTree(self, label: int) -> List[int]:
        path = []
        
        # Find the row of the label.
        # A row starts with 1, 2, 4, 8, ... (2^0, 2^1, 2^2, ...)
        row = 0
        while (1 << row) <= label:
            row += 1
        
        # Generate the path by moving from the label to the root
        while label > 0:
            path.append(label)
            # Find the parent label
            row -= 1
            
            # Determine the parent
            if row % 2 == 0:  # If current row is even (0 indexed)
                parent_label = (1 << row) - (label // 2) - 1
            else:  # If the current row is odd
                parent_label = label // 2
            
            label = parent_label
        
        # Since we collected the path backwards, we need to reverse it
        return path[::-1]

```

### Explanation of the Code:

- The function starts by initializing an empty list `path` to store the labels along the path from the root to the target.
- We calculate the row of the given label to understand where it resides in the tree.
- We then iteratively find each node's parent by adjusting the label based on whether we're in an odd or even row.
- As we find each label in the path, we append it to the `path` list.
- Finally, since we built the path from the node back to the root, we reverse the list before returning it as the output.

This solution efficiently traces back the path in a binary tree, using mathematical operations rather than building the tree explicitly, ensuring it runs within constraints effectively.

# 1110. Delete Nodes And Return Forest

### Problem Description 
Given the `root` of a binary tree, each node in the tree has a distinct value.

After deleting all nodes with a value in `to_delete`, we are left with a forest (a disjoint union of trees).

Return the roots of the trees in the remaining forest. You may return the result in any order.


Example 1:
Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
Output: [[1,2,null,4],[6],[7]]

Example 2:
Input: root = [1,2,4,null,3], to_delete = [3]
Output: [[1,2,4]]

Constraints:
The number of nodes in the given tree is at most `1000`.

Each node has a distinct value between `1` and `1000`.

`to_delete.length <= 1000`
`to_delete` contains distinct values between `1` and `1000`.

### Solution 
 To solve this problem, we will perform a post-order traversal of the binary tree. In post-order traversal, we visit the left subtree first, then the right subtree, and finally the node itself. This approach allows us to handle the deletion of nodes correctly since we can first process the children before processing the node to be deleted.

Here are the main steps we'll follow to implement the solution:

1. **Convert the `to_delete` list to a set** for O(1) lookups.
2. **Post-order traversal** of the tree to process each node:
   - If the current node's value is in `to_delete`, we delete it (which means we will not add it to the resulting forest).
   - If the left or right child is deleted (i.e., equal to any value in `to_delete`), and the child is not null, we add those non-null children to the resulting forest.
3. If a node is not deleted, we return it as part of the result.
4. Collect the roots of the remaining trees that are not deleted.

Now, let's implement this in code following the LeetCode style format.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:
        to_delete_set = set(to_delete)
        result = []
        
        def postOrder(node):
            if not node:
                return None
            
            # Recursive post-order traversal
            node.left = postOrder(node.left)
            node.right = postOrder(node.right)
            
            # Check if current node needs to be deleted
            if node.val in to_delete_set:
                # If left child is valid, add it to result
                if node.left:
                    result.append(node.left)
                # If right child is valid, add it to result
                if node.right:
                    result.append(node.right)
                # Current node is to be deleted, return None
                return None

            # If current node is not deleted, return it
            return node
        
        # Start post-order traversal
        if root:
            # If root is not deleted, add it to result
            if root.val not in to_delete_set:
                result.append(root)
            postOrder(root)

        return result

```

### Explanation:

1. **TreeNode Definition**: Standard definition of a binary tree node with properties for value, left child, and right child.
   
2. **Solution Class**: Contains the method `delNodes` which takes `root` of the binary tree and a list of values `to_delete`.

3. **Set Creation**: Convert `to_delete` into a set for faster lookup times.

4. **Nested Function postOrder**: 
   - Implements the post-order traversal to process nodes:
     - Recursively visit and clean the left and right subtrees.
     - If the current node should be deleted (found in `to_delete_set`), we manage the children and return `None`.
     - If not deleted, we return the current node.

5. **Result Compilation**: After traversing the tree, if the root is not in the delete list, it's added to the result.

6. **Return the Result**: Finally, the list of tree roots that remain after deletions is returned.

This code effectively handles the tree deletions and accurately maintains a list of the remaining tree roots. The solution is efficient and adheres to the constraints provided.

# 1120. Maximum Average Subtree

### Problem Description 
Given the `root` of a binary tree, find the maximum average value of any subtree of that tree.

(A subtree of a tree is any node of that tree plus all its descendants. The average value of a tree is the sum of its values, divided by the number of nodes.)

Example 1:
Input: [5,6,1]
Output: 6.00000
Explanation: 
For the node with value = 5 we have an average of (5 + 6 + 1) / 3 = 4.

For the node with value = 6 we have an average of 6 / 1 = 6.

For the node with value = 1 we have an average of 1 / 1 = 1.

So the answer is 6 which is the maximum.

Note:
The number of nodes in the tree is between `1` and `5000`.

Each node will have a value between `0` and `100000`.

Answers will be accepted as correct if they are within `10^-5` of the correct answer.

### Solution 
 To solve the problem of finding the maximum average value of any subtree in a binary tree, we can use a depth-first traversal approach to calculate the sum and count of nodes for each subtree. We then compute the average for each subtree and keep track of the maximum average found. 

### Steps to Solve the Problem:
1. **Traversal**: Perform a post-order traversal of the tree to ensure that we calculate the sums and counts of the left and right subtrees before the current node.
2. **Subtree Calculation**: For each node, calculate the sum of values and the count of nodes in its subtree.
3. **Average Calculation**: Compute the average for the subtree rooted at the current node.
4. **Update Maximum Average**: Compare the computed average with our running maximum average and update it if it's larger.
5. **Return the maximum average found**.

We'll represent the tree using a `TreeNode` class where each node has a value, a left child, and a right child. Let's implement the solution in the required format for LeetCode.

### Python Code:


```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maximumAverageSubtree(self, root: TreeNode) -> float:
        self.max_average = float('-inf')  # Initialize maximum average

        def dfs(node):
            if not node:
                return (0, 0)  # Return sum = 0, count = 0 for null node

            # Post-order traversal: first recursively compute left and right subtree
            left_sum, left_count = dfs(node.left)
            right_sum, right_count = dfs(node.right)
            
            # Current subtree sum and count
            current_sum = left_sum + right_sum + node.val
            current_count = left_count + right_count + 1
            
            # Current average for the subtree
            current_average = current_sum / current_count
            
            # Update the maximum average if the current average is larger
            self.max_average = max(self.max_average, current_average)
            
            return (current_sum, current_count)

        # Start DFS from the root
        dfs(root)
        
        return self.max_average

```

### Detailed Explanation:
- We define a `TreeNode` class to represent each node in the binary tree.
- The `Solution` class contains the method `maximumAverageSubtree` which computes the maximum average.
- The `dfs` function is a helper function that performs the depth-first search. It returns the sum of values and the count of nodes in the subtree rooted at the given `node`.
- Inside `dfs`, for each node, we first calculate the sums and counts of its left and right subtrees.
- We then calculate the total `current_sum` and `current_count` for the subtree rooted at the current node.
- The average for the current subtree is calculated and we check if it's greater than the `self.max_average`, updating it if so.
- Finally, we call `dfs` starting from the `root` node and return the maximum average found.

This solution runs efficiently within the problem constraints and gives the correct maximum average value of any subtree in the given binary tree.

# 1123. Lowest Common Ancestor of Deepest Leaves

### Problem Description 
Given the `root` of a binary tree, return the lowest common ancestor of its deepest leaves.

Recall that:
The node of a binary tree is a leaf if and only if it has no children
The depth of the root of the tree is `0`. if the depth of a node is `d`, the depth of each of its children is `d + 1`.

The lowest common ancestor of a set `S` of nodes, is the node `A` with the largest depth such that every node in `S` is in the subtree with root `A`.

Note: This question is the same as 865: https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/

Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.

The nodes coloured in blue are the deepest leaf-nodes of the tree.

Note that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.


Example 2:
Input: root = [1]
Output: [1]
Explanation: The root is the deepest node in the tree, and it's the lca of itself.


Example 3:
Input: root = [0,1,3,null,2]
Output: [2]
Explanation: The deepest leaf node in the tree is 2, the lca of one node is itself.


Constraints:
The number of nodes in the tree will be in the range `[1, 1000]`.

`0 <= Node.val <= 1000`
The values of the nodes in the tree are unique.

### Solution 
 To solve the problem of finding the lowest common ancestor (LCA) of the deepest leaves in a binary tree, we can implement a solution that recursively traverses the tree while keeping track of the depth of each node and determining which node serves as the ancestor of the deepest nodes.

Here's a step-by-step breakdown of the approach we'll take:

1. **Depth-First Search (DFS):** We'll use a recursive DFS function to traverse the entire tree. This function will return two values:
   - The maximum depth of the node's subtree.
   - The LCA of the deepest leaves in that subtree.

2. **Determine Depth and LCA:**
   - If a node is `None`, we return a depth of `-1` and `None` as there's no subtree.
   - When a node is a leaf (both left and right children are `None`), we return a depth of `0` and the current node as the LCA.
   - For non-leaf nodes, we recursively find the depth and LCA for both left and right children.
   - We then compare the depths returned from the left and right children:
     - If both depths are equal, it means both sides have leaves at the same depth, so the current node is their LCA.
     - If one side is deeper, we return the LCA from that deeper side.

3. **Return the LCA:** The function will return the final LCA, which is the node that is the ancestor of the deepest leaves.

Hereâ€™s the implementation in Python:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:
        def dfs(node):
            if not node:
                return -1, None

            left_depth, left_lca = dfs(node.left)
            right_depth, right_lca = dfs(node.right)

            current_depth = max(left_depth, right_depth) + 1
            
            if left_depth == right_depth:
                return current_depth, node  # This is the LCA
            elif left_depth > right_depth:
                return current_depth, left_lca  # Return LCA from the left subtree
            else:
                return current_depth, right_lca  # Return LCA from the right subtree
        
        # Start the DFS from the root and get the LCA
        _, lca = dfs(root)
        return lca

```

### Explanation of the Code:
1. **TreeNode Class:** A basic structure representing each node in the binary tree.
2. **Solution Class:** Contains the method `lcaDeepestLeaves`.
3. **dfs Function:** A helper function defined inside `lcaDeepestLeaves`:
   - Checks if the current node is `None` and returns a depth of `-1` and `None`.
   - Recursively calls itself for the left and right children.
   - Computes the current node's depth by adding `1` to the maximum depth of its children.
   - Compares the depths of the left and right children to determine if the current node is the LCA or if it should return the LCA from one of its children.
4. **Return the LCA:** The entry point of the recursion is from the `root`, and it captures the final LCA to return it.

### Complexity:
- **Time Complexity:** \(O(N)\), where \(N\) is the number of nodes in the binary tree, since we visit each node exactly once.
- **Space Complexity:** \(O(H)\), where \(H\) is the height of the tree, due to recursion stack space in the worst case.

This code is structured to be used directly in LeetCode, and it should properly return the LCA of the deepest leaves for a given binary tree.

# 1130. Minimum Cost Tree From Leaf Values

### Problem Description 
Given an array `arr` of positive integers, consider all binary trees such that:
Each node has either 0 or 2 children;
The values of `arr` correspond to the values of each leaf in an in-order traversal of the tree.  (Recall that a node is a leaf if and only if it has 0 children.)
The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.

Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit integer.


Example 1:
Input: arr = [6,2,4]
Output: 32
Explanation:
There are two possible trees.  The first has non-leaf node sum 36, and the second has non-leaf node sum 32.

    24            24
   /  \          /  \
  12   4        6    8
 /  \               / \
6    2             2   4

Constraints:
`2 <= arr.length <= 40`
`1 <= arr[i] <= 15`
It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than `2^31`).

### Solution 
 To solve the problem, we can use a dynamic programming approach. The main idea is to find the minimum cost of building a binary tree for all possible partitions of the array. Let's break down the solution step-by-step, followed by the implementation in Python.

## Problem Explanation

1. **Binary Tree Structure**:
   - Each node in the tree can either be a leaf or a non-leaf.
   - The leaves correspond to the values in the input array `arr`.
   - The value of each non-leaf node is the product of the largest values from its left and right subtrees.

2. **Objective**:
   - We need to construct binary trees for different partitions of the array and compute the minimum sum of the values of non-leaf nodes.

## Dynamic Programming Approach

1. **Define a DP table**:
   - Let `dp[i][j]` represent the minimum cost of constructing a binary tree using the elements from `arr[i]` to `arr[j]`.

2. **Base Case**:
   - If the segment contains only one element (`i == j`), then it is a leaf and thus the cost is 0 (as there are no non-leaf nodes).

3. **Recurrence Relation**:
   - For a segment from `arr[i]` to `arr[j]`, we can choose a split point `k` (where `i <= k < j`). The value of the non-leaf node formed by choosing `k` as root will be `max(arr[i]...arr[k]) * max(arr[k+1]...arr[j])`, plus the costs of constructing the left and right subtrees from `i` to `k` and from `k+1` to `j`, respectively.

4. **Combination of Results**:
   - Calculate value for each partition and take the minimum.

5. **Iterate Over All Possible Lengths**:
   - Iterate over all possible lengths of segments to fill the DP table.

## Python Implementation

Hereâ€™s how this translates into Python code, ready to run on LeetCode.



```python
class Solution:
    def mctFromLeafValues(self, arr: List[int]) -> int:
        n = len(arr)
        dp = [[0] * n for _ in range(n)]

        # A helper function to get the maximum value in arr[l:r+1]
        def get_max(l, r):
            return max(arr[l:r+1])
        
        # Filling the dp table
        for length in range(2, n + 1):  # start with pairs (length=2) up to the full array
            for i in range(n - length + 1):
                j = i + length - 1  # end index
                # Set initial large number as infinity
                dp[i][j] = float('inf')
                
                for k in range(i, j):
                    # Current non-leaf value
                    cost = get_max(i, k) * get_max(k + 1, j)
                    # Update dp table with the minimal cost
                    dp[i][j] = min(dp[i][j], cost + dp[i][k] + dp[k + 1][j])

        # The answer for the whole array will be in dp[0][n-1]
        return dp[0][n - 1]

```

### Explanation of the Code:
- We initialize a `dp` table with dimensions `n x n`, where `n` is the size of the input array.
- The `get_max` function computes the maximum value in a subarray from index `l` to `r`.
- We fill the `dp` table for all segment lengths from 2 to `n`, as every partition of length 1 contains only leaves.
- The nested loops compute the minimum sum of non-leaf node values for every possible partitioning.
- Finally, the minimum cost for the entire array is stored in `dp[0][n-1]`, which we return.

This approach ensures that we efficiently find the minimal cost to construct the required binary trees based on the provided conditions.

# 1145. Binary Tree Coloring Game

### Problem Description 
Two players play a turn based game on a binary tree.  We are given the `root` of this binary tree, and the number of nodes `n` in the tree.  `n` is odd, and each node has a distinct value from `1` to `n`.

Initially, the first player names a value `x` with `1 <= x <= n`, and the second player names a value `y` with `1 <= y <= n` and `y != x`.  The first player colors the node with value `x` red, and the second player colors the node with value `y` blue.

Then, the players take turns starting with the first player.  In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)
If (and only if) a player cannot choose such a node in this way, they must pass their turn.  If both players pass their turn, the game ends, and the winner is the player that colored more nodes.

You are the second player.  If it is possible to choose such a `y` to ensure you win the game, return `true`.  If it is not possible, return `false`.


Example 1:
Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3
Output: true
Explanation: The second player can choose the node with value 2.


Constraints:
`root` is the root of a binary tree with `n` nodes and distinct node values from `1` to `n`.

`n` is odd.

`1 <= x <= n <= 100`

### Solution 
 To solve the problem, we will leverage the properties of the binary tree and the game's rules. The objective is to determine if the second player can choose a node `y` such that they can ensure winning the game against the first player. 

Here's the step-by-step approach we will take:

1. **Understanding the Game Dynamics**:
   - The first player colors a node `x` red.
   - The second player colors a node `y` blue.
   - Both players will then alternate coloring adjacent (uncolored and connected) nodes of their colored nodes.
   - The second player must choose their moves carefully to maximize their count of colored nodes.

2. **Strategy for the Second Player**:
   - The second player should identify the nodes and their surroundings relative to the node `x`.
   - One strategy is to maximize the number of uncolored neighboring nodes surrounding player 2's choice of `y`.
   - Since `n` is odd, the player who can control the most nodes effectively wins.

3. **Tree Traversal**:
   - We will perform a level order or BFS (Breadth-First Search) traversal to determine the size of the subtree rooted at each node.
   - By counting the size of the two subtrees (left and right) of `x`, we can determine how many nodes are available for the second player if they choose optimally.

4. **Implementation**:
   - We will first locate the node corresponding to the value `x`.
   - We will then calculate the number of nodes in each connected component resulting from the first player's choice.
   - Finally, we check whether it is possible for player 2 to choose a winning node `y`.

Here's the Python code that captures the above approach:



```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def canSecondPlayerWin(self, root: TreeNode, n: int, x: int) -> bool:
        # Helper function to count the number of nodes in the subtree rooted at `node`
        def count_nodes(node):
            if not node:
                return 0
            return 1 + count_nodes(node.left) + count_nodes(node.right)

        # We will search for the node with value `x`
        x_node = None
        
        def find_x(node):
            nonlocal x_node
            if node is None:
                return
            if node.val == x:
                x_node = node
                return
            find_x(node.left)
            find_x(node.right)
        
        find_x(root)
        
        # Count nodes in the left and right subtree of x_node
        left_count = count_nodes(x_node.left)
        right_count = count_nodes(x_node.right)

        # Calculate the number of nodes outside the subtree of x_node
        remaining_nodes = n - (1 + left_count + right_count)
        
        # The second player can win if they can ensure they have more than half of the nodes
        # They need to control more than (n // 2) nodes to win
        # Since n is odd, (n // 2) + 1 gives the winning condition
        player2_total = max(left_count, right_count) + remaining_nodes
        
        return player2_total > (n // 2)

# Example usage:
# Assume the binary tree is structured as needed.
# The actual input for the tree would require TreeNode structures to build.

```

### Explanation of the Code:
1. **TreeNode Class**: A standard structure to represent nodes in a binary tree.
2. **canSecondPlayerWin Method**: The main function that implements the logic to determine if the second player can win.
   - `count_nodes` recursively counts the number of nodes in a given subtree.
   - `find_x` traverses the tree to find the node corresponding to value `x`.
   - The counts of the left and right subtrees are calculated, along with the remaining uncolored nodes in the tree.
   - Finally, a comparison is made to determine if the second player can secure more nodes than half the total.

This solution has a time complexity of O(n) because it visits each node at most twice, which is efficient given the constraints of the problem.

# 1161. Maximum Level Sum of a Binary Tree

### Problem Description 
Given the `root` of a binary tree, the level of its root is `1`, the level of its children is `2`, and so on.

Return the smallest level `x` such that the sum of all the values of nodes at level `x` is maximal.


Example 1:
Input: root = [1,7,0,7,-8,null,null]
Output: 2
Explanation: 
Level 1 sum = 1.

Level 2 sum = 7 + 0 = 7.

Level 3 sum = 7 + -8 = -1.

So we return the level with the maximum sum which is level 2.


Example 2:
Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
Output: 2

Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`-105 <= Node.val <= 105`

### Solution 
 To solve the problem of finding the smallest level of a binary tree where the sum of the nodes is maximized, we can use a breadth-first search (BFS) approach. BFS is well-suited here since we can process the tree level by level. 

Hereâ€™s how we can structure our approach:

1. **Initialization**: We'll need a queue to facilitate the BFS traversal and maintain an array (or list) to store the sum of node values at each level.

2. **BFS Traversal**: Process each level of the tree:
   - For each node, add its value to the current level's sum.
   - Add its children to the queue for the next level.

3. **Collect Sums**: After processing all nodes at a level, record the sum for that level in a list.

4. **Determine Maximum Sum Level**: Once we have sums for all levels, find the level with the maximum sum. If there are multiple levels with the same sum, return the smallest level.

5. **Return the Result**: The final result is the level with the maximum sum.

Here's the Python code that implements the above logic following the LeetCode solution format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

from collections import deque

class Solution:
    def maxLevelSum(self, root: TreeNode) -> int:
        # Base case if the tree is empty.
        if not root:
            return 0
        
        # A queue to perform BFS
        queue = deque([root])
        max_sum = float('-inf')  # Initialize to negative infinity
        level = 0  # The current level we're processing
        best_level = 0  # The level with the maximum sum

        while queue:
            level += 1
            level_sum = 0  # Reset the sum for the current level
            level_size = len(queue)  # Number of nodes at the current level
            
            for _ in range(level_size):
                node = queue.popleft()  # Get the current node
                level_sum += node.val  # Add its value to the level sum
                
                if node.left:
                    queue.append(node.left)  # Add the left child to the queue
                if node.right:
                    queue.append(node.right)  # Add the right child to the queue
            
            # Check if the current level sum is greater than the max_sum found so far
            if level_sum > max_sum:
                max_sum = level_sum
                best_level = level  # Update the best level
            
        return best_level

```

### Explanation of the Code

1. **TreeNode Class**: This is a standard class for tree nodes, with a constructor that initializes the node's value and its left and right children.

2. **maxLevelSum Function**:
   - We first check if the root is `None`. If it is, we return 0, indicating no levels exist.
   - We use a deque (double-ended queue) for efficient pop from the front which is essential for BFS.
   - We initialize `max_sum` to negative infinity so any level sum would replace it. `best_level` is used to track the level of the maximum sum.

3. **BFS Loop**:
   - For each level, we increment `level` and reset `level_sum`.
   - We iterate over all nodes at the current level using `level_size` to manage the number of nodes that are processed in this iteration.
   - We sum the values of all nodes, enqueue their children for the next level, and update `max_sum` and `best_level` accordingly.

4. **Return Statement**: Finally, we return `best_level`, which contains the level with the maximum sum.

This approach efficiently computes level sums and tracks the level with the maximum sum while ensuring optimal performance suitable for the problem constraints.

# 1245. Tree Diameter

### Problem Description 
Given an undirected tree, return its diameter: the number of edges in a longest path in that tree.

The tree is given as an array of `edges` where `edges[i] = [u, v]` is a bidirectional edge between nodes `u` and `v`.  Each node has labels in the set `{0, 1, ..., edges.length}`.


Example 1:
Input: edges = [[0,1],[0,2]]
Output: 2
Explanation: 
A longest path of the tree is the path 1 - 0 - 2.


Example 2:
Input: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]
Output: 4
Explanation: 
A longest path of the tree is the path 3 - 2 - 1 - 4 - 5.


Constraints:
`0 <= edges.length < 10^4`
`edges[i][0] != edges[i][1]`
`0 <= edges[i][j] <= edges.length`
The given edges form an undirected tree.

### Solution 
 To solve the problem of finding the diameter of a tree given its edges, we can use a depth-first search (DFS) approach. The diameter of a tree can be computed by performing two passes of DFS:

1. First, we start a DFS from an arbitrary node to find the farthest node from it. This node will be one endpoint of the longest path in the tree.
2. Then, we perform a second DFS starting from this farthest node to find the maximum distance to any other node. The result will give us the diameter of the tree.

Here's the Python code that implements this algorithm following the LeetCode solution format:



```python
class Solution:
    def treeDiameter(self, edges: List[List[int]]) -> int:
        from collections import defaultdict

        # Create an adjacency list from the edges
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        def dfs(node: int, parent: int) -> (int, int):
            # This function returns the farthest node and its distance from the current node
            max_distance = 0
            farthest_node = node
            
            for neighbor in graph[node]:
                if neighbor == parent:  # Avoid going back to parent
                    continue
                distance, candidate_node = dfs(neighbor, node)
                distance += 1  # Add 1 for the edge to the neighbor

                if distance > max_distance:
                    max_distance = distance
                    farthest_node = candidate_node

            return max_distance, farthest_node

        # First DFS to find an arbitrary farthest node from an arbitrary starting node
        _, farthest_node = dfs(0, -1)
        # Second DFS to find the maximum distance from the farthest node found
        diameter, _ = dfs(farthest_node, -1)

        return diameter


```

### Explanation:

1. **Graph Representation**: We use an adjacency list to represent the tree. For each edge `(u, v)`, we add `v` to the list for `u` and `u` to the list for `v` in the graph.

2. **DFS Function**: We define a helper function called `dfs` that takes a `node` and its `parent`. This function will:
   - Initialize the maximum distance (`max_distance`) and the farthest node (`farthest_node`).
   - Iterate through the list of neighbors and check each one.
   - If the neighbor is not the parent (to prevent cycling back), we recursively call `dfs` on that neighbor.
   - After returning, we update the `max_distance` and `farthest_node` if the found distance is greater than the current `max_distance`.

3. **First DFS**: We start with an arbitrary node (node `0`) and perform the first DFS to find the farthest node from it, which gives us one endpoint of the longest path.

4. **Second DFS**: We perform another DFS starting from the previously found farthest node. The maximum distance returned from this DFS will be the tree's diameter.

5. **Return Result**: Finally, we return the diameter of the tree.

### Complexity:
- **Time Complexity**: O(N), where N is the number of nodes (or edges + 1). Each node and edge is visited once during the DFS.
- **Space Complexity**: O(N), for the adjacency list representation and the recursion stack in the DFS. 

This implementation is efficient and handles the constraints given in the problem.

# 1257. Smallest Common Region

### Problem Description 
You are given some lists of `regions` where the first region of each list includes all other regions in that list.

Naturally, if a region `X` contains another region `Y` then `X` is bigger than `Y`. Also by definition a region X contains itself.

Given two regions `region1`, `region2`, find out the smallest region that contains both of them.

If you are given regions `r1`, `r2` and `r3` such that `r1` includes `r3`, it is guaranteed there is no `r2` such that `r2` includes `r3`.

It's guaranteed the smallest region exists.


Example 1:
Input:
regions = [["Earth","North America","South America"],
["North America","United States","Canada"],
["United States","New York","Boston"],
["Canada","Ontario","Quebec"],
["South America","Brazil"]],
region1 = "Quebec",
region2 = "New York"
Output: "North America"

Constraints:
`2 <= regions.length <= 10^4`
`region1 != region2`
All strings consist of English letters and spaces with at most 20 letters.

### Solution 
 To solve the problem of finding the smallest region that contains both `region1` and `region2`, we can adopt the following approach:

1. **Data Structure:** We can use a dictionary to map each region to its parent region. This will allow us to quickly traverse the hierarchy of regions to find the ancestors of both `region1` and `region2`.

2. **Traversal:** Once we have built the mapping, we can create a set of ancestors for `region1` and then iterate upward from `region2` to find the first region that is also in the ancestors of `region1`. The first match we find is the smallest region containing both.

3. **Algorithm Steps:**
   - Build a parent-child relationship from the given regions.
   - Create a set for all ancestors of `region1`.
   - Start from `region2` and perform a traversal to find the first intersection with the ancestors of `region1`.

Here's the Python code implementing the above logic in the format suitable for LeetCode:



```python
class Solution:
    def findSmallestRegion(self, regions: List[List[str]], region1: str, region2: str) -> str:
        # Step 1: Create a dictionary to map each region to its parent
        parent = {}
        
        for region in regions:
            for i in range(1, len(region)):
                parent[region[i]] = region[0]  # Assign the parent as the first element

        # Step 2: Create a set to store the ancestors of region1
        ancestors1 = set()
        current = region1
        
        while current in parent:
            ancestors1.add(current)
            current = parent[current]

        # Step 3: Find the first ancestor of region2 that is also in region1's ancestors
        current = region2
        
        while current in parent:
            if current in ancestors1:
                return current
            current = parent[current]
        
        # Since it's guaranteed that a solution exists, we will always return before reaching here.

```

### Explanation of the Code:
- **Input and Output:** The function `findSmallestRegion` takes a list of regions and two specific regions (`region1` and `region2`) as input and returns the smallest region containing both. 

- **Building the Parent Map:** We iterate over each list in `regions` and populate a dictionary `parent`, where each key is a child region (i.e., a sub-region) and the corresponding value is its parent region (i.e., the region that contains it).

- **Finding Ancestors:** We start with `region1` and continuously move up the hierarchy (using the `parent` dictionary) until there are no more ancestors, adding each encountered region to the `ancestors1` set for quick lookup.

- **Searching for the Smallest Region:** Starting from `region2`, we similarly traverse up its hierarchy, checking at each step if the current region is an ancestor of `region1` (exists in `ancestors1`). The first such region we encounter during this upward traversal is returned as the result.

### Complexity:
- **Time Complexity:** O(n) for building the parent dictionary and O(h1 + h2) for finding the smallest region, where h1 and h2 are the respective heights in the region hierarchy starting from `region1` and `region2`. In the worst case, this can also be considered O(n) since h1 + h2 â‰¤ n for n regions.
- **Space Complexity:** O(n) to store the parent relationships and up to O(n) for the set of ancestors. 

This ensures that our solution efficiently handles the constraints given in the problem.

# 1261. Find Elements in a Contaminated Binary Tree

### Problem Description 
Given a binary tree with the following rules:
`root.val == 0`
If `treeNode.val == x` and `treeNode.left != null`, then `treeNode.left.val == 2 * x + 1`
If `treeNode.val == x` and `treeNode.right != null`, then `treeNode.right.val == 2 * x + 2`
Now the binary tree is contaminated, which means all `treeNode.val` have been changed to `-1`.

You need to first recover the binary tree and then implement the `FindElements` class:
`FindElements(TreeNode* root)` Initializes the object with a contamined binary tree, you need to recover it first.

`bool find(int target)` Return if the `target` value exists in the recovered binary tree.


Example 1:
Input
["FindElements","find","find"]
[[[-1,null,-1]],[1],[2]]
Output
[null,false,true]
Explanation
FindElements findElements = new FindElements([-1,null,-1]); 
findElements.find(1); // return False 
findElements.find(2); // return True 

Example 2:
Input
["FindElements","find","find","find"]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
Output
[null,true,true,false]
Explanation
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False

Example 3:
Input
["FindElements","find","find","find","find"]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
Output
[null,true,false,false,true]
Explanation
FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True

Constraints:
`TreeNode.val == -1`
The height of the binary tree is less than or equal to `20`
The total number of nodes is between `[1, 10^4]`
Total calls of `find()` is between `[1, 10^4]`
`0 <= target <= 10^6`

### Solution 
 To solve the problem of recovering a contaminated binary tree and implementing the `FindElements` class, we can follow these steps:

1. **Understand the Structure and Recovery of the Tree**:
   - The root of the tree is always `0`.
   - For a node with value `x`:
     - The left child is `2 * x + 1`.
     - The right child is `2 * x + 2`.
   - All nodes have been set to `-1`, and we need to reconstruct these values based on the above rules.

2. **Implement the Recovery Function**:
   - We will perform a depth-first search (DFS) to traverse the tree and assign the correct values.

3. **Implement the `FindElements` Class**:
   - This class should store all the valid values during recovery so that we can quickly check for existence with the `find` method.

4. **Create the TreeNode Class**:
   - A simple implementation of the TreeNode class is needed to represent each node in the binary tree.
   
The complete implementation in Python according to the LeetCode structure is as follows:



```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class FindElements:

    def __init__(self, root: TreeNode):
        self.values_set = set()
        self.recover(root, 0)  # Start recovery from root with value 0

    def recover(self, node: TreeNode, value: int):
        if node is None:
            return
        node.val = value  # Recover the value of the current node
        self.values_set.add(value)  # Add the recovered value to the set
        # Recursively recover left and right children if they exist
        self.recover(node.left, 2 * value + 1)
        self.recover(node.right, 2 * value + 2)

    def find(self, target: int) -> bool:
        # Check if the target exists in the set of recovered values
        return target in self.values_set

```

### Explanation:
- **TreeNode Class**: This represents a single node in the binary tree with a value, left child, and right child.
  
- **FindElements Class**:
  - **`__init__` Method**: This initializes the object with the contaminated tree root. It creates a set `values_set` to store the recovered values and calls the `recover` function starting from the root.
  
  - **`recover` Method**: A recursive function that assigns values to each node based on the reconstructed rules. It starts from the given node, assigns it the current value, adds that value to the set, and recursively sets values for left and right children using the formulas derived from the parent node's value.
  
  - **`find` Method**: Given a `target`, this function checks if the `target` value exists in the `values_set`. The set allows for O(1) average time complexity for lookups.

### Complexity:
- **Time Complexity**: The `__init__` method takes O(n), where n is the number of nodes in the tree, to recover all nodes. The `find` method takes O(1) for each query.
- **Space Complexity**: O(n) for storing the recovered values in the set.

This code is designed to be directly compatible with the LeetCode platform, ensuring that it can be run correctly in their environment.

# 1302. Deepest Leaves Sum

### Problem Description 
Given the `root` of a binary tree, return the sum of values of its deepest leaves.


Example 1:
Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
Output: 15

Example 2:
Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
Output: 19

Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`1 <= Node.val <= 100`

### Solution 
 To solve the problem of finding the sum of values of the deepest leaves in a binary tree, we can utilize a breadth-first search (BFS) approach. This method will allow us to traverse each level of the tree and identify the leaves at the deepest level. Hereâ€™s how to accomplish this:

### Detailed Explanation:
1. **Understanding the Tree Structure**: A binary tree consists of nodes where each node can have a maximum of two children (left and right). We will represent the tree using a class structure in Python.

2. **BFS Traversal**: We'll use a queue to perform a level order traversal (BFS) of the tree. At each level, we will keep track of the sum of the values of the nodes. When we reach the next level, we'll reset the sum and continue until there are no more nodes to process.

3. **Sum of Deepest Leaves**: At the end of our traversal, the `sum` variable will contain the sum of the values of the deepest leaves since we will update the sum at each level until we reach the deepest level.

### Implementation:

Here's the Python code structured according to the LeetCode format. 



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def deepestLeavesSum(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        queue = [root]
        current_sum = 0
        
        while queue:
            level_size = len(queue)
            current_sum = 0
            
            for _ in range(level_size):
                node = queue.pop(0)  # Dequeue the front of the queue
                current_sum += node.val  # Sum the values of the current level
                
                # Enqueue the left and right children, if they exist
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        
        return current_sum  # Return the sum of values at the deepest level

```

### How to Use This Code:
- First, the `TreeNode` class is defined to create nodes of the binary tree.
- The `Solution` class contains the method `deepestLeavesSum` which takes in the root of the tree.
- You can define a binary tree using `TreeNode` instances and call the `deepestLeavesSum` method to get the sum of its deepest leaves.

### Example Usage:
Hereâ€™s how you can create an example tree and use the `deepestLeavesSum` method:



```python
# Example Usage
if __name__ == "__main__":
    # Constructing the tree [1,2,3,4,5,null,6,7,null,null,null,null,8]
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.right = TreeNode(6)
    root.left.left.left = TreeNode(7)
    root.right.right.right = TreeNode(8)

    solution = Solution()
    print(solution.deepestLeavesSum(root))  # Output: 15

```

This code will efficiently compute the sum of the deepest leaves in the binary tree for the provided examples. The BFS ensures that we get the correct level sums until reaching the deepest leaves.

# 1305. All Elements in Two Binary Search Trees

### Problem Description 
Given two binary search trees `root1` and `root2`.

Return a list containing all the integers from both trees sorted in ascending order.


Example 1:
Input: root1 = [2,1,4], root2 = [1,0,3]
Output: [0,1,1,2,3,4]

Example 2:
Input: root1 = [0,-10,10], root2 = [5,1,7,0,2]
Output: [-10,0,0,1,2,5,7,10]

Example 3:
Input: root1 = [], root2 = [5,1,7,0,2]
Output: [0,1,2,5,7]

Example 4:
Input: root1 = [0,-10,10], root2 = []
Output: [-10,0,10]

Example 5:
Input: root1 = [1,null,8], root2 = [8,1]
Output: [1,1,8,8]

Constraints:
Each tree has at most `5000` nodes.

Each node's value is between `[-10^5, 10^5]`.

### Solution 
 To solve the problem of merging two binary search trees and returning a sorted list of their values, we can follow these steps:

1. Perform an in-order traversal of both trees to collect their values in a sorted manner.
2. Merge the two sorted lists that we get from the in-order traversals.
3. Return the merged sorted list.

### Detailed Explanation:

1. **In-order Traversal**: In a binary search tree (BST), an in-order traversal visits the nodes in ascending order. Thus, we can easily collect the elements from each tree by performing an in-order traversal.

2. **Merging Two Sorted Lists**: Once we have two lists generated from the in-order traversal of each tree, we can merge them into one sorted list. We can do this efficiently in linear time by comparing elements from the two lists, similar to the merge step in the merge sort algorithm.

### Python Code:

Here's how the solution can be implemented in Python. The function `getSortedElements` performs the in-order traversal, and the function `mergeSortedArrays` merges two sorted lists.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def getSortedElements(self, root):
        """Performs an in-order traversal of the BST and returns a sorted list of values."""
        result = []
        if root:
            result.extend(self.getSortedElements(root.left))  # Left subtree
            result.append(root.val)                            # Current node
            result.extend(self.getSortedElements(root.right)) # Right subtree
        return result

    def mergeSortedArrays(self, arr1, arr2):
        """Merges two sorted arrays into one sorted array."""
        merged = []
        i, j = 0, 0
        while i < len(arr1) and j < len(arr2):
            if arr1[i] < arr2[j]:
                merged.append(arr1[i])
                i += 1
            else:
                merged.append(arr2[j])
                j += 1
        # Append the remaining elements from arr1, if any
        while i < len(arr1):
            merged.append(arr1[i])
            i += 1
        # Append the remaining elements from arr2, if any
        while j < len(arr2):
            merged.append(arr2[j])
            j += 1
        return merged

    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        """Gets all elements from two BSTs and returns them in sorted order."""
        # Get sorted elements from both trees
        elements1 = self.getSortedElements(root1)
        elements2 = self.getSortedElements(root2)
        # Merge the two sorted lists
        return self.mergeSortedArrays(elements1, elements2)

```

### How to Run on LeetCode:
1. You can copy and paste the above code into the LeetCode online editor.
2. The `TreeNode` class is defined to represent each node of the binary search tree, and the `Solution` class contains the methods needed to solve the problem.
3. To test with different binary search trees, you would define `root1` and `root2` as instances of `TreeNode` and call `Solution().getAllElements(root1, root2)`.

### Example Usage:


```python
# Example to represent the trees and use the solution
root1 = TreeNode(2, TreeNode(1), TreeNode(4))
root2 = TreeNode(1, TreeNode(0), TreeNode(3))

solution = Solution()
print(solution.getAllElements(root1, root2))  # Output: [0, 1, 1, 2, 3, 4]

```

This code efficiently combines two binary search trees' values and sorts them, adhering to the problem's constraints.

# 1315. Sum of Nodes with Even-Valued Grandparent

### Problem Description 
Given a binary tree, return the sum of values of nodes with even-valued grandparent.  (A grandparent of a node is the parent of its parent, if it exists.)
If there are no nodes with an even-valued grandparent, return `0`.


Example 1:
Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
Output: 18
Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.


Constraints:
The number of nodes in the tree is between `1` and `10^4`.

The value of nodes is between `1` and `100`.

### Solution 
 To solve the problem of calculating the sum of values of nodes that have even-valued grandparents in a binary tree, we can use a Depth-First Search (DFS) approach to traverse the tree. We will keep track of the node's value, its parent, and its grandparent as we recursively visit each node. Specifically, we can create a helper function that takes the current node, the parent node, and the grandparent node as parameters.

### Approach:
1. **Define the Base Case**: If the current node is `None`, we return `0` (as there are no nodes to process).
  
2. **Check Grandparent Value**: If the grandparent exists and its value is even, we add the current node's value to our running sum.

3. **Recursive Calls**: We make recursive calls to the left and right children of the current node, updating the parent and grandparent accordingly:
   - When moving to the left child, the current node becomes the parent, and the previous parent becomes the grandparent.
   - When moving to the right child, the same logic applies.

4. **Aggregate the Results**: The total sum from both children is aggregated and returned.

Let's implement this in Python and format it as required for submission on LeetCode.

### Implementation

Here's the code along with comments to explain each part:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def sumEvenGrandparent(self, root: TreeNode) -> int:
        # Helper function to perform DFS
        def dfs(node: TreeNode, parent: TreeNode, grandparent: TreeNode) -> int:
            # Base case: If the current node is None, return 0
            if not node:
                return 0
            
            # Calculate current sum (include node's value if grandparent is even)
            sum_val = 0
            if grandparent and grandparent.val % 2 == 0:
                sum_val += node.val
            
            # Recurse for left and right children
            sum_val += dfs(node.left, node, parent)  # Current node is new parent
            sum_val += dfs(node.right, node, parent) # Current node is new parent
            
            return sum_val
        
        # Start the DFS with root node, no parent, and no grandparent
        return dfs(root, None, None)

```

### Explanation:
- **TreeNode Class**: This is a basic structure for a binary tree node that contains a value and pointers to its left and right children.
- **Solution Class**: This contains the method `sumEvenGrandparent`, and we define an inner function `dfs` to perform the recursive traversal.
- **DFS Function**:
  - For each node, it checks if there is a grandparent with an even value. If so, it adds the current node's value to `sum_val`.
  - It recursively visits the left and right children, passing the current node as the new parent and the previous parent as the new grandparent.
- Finally, we call the `dfs` function starting from the root node with no parent or grandparent initially.

### Time Complexity:
The time complexity of this solution is O(n), where n is the number of nodes in the tree, since we visit each node exactly once. 

### Space Complexity:
The space complexity is O(h), where h is the height of the tree, which is due to the recursive call stack. In the worst case (for a skewed tree), this can be O(n), but in a balanced tree, it would be around O(log n). 

This code can now be copied directly into the LeetCode problem page associated with this question, and it should work correctly for the given constraints.

# 1325. Delete Leaves With a Given Value

### Problem Description 
Given a binary tree `root` and an integer `target`, delete all the leaf nodes with value `target`.

Note that once you delete a leaf node with value `target`, if it's parent node becomes a leaf node and has the value `target`, it should also be deleted (you need to continue doing that until you can't).


Example 1:
Input: root = [1,2,3,2,null,2,4], target = 2
Output: [1,null,3,null,4]
Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). 
After removing, new nodes become leaf nodes with value (target = 2) (Picture in center).


Example 2:
Input: root = [1,3,3,3,2], target = 3
Output: [1,3,null,null,2]

Example 3:
Input: root = [1,2,null,2,null,2], target = 2
Output: [1]
Explanation: Leaf nodes in green with value (target = 2) are removed at each step.


Example 4:
Input: root = [1,1,1], target = 1
Output: []

Example 5:
Input: root = [1,2,3], target = 1
Output: [1,2,3]

Constraints:
`1 <= target <= 1000`
The given binary tree will have between `1` and `3000` nodes.

Each node's value is between `[1, 1000]`.

### Solution 
 Below is the Python code to solve the problem of deleting all leaf nodes with a given target value in a binary tree. The solution follows the LeetCode format for tree problems and provides a detailed explanation of the approach used.

### Code Implementation:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def removeLeafNodes(self, root: TreeNode, target: int) -> TreeNode:
        # Helper function to perform DFS and remove leaf nodes
        def dfs(node):
            if not node:
                return None
            
            # Recursively process left and right children
            node.left = dfs(node.left)
            node.right = dfs(node.right)

            # Check if the current node is a leaf and matches the target
            if not node.left and not node.right and node.val == target:
                return None  # Remove the leaf node
            return node  # Return the current node if it's not a target leaf

        # Start the DFS traversal from the root
        return dfs(root)


```

### Explanation:

1. **TreeNode Definition**:
   - We define a `TreeNode` class to represent each node of the binary tree. Each node has a value (`val`), a left child (`left`), and a right child (`right`).

2. **Solution Class**:
   - We define a `Solution` class which contains the method `removeLeafNodes`.

3. **removeLeafNodes Method**:
   - This method is public and accepts a `root` of type `TreeNode` and an integer `target`. It returns a modified tree where all leaf nodes with the specified target value have been removed.

4. **DFS Helper Function**:
   - Inside `removeLeafNodes`, we define a `dfs` (Depth First Search) helper function that takes a single parameter `node`.
   - It checks if the `node` is `None`, returning `None` if that's the case (base case of recursion).

5. **Recursive Traversal**:
   - The `dfs` function recursively calls itself to process the left and right children of the current node. 
   - After processing the children, it checks if the current `node` is a leaf node (i.e., both left and right children are `None`) and whether its value matches `target`.

6. **Node Removal Process**:
   - If the current node is a leaf and its value is equal to `target`, we return `None`, effectively removing this node from the tree.
   - If the node is not a target leaf node, we return the `node`, ensuring it remains part of the tree structure.

7. **Return Value**:
   - The `dfs` function is invoked starting from the `root`, and the modified tree (potentially a new root) is returned.

### Complexity Analysis:
- **Time Complexity**: O(N), where N is the number of nodes in the tree. Each node is visited once.
- **Space Complexity**: O(H), where H is the height of the tree, due to the recursive stack.

This implementation effectively handles the recursive deletion of the target leaf nodes in the binary tree while adhering to the problem constraints.

# 1339. Maximum Product of Splitted Binary Tree

### Problem Description 
Given a binary tree `root`. Split the binary tree into two subtrees by removing 1 edge such that the product of the sums of the subtrees are maximized.

Since the answer may be too large, return it modulo 10^9 + 7.


Example 1:
Input: root = [1,2,3,4,5,6]
Output: 110
Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)

Example 2:
Input: root = [1,null,2,3,4,null,null,5,6]
Output: 90
Explanation:  Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)

Example 3:
Input: root = [2,3,9,10,7,8,6,5,4,11,1]
Output: 1025

Example 4:
Input: root = [1,1]
Output: 1

Constraints:
Each tree has at most `50000` nodes and at least `2` nodes.

Each node's value is between `[1, 10000]`.

### Solution 
 To solve the problem of splitting a binary tree into two subtrees by removing one edge and maximizing the product of their sums, we can follow these steps:

1. **Calculate the total sum of the entire tree**: This is essential because when we remove an edge, we end up with one subtree, and the sum of the other subtree can be easily calculated using the total sum minus the sum of the first subtree.

2. **Use Depth-First Search (DFS)**: We'll perform a DFS traversal to calculate the sum of values in each subtree. During this traversal, for each node, we compute the sum of all its descendants and return this sum while also checking the product of the sums of the two resulting subtrees when the edge leading to the current node is removed.

3. **Keep track of the maximum product encountered**: As we perform the DFS and calculate products of subtree sums, we maintain a variable to store the maximum product found.

4. **Return the maximum product modulo \(10^9 + 7\)**: Since the product can be very large, we need to return it modulo \(10^9 + 7\).

Letâ€™s write the code for this:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxProduct(self, root: TreeNode) -> int:
        MOD = 10**9 + 7
        total_sum = self._calculate_total_sum(root)
        self.max_product = 0
        
        # Perform DFS to find the maximum product
        self._dfs(root, total_sum)
        
        return self.max_product % MOD

    def _calculate_total_sum(self, node: TreeNode) -> int:
        """ Helper function to calculate the total sum of the tree. """
        if not node:
            return 0
        return node.val + self._calculate_total_sum(node.left) + self._calculate_total_sum(node.right)

    def _dfs(self, node: TreeNode, total_sum: int) -> int:
        """ DFS function to compute subtree sums and track the maximum product. """
        if not node:
            return 0
        
        left_sum = self._dfs(node.left, total_sum)
        right_sum = self._dfs(node.right, total_sum)
        
        # Current subtree sum:
        current_sum = left_sum + right_sum + node.val
        
        # Calculate the product of the two subtree sums
        if node.left:
            product_left = current_sum * (total_sum - current_sum)
            self.max_product = max(self.max_product, product_left)
            
        if node.right:
            product_right = current_sum * (total_sum - current_sum)
            self.max_product = max(self.max_product, product_right)

        return current_sum

```

### Explanation

1. **TreeNode class**: This class represents a node in the binary tree with its value and pointers to left and right children.

2. **maxProduct function**: This is the main function that calculates the total sum of the tree and initiates the DFS.

3. **_calculate_total_sum function**: This helper function recursively calculates the total sum of the tree by performing a post-order traversal.

4. **_dfs function**: This function computes the sum of each subtree using DFS. It also calculates the product of the subtree sum when considering each edge that could be removed. We check the product of the current subtree sum and the remaining sum (total - current_subtree_sum) for both left and right children.

5. **Modulo Operation**: Finally, we return the maximum product found modulo \(10^9 + 7\).

This code will run efficiently within the given constraints, as the problem size is manageable for the DFS approach.

# 1367. Linked List in Binary Tree

### Problem Description 
Given a binary tree `root` and a linked list with `head` as the first node. 
Return True if all the elements in the linked list starting from the `head` correspond to some downward path connected in the binary tree otherwise return False.

In this context downward path means a path that starts at some node and goes downwards.


Example 1:
Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Explanation: Nodes in blue form a subpath in the binary Tree.  

Example 2:
Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true

Example 3:
Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: false
Explanation: There is no path in the binary tree that contains all the elements of the linked list from `head`.


Constraints:
The number of nodes in the tree will be in the range `[1, 2500]`.

The number of nodes in the list will be in the range `[1, 100]`.

`1 <= Node.val <= 100` for each node in the linked list and binary tree.

### Solution 
 To solve the problem of determining whether a linked list represents a downward path in a binary tree, we can employ a depth-first search (DFS) strategy. Here's a concise breakdown of the steps involved:

1. **Define the Node Structures**: We will manage two Node classes, one for the binary tree node (`TreeNode`) and one for the linked list node (`ListNode`).
2. **DFS to Search for the Path**: We will recursively traverse the binary tree and compare each node value with the current value of the linked list. If they match, we will proceed to check the next node in the linked list along the downward path of the binary tree.
3. **Base Cases**: The search must account for when we reach the end of the linked list (indicating a successful match) or when we run out of nodes in the binary tree (indicating a failure).
4. **Initiate the Search from Each Node**: We will begin a DFS from every node in the binary tree, checking if there is any downward path that matches the linked list.

Here's how this can be implemented in Python:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Definition for a linked list node.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:
        # Helper function to perform DFS on the binary tree
        def dfs(node: TreeNode, list_node: ListNode) -> bool:
            # If we've reached the end of the linked list, we've found a valid path
            if list_node is None:
                return True
            # If we've reached a leaf in the binary tree or the values don't match
            if node is None or node.val != list_node.val:
                return False
            
            # Continue DFS to the left and right children
            return dfs(node.left, list_node.next) or dfs(node.right, list_node.next)

        # Helper function to initiate DFS from each node in the tree
        def traverse_tree(node: TreeNode) -> bool:
            if node is None:
                return False
            # Check if the current node is the start of a valid path
            if dfs(node, head):
                return True
            # Recursively check the left and right subtrees
            return traverse_tree(node.left) or traverse_tree(node.right)

        # Start the path checking from the root of the binary tree
        return traverse_tree(root)

```

### Explanation of the Code:

1. **Node Definitions**: We define the `TreeNode` and `ListNode` classes to construct our tree and linked list structures.
2. **isSubPath Method**: This is the main method called with the root of the binary tree and the head of the linked list. It uses two nested helper functions.
3. **dfs Function**: 
   - It takes the current node of the binary tree and the current node of the linked list.
   - It checks if we've successfully matched all nodes in the linked list with a downward path in the binary tree.
   - If the linked list node is `None`, it means we successfully traversed the entire list.
   - If the binary tree node is `None` or values don't match, we return `False`.
   - If they match, we continue the search down both the left and right subtrees of the binary tree.
4. **traverse_tree Function**: 
   - It initiates the `dfs` search from each node in the binary tree. If the current node can potentially be the start of a matching path, it calls `dfs`.
   - After checking a node, it moves to the left and right children.

5. **Return Statement**: The final result will be `True` if there is at least one path in the binary tree that corresponds to the linked list; otherwise, it will return `False`.

This solution adheres to the constraints and efficiently determines if the linked list represents a downward path in the binary tree using the DFS approach.

# 1372. Longest ZigZag Path in a Binary Tree

### Problem Description 
You are given the `root` of a binary tree.

A ZigZag path for a binary tree is defined as follow:
Choose any node in the binary tree and a direction (right or left).

If the current direction is right, move to the right child of the current node; otherwise, move to the left child.

Change the direction from right to left or from left to right.

Repeat the second and third steps until you can't move in the tree.

Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).

Return the longest ZigZag path contained in that tree.


Example 1:
Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
Output: 3
Explanation: Longest ZigZag path in blue nodes (right -> left -> right).


Example 2:
Input: root = [1,1,1,null,1,null,null,1,1,null,1]
Output: 4
Explanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).


Example 3:
Input: root = [1]
Output: 0

Constraints:
The number of nodes in the tree is in the range `[1, 5 * 104]`.

`1 <= Node.val <= 100`

### Solution 
 To solve the problem of finding the longest ZigZag path in a binary tree, we can use a depth-first search (DFS) approach. We'll traverse the tree and keep track of the length of the current ZigZag path in both directions (left and right). The key points to consider are:

1. **Definition of ZigZag Path**: We can start from any node and go left or right. After each move, we must switch directions.

2. **ZigZag Length Calculation**: The length of a ZigZag path is calculated as the number of nodes visited minus one.

3. **Depth-First Search (DFS)**: We perform a DFS traversal on the tree, updating the current ZigZag length whenever we switch directions.

4. **Recursion**: At each node, we will call DFS recursively for both children (left and right) while alternating the direction.

5. **Maintaining Maximum Length**: We need to maintain a global maximum ZigZag length throughout the traversal.

Below is the Python code implementing the above logic structured in the LeetCode format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def longestZigZag(self, root: TreeNode) -> int:
        self.max_length = 0
        
        def dfs(node: TreeNode, direction: int, length: int) -> None:
            if not node:
                return
            
            # Update the maximum length found so far
            self.max_length = max(self.max_length, length)
            
            # If the current direction is left, move to the left and switch to right
            if direction == 0:
                dfs(node.left, 1, length + 1)  # Move left and switch to right
                dfs(node.right, 0, 1)           # Start a new path moving right
            else:
                dfs(node.right, 0, length + 1)  # Move right and switch to left
                dfs(node.left, 1, 1)            # Start a new path moving left
            
        # Start DFS from the root, initially we can go either left or right, but we start with length 0
        dfs(root.left, 0, 1)  # Call DFS for the left child starting with a left direction
        dfs(root.right, 1, 1) # Call DFS for the right child starting with a right direction
        
        return self.max_length

```

### Explanation of the Code:

1. **TreeNode Class**: This defines the structure of a node in the binary tree, containing a value, a left child, and a right child.

2. **Solution Class**: This contains the method `longestZigZag`, which will be called to find the longest ZigZag path.

3. **Instance Variable**: `self.max_length` is initialized to 0 and will hold the maximum ZigZag length found as we traverse.

4. **DFS Function**:
   - The `dfs` function takes the current node, the direction of movement (0 for left and 1 for right), and the current length of the ZigZag path.
   - We check if the current node exists. If not, we return.
   - We update `self.max_length` with the current ZigZag path length if it is greater than the previously recorded lengths.
   - Depending on the direction, we call `dfs` on the child nodes while toggling the direction and updating the length accordingly.

5. **Starting the DFS**: The traversal is initiated from the `root` node. We start from the left and right child of the root to explore both possible initial directions.

This solution efficiently calculates the longest ZigZag path in the binary tree in O(N) time, where N is the number of nodes in the tree, complying with the given constraints.

# 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree

### Problem Description 
Given two binary trees `original` and `cloned` and given a reference to a node `target` in the original tree.

The `cloned` tree is a copy of the `original` tree.

Return a reference to the same node in the `cloned` tree.

Note that you are not allowed to change any of the two trees or the `target` node and the answer must be a reference to a node in the `cloned` tree.

Follow up: Solve the problem if repeated values on the tree are allowed.


Example 1:
Input: tree = [7,4,3,null,null,6,19], target = 3
Output: 3
Explanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.


Example 2:
Input: tree = [7], target =  7
Output: 7

Example 3:
Input: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
Output: 4

Example 4:
Input: tree = [1,2,3,4,5,6,7,8,9,10], target = 5
Output: 5

Example 5:
Input: tree = [1,2,null,3], target = 2
Output: 2

Constraints:
The number of nodes in the `tree` is in the range `[1, 10^4]`.

The values of the nodes of the `tree` are unique.

`target` node is a node from the `original` tree and is not `null`.

### Solution 
 To solve the problem of finding a reference to the same node in the `cloned` binary tree based on the `target` node from the `original` binary tree, we can use Depth-First Search (DFS) or Breadth-First Search (BFS) traversal. In this explanation, we'll use a DFS approach, which is efficient and straightforward for this problem.

### Explanation of the Approach

1. **Traversing the Trees**: We'll traverse both the `original` and `cloned` trees simultaneously. When we visit a node in the `original` tree, we'll check if it's the `target` node. If it is, we'll return the corresponding node from the `cloned` tree.

2. **Recursive Function**: We'll define a recursive function that takes nodes from both `original` and `cloned` trees as parameters. At each step:
   - If the `original` node is `None`, it signifies that we have reached the end of that path, and we should return `None`.
   - If the `original` node matches the `target`, we return the `cloned` node which corresponds to it.
   - Otherwise, we recursively explore the left and right children.

3. **Return Value**: The function will return the reference to the node found in the `cloned` tree when the `target` node is matched in the `original` tree.

Here's how you can implement this approach:

### Python Code



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
        # Helper function that uses DFS to find the target node
        def dfs(original_node, cloned_node):
            # Base case: if we have reached a leaf node in the original tree
            if original_node is None:
                return None
            
            # Check if the current node is the target
            if original_node == target:
                return cloned_node
            
            # Search in the left subtree
            left_result = dfs(original_node.left, cloned_node.left)
            if left_result is not None:
                return left_result
            
            # If not found in left, search in the right subtree
            return dfs(original_node.right, cloned_node.right)
        
        # Start the DFS from the root of both trees
        return dfs(original, cloned)

```

### How to Run This Code
- Define the binary tree using the `TreeNode` class.
- Construct two trees: one as the `original` tree and one as the `cloned` tree.
- Create a `target` node that you want to find in the `cloned` tree.
- Call the `getTargetCopy` method from an instance of `Solution` and pass the `original`, `cloned`, and `target` nodes to obtain the result.

### Example Usage
Hereâ€™s how you might set up a simple test case using the above code:



```python
# Create the original and cloned trees
original = TreeNode(7)
original.left = TreeNode(4)
original.right = TreeNode(3)
original.right.left = TreeNode(6)
original.right.right = TreeNode(19)

cloned = TreeNode(7)
cloned.left = TreeNode(4)
cloned.right = TreeNode(3)
cloned.right.left = TreeNode(6)
cloned.right.right = TreeNode(19)

target = original.right  # This is the node with value 3 in the original tree

# Create a Solution object and find the target copy
solution = Solution()
cloned_target = solution.getTargetCopy(original, cloned, target)

# Print the value of the cloned target node
print(cloned_target.val)  # Should output 3

```

### Complexity Analysis
- **Time Complexity**: O(N), where N is the number of nodes in the tree. In the worst case, we may have to visit every node.
- **Space Complexity**: O(H), where H is the height of the tree due to the recursion stack. In the worst case of a skewed tree, this could be O(N).

This solution correctly addresses the problem while keeping the constraints in mind, and it is structured to run directly on LeetCode.

# 1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree

### Problem Description 
Given a binary tree where each path going from the root to any leaf form a valid sequence, check if a given string is a valid sequence in such binary tree. 
We get the given string from the concatenation of an array of integers `arr` and the concatenation of all values of the nodes along a path results in a sequence in the given binary tree.


Example 1:
Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,1,0,1]
Output: true
Explanation: 
The path 0 -> 1 -> 0 -> 1 is a valid sequence (green color in the figure). 
Other valid sequences are: 
0 -> 1 -> 1 -> 0 
0 -> 0 -> 0

Example 2:
Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,0,1]
Output: false 
Explanation: The path 0 -> 0 -> 1 does not exist, therefore it is not even a sequence.


Example 3:
Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,1,1]
Output: false
Explanation: The path 0 -> 1 -> 1 is a sequence, but it is not a valid sequence.


Constraints:
`1 <= arr.length <= 5000`
`0 <= arr[i] <= 9`
Each node's value is between [0 - 9].

### Solution 
 To solve the problem of checking if a given integer array `arr` represents a valid sequence from the root to a leaf in a binary tree, we can perform a traversal on the binary tree. The goal is to ensure that we follow the path represented by `arr` throughout the tree and that we end at a leaf node after processing all elements in `arr`.

Here's a detailed breakdown of the solution:

### Approach
1. **TreeNode Class**: We'll define a class to structure the binary tree node, which contains a value, and pointers to the left and right child nodes.
2. **Depth-First Search (DFS)**: We'll use a recursive DFS approach to traverse the tree. At each step:
   - Check if we're at a node that matches the corresponding index in `arr`.
   - If we've reached the end of `arr`, then we need to check if we're at a leaf node.
   - If not at the end of `arr`, move to the left and right children, recursively checking against the next index in `arr`.
3. **Base Cases**:
   - If we reach a `None` node but still have elements left in `arr`, it's not a valid sequence.
   - If we reach the last element in `arr`, we check if we are at a leaf node.

### Solution Code
Below is the Python code formatted to be used in a LeetCode submission:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isValidSequence(self, root: TreeNode, arr: list[int]) -> bool:
        
        def dfs(node, arr, index):
            # Base case: if the current node is None
            if not node:
                return False
            
            # Check if the current node's value matches the current index in arr
            if index >= len(arr) or node.val != arr[index]:
                return False
            
            # If we are at the end of arr, check if the current node is a leaf
            if index == len(arr) - 1:
                return node.left is None and node.right is None
            
            # Recurse to the left and right children, incrementing the index
            return dfs(node.left, arr, index + 1) or dfs(node.right, arr, index + 1)
        
        return dfs(root, arr, 0)

# Example usage:
# tree = TreeNode(0, 
#                  TreeNode(1, 
#                            TreeNode(0), 
#                            TreeNode(1)
#                           ), 
#                  TreeNode(0, 
#                            TreeNode(1), 
#                            TreeNode(0)
#                           )
#                 )
# arr = [0, 1, 0, 1]
# sol = Solution()
# print(sol.isValidSequence(tree, arr))  # Output will be True

```

### Explanation of the Code:
1. **TreeNode Class**: This class represents the structure of a binary tree node.
2. **isValidSequence Function**: This is the main function where we initiate our DFS traversal.
3. **dfs Function**:
   - It takes the current node, the array `arr`, and the current index in the array.
   - Checks if the current node is `None`. If it is and we still have elements in `arr`, return `False`.
   - If the current node's value does not match the corresponding value in `arr`, return `False`.
   - If we reach the last element in `arr`, check if we're at a leaf node (both left and right children are `None`).
   - Finally, it recursively checks both children of the current node for the next index in `arr`.

This solution runs efficiently in O(n) time complexity, where n is the number of nodes in the tree. Given the constraints, this will work well within the limits provided.

# 1443. Minimum Time to Collect All Apples in a Tree

### Problem Description 
Given an undirected tree consisting of `n` vertices numbered from `0` to `n-1`, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at vertex 0 and coming back to this vertex.

The edges of the undirected tree are given in the array `edges`, where `edges[i] = [ai, bi]` means that exists an edge connecting the vertices `ai` and `bi`. Additionally, there is a boolean array `hasApple`, where `hasApple[i] = true` means that vertex `i` has an apple; otherwise, it does not have any apple.


Example 1:
Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]
Output: 8 
Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  

Example 2:
Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]
Output: 6
Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  

Example 3:
Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]
Output: 0

Constraints:
`1 <= n <= 10^5`
`edges.length == n - 1`
`edges[i].length == 2`
`0 <= ai < bi <= n - 1`
`fromi < toi`
`hasApple.length == n`

### Solution 
 To solve the problem of collecting apples in an undirected tree, we can model the tree using an adjacency list and perform a depth-first search (DFS). The goal is to calculate the minimum time to collect all apples and return to the starting point (vertex 0).

### Problem Breakdown

1. **Tree Representation**: Use an adjacency list to represent the tree. Each vertex will have a list of its neighbors.
2. **DFS Traversal**: We can traverse the tree starting from node 0 using DFS. During this traversal, we will check for apples in the connected nodes.
3. **Time Calculation**: For any path that leads to a node with apples, we account for both the path to the node and the return path, which represents the total time taken.

### Detailed Explanation

1. **Building the Adjacency List**: Using the list of edges, we can build an adjacency list where each node points to its connected nodes.
2. **Defining the DFS Function**: 
    - Check if the current node has an apple or if any of its children have apples.
    - If we find an apple, we count the time taken to go to that node and return.
3. **Collecting the Result**: Start the DFS from the root node (0) and accumulate the time required for all the paths leading to nodes with apples.
4. **Base Case of DFS**: Stop the recursion when reaching a leaf node, ensuring we only count paths that lead to nodes with apples.

### Code Implementation

Hereâ€™s how we can implement the solution in Python:



```python
class Solution:
    def minTimeToCollectAllApples(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        # Step 1: Build the adjacency list for the tree
        graph = {i: [] for i in range(n)}
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        # Step 2: Define the DFS function to traverse the tree
        def dfs(node: int, parent: int) -> int:
            total_time = 0
            # Explore all connected nodes
            for neighbor in graph[node]:
                if neighbor == parent:  # Skip the path back to parent node
                    continue
                # Recur on the child node
                time_from_child = dfs(neighbor, node)
                # If the child returns a time, it means we can collect apples there
                if time_from_child > 0 or hasApple[neighbor]:
                    total_time += time_from_child + 2  # +2 for going there and coming back
            return total_time
        
        # Step 3: Start DFS from the root node (0)
        return dfs(0, -1)


```

### Explanation of the Code

1. **Graph Construction**: We create a dictionary `graph` where each key is a node and the value is a list of its neighbors.
2. **DFS Function**: 
    - It takes a node and its parent to avoid traversing back immediately.
    - For each neighbor, we call `dfs` recursively.
    - If we find that a neighbor has an apple, we add `2` to `total_time` (once for going to the neighbor and once for returning).
3. **Return Value**: The main function returns the total time collected from the DFS starting at node `0`.

### Complexity Analysis

- **Time Complexity**: O(n) since each node and edge is visited exactly once in the DFS.
- **Space Complexity**: O(n) for storing the graph in the adjacency list format and the recursion stack.

This approach ensures that we efficiently compute the minimum time required to collect all apples, adhering to the constraints provided by the problem.

# 1448. Count Good Nodes in Binary Tree

### Problem Description 
Given a binary tree `root`, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.

Return the number of good nodes in the binary tree.


Example 1:
Input: root = [3,1,4,3,null,1,5]
Output: 4
Explanation: Nodes in blue are good.

Root Node (3) is always a good node.

Node 4 -> (3,4) is the maximum value in the path starting from the root.

Node 5 -> (3,4,5) is the maximum value in the path
Node 3 -> (3,1,3) is the maximum value in the path.


Example 2:
Input: root = [3,3,null,4,2]
Output: 3
Explanation: Node 2 -> (3, 3, 2) is not good, because "3" is higher than it.


Example 3:
Input: root = [1]
Output: 1
Explanation: Root is considered as good.


Constraints:
The number of nodes in the binary tree is in the range `[1, 10^5]`.

Each node's value is between `[-10^4, 10^4]`.

### Solution 
 To solve the problem of counting the "good" nodes in a binary tree, we can use a depth-first search (DFS) approach. A node is considered "good" if all nodes in the path from the root to that node have values less than or equal to the value of that node.

Here's a detailed explanation of how to implement this:

### Explanation of the Approach:

1. **Base Case**: The root node is always considered good since there are no nodes on the path before it.
  
2. **Recursive Traversal**: We use a DFS approach to traverse the tree. For each node, we need to:
   - Compare its value with the maximum value seen on the path from the root to that node. 
   - If the current nodeâ€™s value is greater than or equal to the maximum value for the path, it is considered good.
   - Update the maximum value for the path when we move to its children.

3. **Count Good Nodes**: Maintain a count of good nodes during the DFS traversal. 

4. **Termination and Recursion**: When we reach a leaf node, we return the count of good nodes computed.

### Implementation:

Here is how you can implement this solution in Python according to the LeetCode format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        def dfs(node, max_val):
            if not node:
                return 0
            
            # Check if the current node is a good node
            good_node_count = 1 if node.val >= max_val else 0
            
            # Update the maximum value on the path
            max_val = max(max_val, node.val)
            
            # Continue the DFS on the left and right children
            good_node_count += dfs(node.left, max_val)
            good_node_count += dfs(node.right, max_val)
            
            return good_node_count
        
        # Start DFS with the root node and its value as the max value
        return dfs(root, root.val)

```

### Detailed Breakdown of the Code:

- **TreeNode Class**: This defines the structure of each node in the binary tree.

- **`goodNodes` Method**: This is the main method where we kick off our DFS traversal. The `dfs` function is defined inside it to use the values of `max_val` conveniently.

- **DFS Function**:
  - It takes `node` and `max_val` as parameters.
  - If the node is `None`, we return 0 (base case).
  - We check if the current node is good. If it is, we initialize `good_node_count` to 1; otherwise, we set it to 0.
  - We then update `max_val` to be the maximum of the current `max_val` and the node's value.
  - We recursively call `dfs` for left and right children and add the counts from both sides to our `good_node_count`.
  
- Finally, we return the total count of good nodes from the initial call to `dfs`.

### Complexity Analysis:
- **Time Complexity**: O(N), where N is the number of nodes in the tree, since we visit each node exactly once.
- **Space Complexity**: O(H), where H is the height of the tree, due to the recursive stack space. In the worst case (a skewed tree), this could be O(N), but in a balanced tree, it would be O(log N).

This code should be able to run directly on the LeetCode platform to solve the stated problem.

# 1457. Pseudo-Palindromic Paths in a Binary Tree

### Problem Description 
Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.

Return the number of pseudo-palindromic paths going from the root node to leaf nodes.


Example 1:
Input: root = [2,3,1,3,1,null,1]
Output: 2 
Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).


Example 2:
Input: root = [2,1,1,1,3,null,null,null,null,null,1]
Output: 1 
Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).


Example 3:
Input: root = [9]
Output: 1

Constraints:
The number of nodes in the tree is in the range `[1, 105]`.

`1 <= Node.val <= 9`

### Solution 
 To solve the problem of counting pseudo-palindromic paths in a binary tree, we need to leverage the properties of a palindrome. A sequence can be rearranged into a palindrome if at most one digit has an odd frequency. 

Here's the detailed explanation and implementation of the solution:

### Explanation:

1. **Binary Tree and Path Representation**:
   - A binary tree is represented with nodes containing values. Our goal is to find paths from the root to the leaves of the tree.
   - Each path consists of the values of nodes from the root to a leaf.

2. **Pseudo-Palindromic Path**:
   - A path is pseudo-palindromic if the frequency of any value appears an even number of times, with the exception of at most one value (which can appear an odd number of times).

3. **DFS Approach**:
   - We will use a Depth First Search (DFS) approach to traverse the tree.
   - We can keep track of the frequency of the digits we encounter along the path using a dictionary or a bitmask.
   - If a leaf node is reached, we will check the frequency of the digits to determine if the path is pseudo-palindromic.

4. **Using a Bitmask**:
   - Instead of using a dictionary to count frequencies, we can use a bitmask of size 10 (1-9). Each bit in the mask will represent whether the corresponding digit has been seen an odd (`1`) or even (`0`) number of times.
   - We use `mask ^= (1 << value)` to toggle the bit corresponding to the digit encountered.

5. **Leaf Checking**:
   - Whenever we reach a leaf node, we will check if the count of odd frequencies is at most one by using `mask & (mask - 1) == 0` or simply counting the number of `1`s in the mask.

### Implementation in Python:

Hereâ€™s the complete code structured for LeetCode:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def pseudoPalindromicPaths(self, root: TreeNode) -> int:
        def dfs(node, mask):
            if not node:
                return 0
            
            # Toggle the bit corresponding to the node's value.
            mask ^= (1 << node.val)
            
            # If we reach a leaf node, check the mask.
            if not node.left and not node.right:
                # Check if at most one bit is set in mask
                if mask & (mask - 1) == 0:
                    return 1
                else:
                    return 0
            
            # Continue DFS on left and right children.
            return dfs(node.left, mask) + dfs(node.right, mask)
        
        # Start DFS with the initial mask set to 0.
        return dfs(root, 0)

```

### Explanation of the Code:
- **TreeNode Class**: Represents the structure of a tree node.
- **Solution Class**: Contains a method `pseudoPalindromicPaths` that initiates the DFS.
- **DFS Function**:
  - Takes a node and a bitmask.
  - It toggles the bit for the current node's value.
  - If a leaf node is reached, it checks the mask to determine if the path can be considered pseudo-palindromic.
  - Recursively calls itself for the left and right children.

### Complexity:
- **Time Complexity**: O(N) where N is the number of nodes in the tree, as we visit each node once.
- **Space Complexity**: O(H) where H is the height of the tree due to the recursive call stack.

This solution is efficient and works well within the problem's constraints.

# 1466. Reorder Routes to Make All Paths Lead to the City Zero

### Problem Description 
There are `n` cities numbered from `0` to `n-1` and `n-1` roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.

Roads are represented by `connections` where `connections[i] = [a, b]` represents a road from city `a` to `b`.

This year, there will be a big event in the capital (city 0), and many people want to travel to this city.

Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.

It's guaranteed that each city can reach the city 0 after reorder.


Example 1:
Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
Output: 3
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).


Example 2:
Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
Output: 2
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).


Example 3:
Input: n = 3, connections = [[1,0],[2,0]]
Output: 0

Constraints:
`2 <= n <= 5 * 10^4`
`connections.length == n-1`
`connections[i].length == 2`
`0 <= connections[i][0], connections[i][1] <= n-1`
`connections[i][0] != connections[i][1]`

### Solution 
 To solve the problem of reorienting the roads so that all cities can reach the capital (city 0), we can represent this as a graph traversal problem. The problem can be approached using Depth-First Search (DFS). Hereâ€™s a detailed breakdown of the solution:

### Problem Understanding
1. Given `n` cities and `n-1` directed roads forming a tree, our goal is to alter the direction of some roads such that every city can reach city 0.
2. Each road can either be directed towards the capital or away from it.
3. By counting how many roads lead away from city 0 and require redirection, we can determine the minimum number of changes needed.

### Solution Strategy
1. Build an adjacency list from the connections array which helps us efficiently traverse the roads.
2. Start a DFS from city 0. During this traversal:
   - If we come across a road directed away from city 0, we increment a counter.
3. Return the counter as the final number of roads that need to be reoriented.

### Complexity
- Time complexity: O(n) since we visit each edge once.
- Space complexity: O(n) for storing the adjacency list.

### Python Solution
Here's the complete code formatted for LeetCode:



```python
class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        from collections import defaultdict
        
        # Create an adjacency list to hold the roads
        roads = defaultdict(list)
        
        # Initialize the roads, where we store the directed edges
        for a, b in connections:
            roads[a].append((b, 1))  # road from a to b (needs to be reversed)
            roads[b].append((a, 0))  # road from b to a (no need to reverse)

        # Variable to count the number of roads that need to be reversed
        change_count = 0

        # Depth First Search function
        def dfs(city: int, parent: int):
            nonlocal change_count
            for neighbor, needs_reverse in roads[city]:
                if neighbor == parent:
                    continue  # Avoid going back to the parent
                change_count += needs_reverse  # Count if this edge needs to be reversed
                dfs(neighbor, city)  # Continue the DFS
        
        # Start DFS from the capital (city 0)
        dfs(0, -1)
        
        return change_count

```

### Explanation of the Code
1. Import necessary module and define the `Solution` class and the `minReorder` method.
2. We create a `defaultdict` to store adjacency lists for the roads. Each road is stored with a flag indicating whether it points away from city 0 (`1` for needs reverse, `0` for doesn't).
3. A `dfs` function is defined to traverse the graph. It increments `change_count` whenever a road directed away from city 0 is encountered.
4. Finally, we initiate a DFS from the capital city (city 0) and return the computed `change_count`.

### Usage
This code can be directly run in the LeetCode environment by defining it within the appropriate testing structure provided by LeetCode. It follows the LeetCode conventions and utilizes standard library functions to handle input and output.

# 1469. Find All The Lonely Nodes

### Problem Description 
In a binary tree, a lonely node is a node that is the only child of its parent node. The root of the tree is not lonely because it does not have a parent node.

Given the `root` of a binary tree, return an array containing the values of all lonely nodes in the tree. Return the list in any order.


Example 1:
Input: root = [1,2,3,null,4]
Output: [4]
Explanation: Light blue node is the only lonely node.

Node 1 is the root and is not lonely.

Nodes 2 and 3 have the same parent and are not lonely.


Example 2:
Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2]
Output: [6,2]
Explanation: Light blue nodes are lonely nodes.

Please remember that order doesn't matter, [2,6] is also an acceptable answer.


Example 3:
Input: root = [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]
Output: [77,55,33,66,44,22]
Explanation: Nodes 99 and 88 share the same parent. Node 11 is the root.

All other nodes are lonely.


Example 4:
Input: root = [197]
Output: []

Example 5:
Input: root = [31,null,78,null,28]
Output: [78,28]

Constraints:
The number of nodes in the `tree` is in the range `[1, 1000].`
Each node's value is between `[1, 10^6]`.

### Solution 
 To solve the problem of finding lonely nodes in a binary tree, we need to traverse the tree and check if a node is the only child of its parent. A node is considered lonely if it has no sibling, which means it must be the only child of its parent.

Here's a detailed step-by-step plan to solve this problem:

1. **Understanding the Structure**: We'll use a modified depth-first search (DFS) to traverse the binary tree. We'll keep track of each node's parent node during traversal to check if a node is lonely.

2. **Implementing the Traversal**: We can leverage recursion to explore left and right children of each node. For each node we visit, we will check:
   - If it has a left child, we will check if it has a right sibling. If not, we add it to the list of lonely nodes.
   - If it has a right child, we will check if it has a left sibling. If not, we add it to the list of lonely nodes.

3. **Storing Results**: We will maintain a list to which we will append the values of lonely nodes as we identify them during the traversal.

4. **Returning the Result**: Finally, we will return the list of lonely nodes.

### Python Code Implementation

The following code encapsulates the above logic into a solution format that can be run on LeetCode.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def getLonelyNodes(self, root: TreeNode) -> List[int]:
        lonely_nodes = []
        
        def dfs(node, has_sibling):
            if not node:
                return
            # Check if it's a lonely node
            if (node.left and not node.right):
                lonely_nodes.append(node.left.val)
            if (node.right and not node.left):
                lonely_nodes.append(node.right.val)
                
            # Continue traversing the tree
            dfs(node.left, node.right is not None)
            dfs(node.right, node.left is not None)
        
        # Start DFS from the root
        dfs(root, False)

        return lonely_nodes

```

### Explanation of the Code:

1. **TreeNode Class**: Defines the structure of a tree node which includes its value (`val`), left child (`left`), and right child (`right`).

2. **Solution Class**: Contains the method `getLonelyNodes` which traverses the tree.

3. **Lonely Node Detection**:
   - We define a nested function `dfs` that takes in a node and whether its sibling exists. 
   - We check if a node has a left child without a right child or vice versa to determine if it is lonely.
   - We use recursion to visit the left and right children of the current node.

4. **Return**: The function returns a list of lonely node values.

### Usage:
- To use this code on LeetCode, define your binary tree using the `TreeNode` class, and call `Solution().getLonelyNodes(root)` where `root` is the root of your binary tree.

This solution is efficient and adheres to the constraints provided. It traverses the tree once, making it O(N) in terms of time complexity where N is the number of nodes in the tree, and it utilizes O(H) additional space where H is the height of the tree due to recursion stack, which is manageable within the problem's constraints.

# 1485. Clone Binary Tree With Random Pointer

### Problem Description 
A binary tree is given such that each node contains an additional random pointer which could point to any node in the tree or null.

Return a deep copy of the tree.

The tree is represented in the same input/output way as normal binary trees where each node is represented as a pair of `[val, random_index]` where:
`val`: an integer representing `Node.val`
`random_index`: the index of the node (in the input) where the random pointer points to, or `null` if it does not point to any node.

You will be given the tree in class `Node` and you should return the cloned tree in class `NodeCopy`. `NodeCopy` class is just a clone of `Node` class with the same attributes and constructors.


Example 1:
Input: root = [[1,null],null,[4,3],[7,0]]
Output: [[1,null],null,[4,3],[7,0]]
Explanation: The original binary tree is [1,null,4,7].

The random pointer of node one is null, so it is represented as [1, null].

The random pointer of node 4 is node 7, so it is represented as [4, 3] where 3 is the index of node 7 in the array representing the tree.

The random pointer of node 7 is node 1, so it is represented as [7, 0] where 0 is the index of node 1 in the array representing the tree.


Example 2:
Input: root = [[1,4],null,[1,0],null,[1,5],[1,5]]
Output: [[1,4],null,[1,0],null,[1,5],[1,5]]
Explanation: The random pointer of a node can be the node itself.


Example 3:
Input: root = [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]
Output: [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]

Example 4:
Input: root = []
Output: []

Example 5:
Input: root = [[1,null],null,[2,null],null,[1,null]]
Output: [[1,null],null,[2,null],null,[1,null]]

Constraints:
The number of nodes in the `tree` is in the range `[0, 1000].`
Each node's value is between `[1, 10^6]`.

### Solution 
 To solve the problem of creating a deep copy of a binary tree where each node has a random pointer, we'll follow a structured approach. The problem can be broken down into the following steps:

1. **Understand the Node Structure**: The original binary tree nodes have a value and a random pointer that can point to any node or be null. We'll define a `Node` class with these properties.

2. **Define the Copy Node Class**: We will create a `NodeCopy` class, which will have the same attributes as the `Node` class to create the deep copy.

3. **Implement the Copy Logic**: To perform the deep copy, we will use a dictionary to keep track of the original nodes and their corresponding copies. This will allow us to easily set the random pointers in the copied tree.

4. **Convert Input Format**: Since the input will be formatted as a list of lists, we will need to handle the conversion from this format to our `Node` and `NodeCopy` objects.

5. **Return the Deep Copied Tree**: Finally, we will return the root of the copied tree.

The following Python code implements these steps and follows the format suitable for running on LeetCode.



```python
class Node:
    def __init__(self, val=0, left=None, right=None, random=None):
        self.val = val
        self.left = left
        self.right = right
        self.random = random

class NodeCopy:
    def __init__(self, val=0, left=None, right=None, random=None):
        self.val = val
        self.left = left
        self.right = right
        self.random = random

def copyRandomBinaryTree(root: Node) -> NodeCopy:
    if not root:
        return None
    
    # Step 1: Create a mapping from original nodes to their copies
    mapping = {}
    
    def clone_tree(node):
        if not node:
            return None
        # If this node is already cloned, return the clone
        if node in mapping:
            return mapping[node]
        # Create a copy of the current node
        copy_node = NodeCopy(node.val)
        mapping[node] = copy_node
        # Recursively clone left and right
        copy_node.left = clone_tree(node.left)
        copy_node.right = clone_tree(node.right)
        return copy_node
    
    # Step 2: Clone the tree
    cloned_root = clone_tree(root)
    
    # Step 3: Set the random pointers for the cloned tree
    for original_node, copied_node in mapping.items():
        if original_node.random:
            copied_node.random = mapping[original_node.random]
    
    return cloned_root

# Helper function to build the tree from input data (this typically won't be part of LeetCode submission)
def build_tree_from_input(input_list):
    if not input_list:
        return None
    
    nodes = [Node(val=x[0]) for x in input_list]
    for i, x in enumerate(input_list):
        if x[1] is not None:
            nodes[i].random = nodes[x[1]]  # Set random pointers based on input
    idx = 1
    for node in nodes:
        if idx < len(nodes):
            node.left = nodes[idx]  # Set left child
            idx += 1
        if idx < len(nodes):
            node.right = nodes[idx]  # Set right child
            idx += 1
    return nodes[0]

# Example Testing
root = build_tree_from_input([[1, None], None, [4, 3], [7, 0]])
cloned_tree = copyRandomBinaryTree(root)

```

### Explanation of the Code:
- **Node Class**: Represents each node in the original tree.
- **NodeCopy Class**: Represents the corresponding clone of each node in the copied tree.
- **copyRandomBinaryTree Function**: This is the main function that performs the cloning:
   - A helper function `clone_tree` recursively creates copies of nodes while maintaining a mapping of original to copied nodes to handle random pointers conveniently.
   - After the tree structure is copied, random pointers in the copied nodes are established based on the mapping created initially.
- **build_tree_from_input Function**: This utility builds a binary tree from the given array format. This is not part of the LeetCode solution directly but aids in testing the function.

This implementation ensures we respect the structure of the problem and meets the constraints given effectively.

# 1490. Clone N-ary Tree

### Problem Description 
Given a `root` of an N-ary tree, return a deep copy (clone) of the tree.

Each node in the n-ary tree contains a val (`int`) and a list (`List[Node]`) of its children.

class Node {
    public int val;
    public List<Node> children;
}
Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).

Follow up: Can your solution work for the graph problem?

Example 1:
Input: root = [1,null,3,2,4,null,5,6]
Output: [1,null,3,2,4,null,5,6]

Example 2:
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]

Constraints:
The depth of the n-ary tree is less than or equal to `1000`.

The total number of nodes is between `[0, 10^4]`.

### Solution 
 Certainly! Let's solve the problem of creating a deep copy of an N-ary tree. We'll provide the solution in a manner compatible with LeetCode, including the required class definitions and methods.

### Problem Breakdown
1. **N-ary Tree Definition**: Each node has a value (`val`) and a list of children (`children`).
2. **Deep Copy**: We need to create a new tree that has the same structure and values as the original but is entirely separate in memory.

### Input and Output
- **Input**: A serialized representation of an N-ary tree.
- **Output**: A deep copied serialized representation.

### Solution Approach
The problem can be solved using either Depth First Search (DFS) or Breadth First Search (BFS). In this solution, we'll use DFS for its simplicity when dealing with tree structures. 

### Steps:
1. **Node Traversal**: Traverse the original tree and create a copy of each node.
2. **Recursion**: For each node, recursively copy its children.
3. **Return the new tree**: At the end of the traversal, we'll have a completely cloned tree.

### Python Code Implementation
Here's how we would implement this in Python:



```python
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

class Solution:
    def cloneTree(self, root: 'Node') -> 'Node':
        if root is None:
            return None
        
        # Create a copy of the root node
        cloned_root = Node(root.val)
        
        # Recursively clone each child
        for child in root.children:
            cloned_root.children.append(self.cloneTree(child))
        
        return cloned_root

```

### Explanation
- **Node Class**: This defines the structure of a node in the N-ary tree with a constructor that initializes the `val` and `children`.
- **cloneTree Method**:
  - Base Case: If the input `root` is `None`, we return `None` (to handle empty trees).
  - Create a new node (`cloned_root`) with the same value as the original node.
  - Recursively call `cloneTree` for each child of the original root. Append the returned cloned nodes to the `children` list of the cloned node.
  - Finally, return the `cloned_root`.

### Complexity Analysis
- **Time Complexity**: O(N), where N is the number of nodes in the tree since we visit each node exactly once.
- **Space Complexity**: O(N), for the recursive stack and the cloned nodes storage.

### Conclusion
This implementation satisfies the requirement to create a deep copy of an N-ary tree, and the provided format is compatible with LeetCode for direct submission and execution.

# 1516. Move Sub-Tree of N-Ary Tree

### Problem Description 
Given the `root` of an N-ary tree of unique values, and two nodes of the tree `p` and `q`.

You should move the subtree of the node `p` to become a direct child of node `q`. If `p` is already a direct child of `q`, don't change anything. Node `p` must be the last child in the children list of node `q`.

Return the root of the tree after adjusting it.

There are 3 cases for nodes `p` and `q`:
Node `q` is in the sub-tree of node `p`.

Node `p` is in the sub-tree of node `q`.

Neither node `p` is in the sub-tree of node `q` nor node `q` is in the sub-tree of node `p`.

In cases 2 and 3, you just need to move `p` (with its sub-tree) to be a child of `q`, but in case 1 the tree may be disconnected, thus you need to reconnect the tree again. Please read the examples carefully before solving this problem.

Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).

For example, the above tree is serialized as [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].


Example 1:
Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 4, q = 1
Output: [1,null,2,3,4,null,5,null,6,null,7,8]
Explanation: This example follows the second case as node p is in the sub-tree of node q. We move node p with its sub-tree to be a direct child of node q.

Notice that node 4 is the last child of node 1.


Example 2:
Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 7, q = 4
Output: [1,null,2,3,null,4,5,null,6,null,7,8]
Explanation: Node 7 is already a direct child of node 4. We don't change anything.


Example 3:
Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 3, q = 8
Output: [1,null,2,null,4,5,null,7,8,null,null,null,3,null,6]
Explanation: This example follows case 3 because node p is not in the sub-tree of node q and vice-versa. We can move node 3 with its sub-tree and make it as node 8's child.


Example 4:
Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 2, q = 7
Output: [1,null,7,3,null,2,null,6,null,4,5,null,null,8]
Explanation: Node q is in the sub-tree of node p, so this is case 1.

The first step, we move node p (with all of its sub-tree except for node q) and add it as a child to node q.

Then we will see that the tree is disconnected, you need to reconnect node q to replace node p as shown.


Example 5:
Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 1, q = 2
Output: [2,null,4,5,1,null,7,8,null,null,3,null,null,null,6]
Explanation: Node q is in the sub-tree of node p, so this is case 1.

The first step, we move node p (with all of its sub-tree except for node q) and add it as a child to node q.

As node p was the root of the tree, node q replaces it and becomes the root of the tree.


Constraints:
The total number of nodes is between `[2, 1000]`.

Each node has a unique value.

`p != null`
`q != null`
`p` and `q` are two different nodes (i.e. `p != q`).

### Solution 
 To solve the problem of moving a subtree rooted at node `p` to become a child of node `q` in an N-ary tree, we need to consider a few key operations. Below is a structured solution that meets the specifications of a typical LeetCode submission, including necessary helper classes and detailed explanations.

### Step-by-step Explanation

1. **Understand the Tree Structure**:
    - An N-ary tree is represented where each node can have zero or more children.
    - The conversions between tree nodes and their data structure (e.g., list) will need to be handled carefully.

2. **Identifying Cases**:
    - Case 1: `q` is in the subtree of `p`: We need to disconnect `q` from `p` and attach `p` as a child of `q`.
    - Case 2: `p` is already a child of `q`: No action is necessary.
    - Case 3: Both nodes are independent: Simply move the subtree of `p` under `q`.

3. **Implementation Strategy**:
    - First, perform a search to see where `p` and `q` are located regarding each other.
    - Depending on the relationship identified, carry out the appropriate operation to move the subtree of `p` under `q`.

4. **Edge Cases**:
    - Always ensure that moving occurs correctly based on the absence or presence of child nodes.

Let's proceed to the implementation:



```python
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

class Solution:
    def moveSubtree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':
        # Edge case check
        if not root or not p or not q:
            return root
        
        # To find p and q in the tree and determine their relationship
        parent = {root: None}  # This will keep track of the parent nodes
        stack = [root]
        
        while stack:
            node = stack.pop()
            for child in node.children:
                parent[child] = node
                stack.append(child)

        def is_descendant(root: 'Node', node: 'Node') -> bool:
            """ Helper function to check if 'node' is in the subtree rooted at 'root' """
            if root is None:
                return False
            if root == node:
                return True
            for child in root.children:
                if is_descendant(child, node):
                    return True
            return False

        # Check the relationships
        if is_descendant(p, q):  # case 1
            parent_of_q = parent[q]
            # Remove q from its parent (if not already root)
            if parent_of_q:
                parent_of_q.children.remove(q)
            # Move p over q and attach q as child of p
            p.children.append(q)
            return p

        if is_descendant(q, p):  # case 2
            return root  # No changes needed, p is already a child of q

        # Case 3: Neither is a descendant of the other
        # Parent of p needs to detach p and attach to q
        parent_of_p = parent[p]
        if parent_of_p:
            parent_of_p.children.remove(p)
        
        q.children.append(p)  # Move p to be a child of q
        return root

# Example of how to run the code on LeetCode would use the constructor for Node 
# and passing the tree as described in the problem.

```

### Summary of the Code
1. **Modeling the Node**: We define a `Node` class to represent each node in the tree.
2. **Finding Relationships**: We utilize DFS to build a mapping of parents to nodes, which simplifies checking for descendants.
3. **Handling Cases**: We check the relationships between `p` and `q` to perform the required action.
4. **Returning the Result**: The function returns the modified tree's root. 

This solution efficiently handles all specified cases, ensuring that the operations maintain the integrity of the N-ary tree structure.

# 1530. Number of Good Leaf Nodes Pairs

### Problem Description 
Given the `root` of a binary tree and an integer `distance`. A pair of two different leaf nodes of a binary tree is said to be good if the length of the shortest path between them is less than or equal to `distance`.

Return the number of good leaf node pairs in the tree.


Example 1:
Input: root = [1,2,3,null,4], distance = 3
Output: 1
Explanation: The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.


Example 2:
Input: root = [1,2,3,4,5,6,7], distance = 3
Output: 2
Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.


Example 3:
Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
Output: 1
Explanation: The only good pair is [2,5].


Example 4:
Input: root = [100], distance = 1
Output: 0

Example 5:
Input: root = [1,1,1], distance = 2
Output: 1

Constraints:
The number of nodes in the `tree` is in the range `[1, 2^10].`
Each node's value is between `[1, 100]`.

`1 <= distance <= 10`

### Solution 
 To solve the problem of counting the number of good leaf node pairs in a binary tree based on the distance constraint, we can leverage a depth-first search (DFS) approach. We will traverse the binary tree, identify leaf nodes, and calculate the distances between them.

Hereâ€™s the plan:

1. **Identify Leaf Nodes**: Leaf nodes are defined as nodes that do not have any children. During our DFS traversal, we will keep track of the distances from a parent leaf node to its child leaf nodes.

2. **Count Good Pairs**: When we find leaf nodes, we will count how many of them can be considered "good pairs." A pair is good if the distance between them is less than or equal to the given distance.

3. **Store Distances**: As we backtrack up the tree, we will store the distances to each leaf node in a list. Each time we return from a leaf node, we will check combinations of the leaves stored to count valid pairs.

Here is the code following the LeetCode solution format:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
class Solution:
    def countPairs(self, root: TreeNode, distance: int) -> int:
        self.answer = 0
        
        # Helper function to perform DFS
        def dfs(node):
            if not node:
                return []
            
            # If it's a leaf node, return a list with a single element (distance 1)
            if not node.left and not node.right:
                return [1]
        
            # Gather distances from left and right subtrees
            left_distances = dfs(node.left)
            right_distances = dfs(node.right)

            # Compare distances between leaves from left and right child
            for l in left_distances:
                for r in right_distances:
                    if l + r <= distance:
                        self.answer += 1
            
            # Prepare the distances to return to the parent
            # Increase each distance by 1 (since moving up one level increases the distance)
            return [d + 1 for d in left_distances + right_distances]

        # Start the DFS from the root
        dfs(root)
        return self.answer

```

### Explanation of the Code:

1. **TreeNode Class**: We define the `TreeNode` class which represents each node in the tree.

2. **Solution Class**: We define the `Solution` class which contains the method `countPairs`.

3. **countPairs Method**: This is the main method that initializes an answer counter to keep track of the number of good pairs. It then calls the helper DFS function.

4. **DFS Function**:
   - If the current node is `None`, it returns an empty list, indicating no distances.
   - If the current node is a leaf, it returns a list with a single element: the distance of 1 (itself).
   - It recursively gathers distances from both the left and right children.
   - It then checks the accumulated distances to see how many pairs are good based on the given distance.
   - Lastly, it increments each distance by 1 (to account for moving up a level in the tree) and concatenates the lists of distances from both subtrees for the parent to utilize.

5. **Return the Result**: Finally, the method returns the total count of good leaf node pairs.

### Complexity Analysis:
- **Time Complexity**: O(N^2) in the worst case, where N is the number of leaf nodes. This can occur if we have to check all pairs of leaves in the tree.
- **Space Complexity**: O(N) for storing the list of distances, where N is the number of leaf nodes in the worst case.

This code can be directly run on LeetCode by providing the binary tree in the specified input format.

# 1586. Binary Search Tree Iterator II

### Problem Description 
Implement the `BSTIterator` class that represents an iterator over the in-order traversal of a binary search tree (BST):
`BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.

`boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.

`int next()` Moves the pointer to the right, then returns the number at the pointer.

`boolean hasPrev()` Returns `true` if there exists a number in the traversal to the left of the pointer, otherwise returns `false`.

`int prev()` Moves the pointer to the left, then returns the number at the pointer.

Notice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.

You may assume that `next()` and `prev()` calls will always be valid. That is, there will be at least a next/previous number in the in-order traversal when `next()`/`prev()` is called.


Example 1:
Input
["BSTIterator", "next", "next", "prev", "next", "hasNext", "next", "next", "next", "hasNext", "hasPrev", "prev", "prev"]
[[[7, 3, 15, null, null, 9, 20]], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null]]
Output
[null, 3, 7, 3, 7, true, 9, 15, 20, false, true, 15, 9]
Explanation
// The underlined element is where the pointer currently is.

BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); // state is   [3, 7, 9, 15, 20]
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 3
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 7
bSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 3
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 7
bSTIterator.hasNext(); // return true
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 9
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 15
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 20
bSTIterator.hasNext(); // return false
bSTIterator.hasPrev(); // return true
bSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 15
bSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 9

Constraints:
The number of nodes in the tree is in the range `[1, 105]`.

`0 <= Node.val <= 106`
At most `105` calls will be made to `hasNext`, `next`, `hasPrev`, and `prev`.

Follow up: Could you solve the problem without precalculating the values of the tree?

### Solution 
 To solve the problem of implementing an iterator for the in-order traversal of a Binary Search Tree (BST), we need to create a class called `BSTIterator`. This iterator will allow us to traverse the BST in both forward and backward directions, returning values accordingly.

### Breakdown of the Solution

1. **In-Order Traversal**: In a BST, in-order traversal involves visiting the left subtree, the root, and then the right subtree. This gives us the values in ascending order.
  
2. **Data Structures**: We will use a stack to help in the traversal. The stack will allow us to remember which nodes we need to visit next when we call `next()`.

3. **Initialization**: The constructor will initialize the iterator and populate the stack with left children of the given root. This way, we can easily access the smallest element when we perform the first `next()` call.

4. **Methods**:
   - `hasNext()`: Check if there's a next element by verifying if our stack is not empty.
   - `next()`: Pop the top element from the stack (the next smallest element), push its right child and all its left descendants onto the stack, and return the value.
   - `hasPrev()`: This can simply check if the current index is greater than zero, since we will maintain a list of values.
   - `prev()`: If there's a previous element, decrement the pointer and return the previous value from the list.

Hereâ€™s how the implementation looks:



```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BSTIterator:
    def __init__(self, root: TreeNode):
        self.stack = []
        self.current_index = -1
        self.vals = []
        self._inorder_traversal(root)
    
    def _inorder_traversal(self, node):
        if node:
            self._inorder_traversal(node.left)
            self.vals.append(node.val)
            self._inorder_traversal(node.right)
    
    def hasNext(self) -> bool:
        return self.current_index + 1 < len(self.vals)
    
    def next(self) -> int:
        self.current_index += 1
        return self.vals[self.current_index]
    
    def hasPrev(self) -> bool:
        return self.current_index > 0
    
    def prev(self) -> int:
        if self.hasPrev():
            self.current_index -= 1
            return self.vals[self.current_index]
        else:
            raise IndexError("No previous element")

# Example usage:
# bst = TreeNode(7)
# bst.left = TreeNode(3)
# bst.right = TreeNode(15, TreeNode(9), TreeNode(20))
# iterator = BSTIterator(bst)
# while iterator.hasNext():
#     print(iterator.next())

```

### Explanation of Key Components
- **TreeNode class**: Represents a node in the binary search tree.
- **BSTIterator class**:
  - The `__init__` constructor initializes the stack and current index, and it calls a helper function to populate the values in order.
  - `_inorder_traversal` function constructs a list of the nodes' values in sorted order.
  - `hasNext()` checks if there are more elements to traverse.
  - `next()` fetches the next element in the traversal.
  - `hasPrev()` checks if a previous element exists.
  - `prev()` returns the previous element.

### Complexity
- The space complexity is O(h) for the stack where h is the height of the tree.
- The time complexity for each operation is O(1) for `next()`, `hasNext()`, `hasPrev()`, and `prev()`, while the initial in-order construction is O(n).

This solution is efficient and meets the problem constraints effectively.

# 1597. Build Binary Expression Tree From Infix Expression

### Problem Description 
A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal nodes (nodes with 2 children) correspond to the operators `'+'` (addition), `'-'` (subtraction), `'*'` (multiplication), and `'/'` (division).

For each internal node with operator `o`, the infix expression that it represents is `(A o B)`, where `A` is the expression the left subtree represents and `B` is the expression the right subtree represents.

You are given a string `s`, an infix expression containing operands, the operators described above, and parentheses `'('` and `')'`.

Return any valid binary expression tree, which its in-order traversal reproduces `s` after omitting the parenthesis from it (see examples below).

Please note that order of operations applies in `s`. That is, expressions in parentheses are evaluated first, and multiplication and division happen before addition and subtraction.

Operands must also appear in the same order in both `s` and the in-order traversal of the tree.


Example 1:
Input: s = "3*4-2*5"
Output: [-,*,*,3,4,2,5]
Explanation: The tree above is the only valid tree whose inorder traversal produces s.


Example 2:
Input: s = "2-3/(5*2)+1"
Output: [+,-,1,2,/,null,null,null,null,3,*,null,null,5,2]
Explanation: The inorder traversal of the tree above is 2-3/5*2+1 which is the same as s without the parenthesis. The tree also produces the correct result and its operands are in the same order as they appear in s.

The tree below is also a valid binary expression tree with the same inorder traversal as s, but it not a valid answer because it does not evaluate to the same value.

The third tree below is also not valid. Although it produces the same result and is equivalent to the above trees, its inorder traversal does not produce s and its operands are not in the same order as s.


Example 3:
Input: s = "1+2+3+4+5"
Output: [+,+,5,+,4,null,null,+,3,null,null,1,2]
Explanation: The tree [+,+,5,+,+,null,null,1,2,3,4] is also one of many other valid trees.


Constraints:
`1 <= s.length <= 1000`
`s` consists of digits and the characters `'+'`, `'-'`, `'*'`, and `'/'`.

Operands in `s` are exactly 1 digit.

It is guaranteed that `s` is a valid expression.

### Solution 
 To construct a binary expression tree from the given infix expression string, we need to consider the operator precedence and the structure of the expression. The approach we'll take is to convert the infix expression into a parse tree that correctly reflects the order of operations as well as the structure mandated by the rules of binary expression trees.

### Steps to Solve the Problem:

1. **Operator Precedence**: We must define the precedence of the operators in the expression. The precedence determines how we group operators, with higher precedence operators evaluated before lower ones.

2. **Tree Node Structure**: Define a `TreeNode` class that can store an operator or an operand and has pointers to left and right children.

3. **Parsing the Expression**: We'll create a function that uses a stack-based approach (or recursive parsing) to build the binary expression tree based on the operator precedence and the parentheses in the expression.

4. **Inorder Traversal Building**: After building the tree, we will define a method to traverse it in order to return the correct list that represents the tree structure as required.

5. **Serialization**: Finally, serialize the tree according to the specified output format.

### Implementation:

Here is the code that implements the above logic.



```python
class TreeNode:
    def __init__(self, val=None):
        self.val = val
        self.left = None
        self.right = None

class Solution:
    def expTree(self, s: str) -> TreeNode:
        precedence = {'+': 1, '-': 1, '*': 2, '/': 2}

        def to_postfix(expression):
            output = []
            stack = []
            i = 0
            while i < len(expression):
                char = expression[i]

                if char.isdigit():  # If the character is an operand
                    output.append(char)
                elif char in precedence:  # If the character is an operator
                    while (stack and stack[-1] != '(' and 
                           precedence[stack[-1]] >= precedence[char]):
                        output.append(stack.pop())
                    stack.append(char)

                elif char == '(':  # If the character is '('
                    stack.append(char)
                elif char == ')':  # If the character is ')'
                    while stack and stack[-1] != '(':
                        output.append(stack.pop())
                    stack.pop()  # Pop the '('
                i += 1

            while stack:  # Pop all the operators from the stack
                output.append(stack.pop())

            return output

        def build_expression_tree(postfix):
            stack = []
            for token in postfix:
                if token.isdigit():
                    stack.append(TreeNode(token))
                else:
                    right = stack.pop()
                    left = stack.pop()
                    node = TreeNode(token)
                    node.left = left
                    node.right = right
                    stack.append(node)
            return stack[0]  # The root of the expression tree

        postfix = to_postfix(s)
        return build_expression_tree(postfix)

# Function to serialize the tree in required format
def serialize(root: TreeNode):
    result = []
    def dfs(node):
        if node is None:
            result.append("null")
            return
        result.append(node.val)
        dfs(node.left)
        dfs(node.right)
    dfs(root)
    return result

# Example usage:
solution = Solution()
root = solution.expTree("2-3/(5*2)+1")
serialized_output = serialize(root)
print(serialized_output)

```

### Explanation:

- **`TreeNode` Class**: A simple class to construct each node of the binary expression tree.
  
- **`to_postfix` Function**: Converts the infix expression into postfix (Reverse Polish Notation) to facilitate easy tree construction. It uses a stack to manage operators and respects operator precedence and parentheses.

- **`build_expression_tree` Function**: Constructs the binary expression tree from the postfix expression. It uses another stack where it creates nodes for operators and attaches child nodes for operands.

- **`serialize` Function**: Traverses the tree for output formatting, ensuring that nulls are used for missing children.

This implementation adheres to the constraints and specifications laid out in the problem description and can be run on LeetCode directly.

# 1600. Throne Inheritance

### Problem Description 
A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born.

The kingdom has a well-defined order of inheritance that consists of the king as the first member. Let's define the recursive function `Successor(x, curOrder)`, which given a person `x` and the inheritance order so far, returns who should be the next person after `x` in the order of inheritance.

Successor(x, curOrder):
    if x has no children or all of x's children are in curOrder:
        if x is the king return null
        else return Successor(x's parent, curOrder)
    else return x's oldest child who's not in curOrder
For example, assume we have a kingdom that consists of the king, his children Alice and Bob (Alice is older than Bob), and finally Alice's son Jack.

In the beginning, `curOrder` will be `["king"]`.

Calling `Successor(king, curOrder)` will return Alice, so we append to `curOrder` to get `["king", "Alice"]`.

Calling `Successor(Alice, curOrder)` will return Jack, so we append to `curOrder` to get `["king", "Alice", "Jack"]`.

Calling `Successor(Jack, curOrder)` will return Bob, so we append to `curOrder` to get `["king", "Alice", "Jack", "Bob"]`.

Calling `Successor(Bob, curOrder)` will return `null`. Thus the order of inheritance will be `["king", "Alice", "Jack", "Bob"]`.

Using the above function, we can always obtain a unique order of inheritance.

Implement the `ThroneInheritance` class:
`ThroneInheritance(string kingName)` Initializes an object of the `ThroneInheritance` class. The name of the king is given as part of the constructor.

`void birth(string parentName, string childName)` Indicates that `parentName` gave birth to `childName`.

`void death(string name)` Indicates the death of `name`. The death of the person doesn't affect the `Successor` function nor the current inheritance order. You can treat it as just marking the person as dead.

`string[] getInheritanceOrder()` Returns a list representing the current order of inheritance excluding dead people.


Example 1:
Input
["ThroneInheritance", "birth", "birth", "birth", "birth", "birth", "birth", "getInheritanceOrder", "death", "getInheritanceOrder"]
[["king"], ["king", "andy"], ["king", "bob"], ["king", "catherine"], ["andy", "matthew"], ["bob", "alex"], ["bob", "asha"], [null], ["bob"], [null]]
Output
[null, null, null, null, null, null, null, ["king", "andy", "matthew", "bob", "alex", "asha", "catherine"], null, ["king", "andy", "matthew", "alex", "asha", "catherine"]]
Explanation
ThroneInheritance t= new ThroneInheritance("king"); // order: king
t.birth("king", "andy"); // order: king > andy
t.birth("king", "bob"); // order: king > andy > bob
t.birth("king", "catherine"); // order: king > andy > bob > catherine
t.birth("andy", "matthew"); // order: king > andy > matthew > bob > catherine
t.birth("bob", "alex"); // order: king > andy > matthew > bob > alex > catherine
t.birth("bob", "asha"); // order: king > andy > matthew > bob > alex > asha > catherine
t.getInheritanceOrder(); // return ["king", "andy", "matthew", "bob", "alex", "asha", "catherine"]
t.death("bob"); // order: king > andy > matthew > bob > alex > asha > catherine
t.getInheritanceOrder(); // return ["king", "andy", "matthew", "alex", "asha", "catherine"]

Constraints:
`1 <= kingName.length, parentName.length, childName.length, name.length <= 15`
`kingName`, `parentName`, `childName`, and `name` consist of lowercase English letters only.

All arguments `childName` and `kingName` are distinct.

All `name` arguments of `death` will be passed to either the constructor or as `childName` to `birth` first.

For each call to `birth(parentName, childName)`, it is guaranteed that `parentName` is alive.

At most `105` calls will be made to `birth` and `death`.

At most `10` calls will be made to `getInheritanceOrder`.

### Solution 
 To solve the problem of inheritance in the kingdom, we can design a class called `ThroneInheritance`. This class will maintain a structure to represent family relationships and handle births, deaths, and inheritance orders efficiently.

### Explanation:

1. **Data Structure**: We'll use a dictionary (hashmap) to store the family tree, where each key will represent a person's name and the value will be a list of that person's children. Additionally, we will use a set to keep track of dead individuals.

2. **Initialization**: The class is initialized with the name of the king, who is the root of our family tree.

3. **Birth Function**: When a new child is born, we simply append the child to the list of their parent's children in the tree structure.

4. **Death Function**: This function will mark an individual as dead by adding them to the set of dead individuals.

5. **Get Inheritance Order**: This function will perform a depth-first traversal (DFS) of our family tree. It will build a list of the living individuals in the correct inheritance order, omitting those marked as dead.

Letâ€™s implement this logic in Python using the specified format so that it can be directly run on LeetCode.



```python
class ThroneInheritance:

    def __init__(self, kingName: str):
        self.kingName = kingName
        self.tree = {kingName: []}  # family tree to hold parent-child relationships
        self.dead = set()  # set to track dead individuals

    def birth(self, parentName: str, childName: str) -> None:
        # Add the child to the parent's list of children
        if parentName in self.tree:
            self.tree[parentName].append(childName)
            self.tree[childName] = []  # Initialize the new child's list of children

    def death(self, name: str) -> None:
        # Mark the individual as dead
        self.dead.add(name)

    def getInheritanceOrder(self) -> list:
        # To retrieve the current order of inheritance
        result = []
        
        def dfs(person):
            # If the person is not dead, add to the result
            if person not in self.dead:
                result.append(person)
            # Visit children
            for child in self.tree[person]:
                dfs(child)
        
        # Start the DFS from the king
        dfs(self.kingName)
        return result

```

### Explanation of Methods:

- **`__init__(self, kingName: str)`**: Initializes the object with the king's name, sets up their corresponding entry in the family tree, and initializes the set for dead individuals.

- **`birth(self, parentName: str, childName: str)`**: Appends a new child to the specified parent's list of children and initializes the child's entry in the family tree.

- **`death(self, name: str)`**: Adds the specified individual to the `dead` set, marking them as deceased.

- **`getInheritanceOrder(self) -> list`**: Constructs the inheritance order by performing a DFS traversal starting from the king. Only living individuals are added to the result list.

### Efficiency:
- The time complexity for each operation (birth, death, getInheritanceOrder) is efficient due to the use of dictionary and set data structures, allowing for O(1) average time complexity for inserts and lookups.

This implementation efficiently manages the family tree structure while allowing for dynamic birth and death events, with the ability to retrieve the current order of inheritance of living individuals promptly.

# 1602. Find Nearest Right Node in Binary Tree

### Problem Description 
Given the `root` of a binary tree and a node `u` in the tree, return the nearest node on the same level that is to the right of `u`, or return `null` if `u` is the rightmost node in its level.


Example 1:
Input: root = [1,2,3,null,4,5,6], u = 4
Output: 5
Explanation: The nearest node on the same level to the right of node 4 is node 5.


Example 2:
Input: root = [3,null,4,2], u = 2
Output: null
Explanation: There are no nodes to the right of 2.


Example 3:
Input: root = [1], u = 1
Output: null

Example 4:
Input: root = [3,4,2,null,null,null,1], u = 4
Output: 2

Constraints:
The number of nodes in the tree is in the range `[1, 105]`.

`1 <= Node.val <= 105`
All values in the tree are distinct.

`u` is a node in the binary tree rooted at `root`.

### Solution 
 To solve the problem of finding the nearest node to the right of a given node `u` in a binary tree, we can use a breadth-first search (BFS) traversal. This method allows us to explore each level of the tree and locate `u`, while also determining its position among its siblings (other nodes at the same level).

### Steps to Approach the Problem:

1. **BFS Traversal**: Utilize a queue to perform a level-order traversal of the tree, which processes nodes level by level.
  
2. **Identify the Level**: As we traverse, we keep track of the nodes at each level, allowing us to find the desired node `u` and check if there is a right sibling after `u`.

3. **Return the Right Node**: Once we locate `u`, we can check the next node in the current level's traversal to find the desired output. If no such node exists, we return `null`.

### Implementation:
Below is the Python code encapsulated in a class format suitable for direct use on LeetCode. The code defines a binary tree node, implements the BFS traversal, and handles the logic for finding the right neighbor.



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findNearestRightNode(self, root: TreeNode, u: TreeNode) -> TreeNode:
        # Initialize a queue for BFS
        queue = [(root, 0)]  # (node, level)
        target_level = None  # To store the level of node u
        
        while queue:
            level_size = len(queue)  # Nodes at the current level
            
            # Process all nodes at the current level
            for i in range(level_size):
                node, level = queue.pop(0)
                
                # Check if we've found node u
                if node == u:
                    target_level = level
                    # If u is the last node at this level, return None
                    if i == level_size - 1:
                        return None
                    return queue[i][0]  # The next node in queue is the answer
                
                # Add children to the queue
                if node.left:
                    queue.append((node.left, level + 1))
                if node.right:
                    queue.append((node.right, level + 1))
        
        return None  # This line is not expected to be reached; u is guaranteed to be in the tree.

```

### Explanation of the Code:

1. **TreeNode Class**: This class defines the structure of a binary tree node.

2. **Solution Class**: Contains the method `findNearestRightNode`.

3. **BFS Logic**:
   - We initialize a queue with the root node and its level.
   - As we process each level, we check if the current node is the target `u`.
   - If `u` is found and it is not the last node at that level, we return the next node in the queue.
   - If `u` is the last node, we return `None`.

### Complexity Analysis:
- **Time Complexity**: O(N), where N is the number of nodes in the binary tree. We may visit each node once.
- **Space Complexity**: O(W), where W is the maximum width of the tree. In the worst case, this can be up to O(N) for a degenerate tree.

This implementation efficiently finds the nearest right node for given `u` in the binary tree using BFS, adhering to LeetCode's requirements.

# 1609. Even Odd Tree

### Problem Description 
A binary tree is named Even-Odd if it meets the following conditions:
The root of the binary tree is at level index `0`, its children are at level index `1`, their children are at level index `2`, etc.

For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right).

For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right).

Given the `root` of a binary tree, return `true` if the binary tree is Even-Odd, otherwise return `false`.


Example 1:
Input: root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
Output: true
Explanation: The node values on each level are:
Level 0: [1]
Level 1: [10,4]
Level 2: [3,7,9]
Level 3: [12,8,6,2]
Since levels 0 and 2 are all odd and increasing, and levels 1 and 3 are all even and decreasing, the tree is Even-Odd.


Example 2:
Input: root = [5,4,2,3,3,7]
Output: false
Explanation: The node values on each level are:
Level 0: [5]
Level 1: [4,2]
Level 2: [3,3,7]
Node values in the level 2 must be in strictly increasing order, so the tree is not Even-Odd.


Example 3:
Input: root = [5,9,1,3,5,7]
Output: false
Explanation: Node values in the level 1 should be even integers.


Example 4:
Input: root = [1]
Output: true

Example 5:
Input: root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]
Output: true

Constraints:
The number of nodes in the tree is in the range `[1, 105]`.

`1 <= Node.val <= 106`

### Solution 
 To solve the problem of determining if a binary tree is Even-Odd, we will perform a level-order traversal using a queue. This will allow us to examine each level of the tree while keeping track of the index (or depth) we are at. 

The conditions we need to check for each level are:
1. For even-indexed levels, all node values must be odd and they must be in strictly increasing order.
2. For odd-indexed levels, all node values must be even and they must be in strictly decreasing order.

Here's a step-by-step breakdown of how we'll implement the solution:

### Steps:
1. **Level-Order Traversal**: We will use a queue to perform a level-order traversal of the binary tree.
2. **Track Levels**: At each level of the tree, we will:
   - Collect the values of the nodes.
   - Check if the values meet the conditions for even or odd levels.
   - Store the values in lists for validation.
3. **Validation**:
   - For even levels, ensure all values are odd and strictly increasing.
   - For odd levels, ensure all values are even and strictly decreasing.
4. **Return Result**: If all levels satisfy their respective conditions, return `true`; otherwise, return `false`.

### Python Code:
Let's implement this idea in Python:



```python
from collections import deque

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isEvenOddTree(self, root: TreeNode) -> bool:
        if not root:
            return False
        
        # Queue for level-order traversal
        queue = deque([root])
        level = 0
        
        while queue:
            level_size = len(queue)
            values = []
            
            for _ in range(level_size):
                node = queue.popleft()
                values.append(node.val)  # Collect values of the current level

                # Add child nodes to the queue for the next level
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            # Check conditions for the current level
            if level % 2 == 0:  # Even level
                if any(val % 2 == 0 for val in values):  # All should be odd
                    return False
                if not all(values[i] < values[i + 1] for i in range(len(values) - 1)):  # Strictly increasing
                    return False
            else:  # Odd level
                if any(val % 2 != 0 for val in values):  # All should be even
                    return False
                if not all(values[i] > values[i + 1] for i in range(len(values) - 1)):  # Strictly decreasing
                    return False
            
            level += 1  # Move to the next level
        
        return True  # All levels satisfy the even-odd conditions

```

### Explanation of the Code:
1. **TreeNode Class**: This defines the structure for a node in the binary tree.
2. **Solution Class**: This contains the `isEvenOddTree` method which determines if the tree is Even-Odd.
3. **Queue Initialization**: We initialize a deque with the root node for level-order traversal.
4. **Loop through Levels**:
   - Collect the node values at the current level.
   - Check the properties for even and odd levels using conditional statements.
5. **Return Value**: After checking all levels, if we pass all conditions, return `True`.

### Time Complexity:
The algorithm has a time complexity of O(N), where N is the number of nodes in the binary tree, since we visit each node exactly once.

### Space Complexity:
The space complexity is O(W), where W is the maximum width of the tree, which can go up to O(N) in the worst case if the tree is fully balanced. 

This solution is now formatted in a way that should work correctly if submitted to LeetCode!

# 1612. Check If Two Expression Trees are Equivalent

### Problem Description 
A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (variables), and internal nodes (nodes with two children) correspond to the operators. In this problem, we only consider the `'+'` operator (i.e. addition).

You are given the roots of two binary expression trees, `root1` and `root2`. Return `true` if the two binary expression trees are equivalent. Otherwise, return `false`.

Two binary expression trees are equivalent if they evaluate to the same value regardless of what the variables are set to.

Follow up: What will you change in your solution if the tree also supports the `'-'` operator (i.e. subtraction)?

Example 1:
Input: root1 = [x], root2 = [x]
Output: true

Example 2:
Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c]
Output: true
Explaination: `a + (b + c) == (b + c) + a`

Example 3:
Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d]
Output: false
Explaination: `a + (b + c) != (b + d) + a`

Constraints:
The number of nodes in both trees are equal, odd and, in the range `[1, 4999]`.

`Node.val` is `'+'` or a lower-case English letter.

It's guaranteed that the tree given is a valid binary expression tree.

### Solution 
 To determine whether two binary expression trees are equivalent, we can leverage the properties of the trees and how expression trees represent mathematical expressions. 

The key insight for this problem is that two expressions represented by binary trees are equivalent if rearranging their structure doesn't change their evaluated result. For instance, the addition operator is commutative, meaning that `a + b` is the same as `b + a`. Also, it's associative, so `a + (b + c)` is the same as `(a + b) + c`.

Given the above properties, we can approach the problem by following these steps:

1. **Check the structure and node values**: We will define a recursive function that will traverse both trees simultaneously.
2. **Sort the operands**: For each node that represents an operation (`'+'`), we can collect the values of its left and right children and sort them to ensure that their order does not affect equivalence.
3. **Compare Node Values**: If both left and right children (if they are operation nodes) yield the same sorted list of operands, then the trees are equivalent at that node.

Now, let's implement this in Python using a class structure to represent the tree nodes and the main function for checking equivalence.

Here is the implementation:



```python
# Definition for a binary expression tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def areEquivalent(self, root1: TreeNode, root2: TreeNode) -> bool:
        def serialize(node):
            if not node:
                return []
            if node.val != '+':  # If it's an operand, return its value as a single-element list
                return [node.val]
            # Recursively serialize left and right children and sort
            left_serialized = serialize(node.left)
            right_serialized = serialize(node.right)
            return sorted(left_serialized + right_serialized)
        
        return serialize(root1) == serialize(root2)

# Example usage:
# Assuming we have functions to construct the expression trees

```

### Explanation:
- **Tree Node Definition**: Each tree node is defined with a value `val`, a left child `left`, and a right child `right`.
- **Serialization Function**: The `serialize` function creates a list representation of the tree:
  - If the current node is `None`, it returns an empty list.
  - If the node is a leaf (operand), it returns a list containing just that operand.
  - If the node represents the `'+'` operator, it recursively gets the serialized lists from the left and right children, combines, and sorts them.
- **Equivalence Check**: Finally, we compare the serialized lists of both trees. If they are identical, the trees are equivalent.

### Follow-Up:
If the tree also supports the `'-'` operator, our solution remains effective, but we need to ensure that subtraction is treated accordingly since it is not commutative. In addition, we'll need to handle specific cases where the same operands may yield different results depending on their grouping. 

For example, `a - b` is different from `b - a`, thus modifying the serialization logic would be necessary to correctly handle these cases by keeping the structure intact and considering the direction of operations where subtraction is involved, possibly requiring a different approach or additional flags in our serialization logic to represent operator direction.

### Complexity:
The time complexity of this solution is `O(n log n)` due to the sorting process, where `n` is the number of nodes in the trees. The space complexity is `O(n)` for storing the serialized representations of the trees.

# 1628. Design an Expression Tree With Evaluate Function

### Problem Description 
Given the `postfix` tokens of an arithmetic expression, build and return the binary expression tree that represents this expression.

Postfix notation is a notation for writing arithmetic expressions in which the operands (numbers) appear before their operators. For example, the postfix tokens of the expression `4*(5-(7+2))` are represented in the array `postfix = ["4","5","7","2","+","-","*"]`.

The class `Node` is an interface you should use to implement the binary expression tree. The returned tree will be tested using the `evaluate` function, which is supposed to evaluate the tree's value. You should not remove the `Node` class; however, you can modify it as you wish, and you can define other classes to implement it if needed.

A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal nodes (nodes with two children) correspond to the operators `'+'` (addition), `'-'` (subtraction), `'*'` (multiplication), and `'/'` (division).

It's guaranteed that no subtree will yield a value that exceeds `109` in absolute value, and all the operations are valid (i.e., no division by zero).

Follow up: Could you design the expression tree such that it is more modular? For example, is your design able to support additional operators without making changes to your existing `evaluate` implementation?

Example 1:
Input: s = ["3","4","+","2","*","7","/"]
Output: 2
Explanation: this expression evaluates to the above binary tree with expression (`(3+4)*2)/7) = 14/7 = 2.`

Example 2:
Input: s = ["4","5","7","2","+","-","*"]
Output: -16
Explanation: this expression evaluates to the above binary tree with expression 4*(5-`(2+7)) = 4*(-4) = -16.`

Example 3:
Input: s = ["4","2","+","3","5","1","-","*","+"]
Output: 18

Example 4:
Input: s = ["100","200","+","2","/","5","*","7","+"]
Output: 757

Constraints:
`1 <= s.length < 100`
`s.length` is odd.

`s` consists of numbers and the characters `'+'`, `'-'`, `'*'`, and `'/'`.

If `s[i]` is a number, its integer representation is no more than `105`.

It is guaranteed that `s` is a valid expression.

The absolute value of the result and intermediate values will not exceed `109`.

It is guaranteed that no expression will include division by zero.

### Solution 
 To solve the problem of building a binary expression tree from postfix notation and evaluating it, we will use a stack-based approach. Here's a structured breakdown and implementation:

### Detailed Explanation

1. **Node Class**: We will define a `Node` class that represents each node in our binary expression tree. Each node will store a value (either an operator or operand) and references to its left and right children.

2. **Stack Structure**: We'll utilize a list as a stack to help us build the expression tree from the postfix tokens. The basic idea is:
   - For each token in the input list:
     - If the token is an operand (number), create a new node and push it onto the stack.
     - If the token is an operator (one of `+`, `-`, `*`, `/`), pop the top two nodes off the stack. These nodes will be the right and left children of a new node created for the operator. This new node is then pushed back onto the stack.

3. **Completion**: At the end of processing all tokens, the stack will contain only one node, which is the root of the expression tree.

4. **Evaluation**: We will also implement a method to evaluate the tree. This will be a recursive function that computes the value of each subtree based on the operator at the node.

5. **Modularity**: To support future extensions (like additional operators), we will define a base class method that can easily be overridden or extended to add new behaviors.

Now, let's implement the solution in Python.

### Python Code



```python
class Node:
    def __init__(self, value):
        # Initialize the node with a value and optional left/right children
        self.value = value
        self.left = None
        self.right = None

    def evaluate(self):
        """Evaluate the value of the binary expression tree recursively."""
        if self.left is None and self.right is None:
            return int(self.value)  # Base case: return integer value
        
        left_val = self.left.evaluate()   # Evaluate left subtree
        right_val = self.right.evaluate() # Evaluate right subtree
        
        if self.value == '+':
            return left_val + right_val
        elif self.value == '-':
            return left_val - right_val
        elif self.value == '*':
            return left_val * right_val
        elif self.value == '/':
            return left_val // right_val  # Use integer division as specified

class Solution:
    def buildTree(self, postfix):
        """Build a binary expression tree from postfix notation."""
        stack = []
        
        for token in postfix:
            if token in "+-*/":
                # It is an operator; pop two nodes from the stack
                right = stack.pop()
                left = stack.pop()
                # Create a new node for the operator
                node = Node(token)
                # Link the left and right children
                node.left = left
                node.right = right
                # Push the new node onto the stack
                stack.append(node)
            else:
                # It is a number; create a new leaf node
                stack.append(Node(token))
        
        # The stack should now contain one element, the root of the expression tree
        return stack.pop()

# Example Usage
solution = Solution()
tree = solution.buildTree(["3","4","+","2","*","7","/"])
print(tree.evaluate())  # Output: 2

tree = solution.buildTree(["4","5","7","2","+","-","*"])
print(tree.evaluate())  # Output: -16

tree = solution.buildTree(["4","2","+","3","5","1","-","*","+"])
print(tree.evaluate())  # Output: 18

tree = solution.buildTree(["100","200","+","2","/","5","*","7","+"])
print(tree.evaluate())  # Output: 757

```

### Summary

This solution effectively converts postfix expressions into binary expression trees and evaluates them. The design is modular enough to allow for additional operators by simply expanding the `evaluate` method. This maintains the requirement of flexibility without altering the existing structure. Our use of a stack simplifies the management of nodes during tree construction, ensuring clarity and efficiency.

# 1644. Lowest Common Ancestor of a Binary Tree II

### Problem Description 
Given the `root` of a binary tree, return the lowest common ancestor (LCA) of two given nodes, `p` and `q`. If either node `p` or `q` does not exist in the tree, return `null`. All values of the nodes in the tree are unique.

According to the definition of LCA on Wikipedia: "The lowest common ancestor of two nodes `p` and `q` in a binary tree `T` is the lowest node that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself)". A descendant of a node `x` is a node `y` that is on the path from node `x` to some leaf node.


Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.


Example 2:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5. A node can be a descendant of itself according to the definition of LCA.


Example 3:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 10
Output: null
Explanation: Node 10 does not exist in the tree, so return null.


Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`-109 <= Node.val <= 109`
All `Node.val` are unique.

`p != q`
Follow up: Can you find the LCA traversing the tree, without checking nodes existence?

### Solution 
 To solve the problem of finding the Lowest Common Ancestor (LCA) of two nodes in a binary tree, we will use a recursive depth-first search (DFS) algorithm. The goal is to traverse the tree and find both nodes `p` and `q`. Once we find both nodes, we will backtrack to identify their lowest common ancestor.

### Steps to Solve the Problem:
1. **Define the TreeNode class**: A standard structure for representing each node in the binary tree with `val`, `left`, and `right`.
2. **Implement the LCA Function**: The function will check if the current node matches `p` or `q`, and recursively search the left and right subtrees to find the nodes.
3. **Determine the LCA**: As we backtrack through the recursion, we will:
   - Return the current node if it matches `p` or `q`.
   - If we find both nodes in the left and right subtrees of a node, that node is the LCA.
4. **Check for existence**: If one of the nodes does not exist in the tree, we should return `null`.

Here's the Python code that adheres to the LeetCode structure:



```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        # Helper function to traverse the tree
        def helper(node):
            # Base case: if the current node is None, return None
            if not node:
                return None
            
            # If we find either p or q, we return the node
            if node == p or node == q:
                return node
            
            # Recur for left and right subtrees
            left = helper(node.left)
            right = helper(node.right)
            
            # If both left and right are not None, it means we found p and q in both subtrees
            if left and right:
                return node
            
            # Otherwise, check which side is not None (which means we found one of p or q)
            return left if left is not None else right
        
        # Call the helper function
        lca = helper(root)
        
        # Check if both nodes exist in the tree
        if self.exists(root, p) and self.exists(root, q):
            return lca
        else:
            return None

    # Helper function to check if a node exists in the tree
    def exists(self, root: TreeNode, node: TreeNode) -> bool:
        if not root:
            return False
        if root == node:
            return True
        return self.exists(root.left, node) or self.exists(root.right, node)

```

### Explanation of the Code:
1. **TreeNode Class**: This is a simple class for each node consisting of a value and references for left and right children.
2. **lowestCommonAncestor Method**:
   - This method uses a helper function to traverse the binary tree.
   - The helper function checks the base case of if the current node is `None`. If it equals `p` or `q`, it returns that node.
   - It explores both left and right children recursively.
   - If both children return non-`None` values, it means both nodes were found and the current node is their LCA.
3. **Exists Method**: This method checks if a specific node exists in the tree, ensuring both `p` and `q` exist before confirming the LCA.
4. **Return**: The final return checks if both nodes exist; if they don't, it returns `None`.

### Complexity:
- **Time Complexity**: O(N), where N is the number of nodes in the binary tree due to the DFS traversal.
- **Space Complexity**: O(H), where H is the height of the tree. This accounts for the function call stack in case of recursive calls.

# 1650. Lowest Common Ancestor of a Binary Tree III

### Problem Description 
Given two nodes of a binary tree `p` and `q`, return their lowest common ancestor (LCA).

Each node will have a reference to its parent node. The definition for `Node` is below:
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
}
According to the definition of LCA on Wikipedia: "The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself)."

Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.


Example 2:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.


Example 3:
Input: root = [1,2], p = 1, q = 2
Output: 1

Constraints:
The number of nodes in the tree is in the range `[2, 105]`.

`-109 <= Node.val <= 109`
All `Node.val` are unique.

`p != q`
`p` and `q` exist in the tree.

### Solution 
 To solve the problem of finding the Lowest Common Ancestor (LCA) in a binary tree where each node has a reference to its parent, we can utilize a hash set to track the ancestors of one of the nodes (either `p` or `q`) and then traverse the other node's ancestors until we find the first common ancestor.

### Step-by-Step Explanation

1. **Data Structure**: We define the structure of a `Node` class that has attributes for its value, left and right children, and its parent.
  
2. **Trace Ancestors**: 
   - Start with one of the nodes, say `p`, and move up to the root of the tree, adding each ancestor to a set. This will give us all ancestors of `p`.
  
3. **Find LCA**: 
   - Traverse from node `q` up to the root. For each ancestor of `q`, check if it is also in the set of ancestors of `p`. The first common ancestor we find is the LCA.

4. **Time Complexity**: The time complexity of this approach is O(H) where H is the height of the tree, since we potentially traverse both paths up to the root. The space complexity is also O(H) due to the storage of ancestors in a set.

Hereâ€™s how this can be implemented in Python using the LeetCode format:



```python
class Node:
    def __init__(self, val, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent

class Solution:
    def lowestCommonAncestor(self, p: Node, q: Node) -> Node:
        # Step 1: Track all ancestors of p
        ancestors = set()
        
        # Traverse up from p to root, adding all ancestors to the set
        while p:
            ancestors.add(p)
            p = p.parent
        
        # Step 2: Traverse up from q until we find an ancestor that is in the set
        while q:
            if q in ancestors:
                return q
            q = q.parent
        
        return None  # In case there is no common ancestor, though the problem guarantees there will be.

```

### Explanation of the Code
- We first define the `Node` class with its constructor to initialize its value, left and right children, and parent.
- The `Solution` class contains the `lowestCommonAncestor` method which takes two nodes `p` and `q`.
- We first build a set of all ancestors of `p`.
- We then check each ancestor of `q` and return the first one found in the ancestors set.
- If we exhaust the while loop without finding a common ancestor (which should not happen per problem constraints), we return `None`.

### Example Usage
Assuming you have a binary tree set up, you can utilize the solution as follows:



```python
# Example usage
root = Node(3)
node5 = Node(5, parent=root)
node1 = Node(1, parent=root)
root.left = node5
root.right = node1
node6 = Node(6, parent=node5)
node2 = Node(2, parent=node5)
node5.left = node6
node5.right = node2

# Nodes 5 and 1
sol = Solution()
lca = sol.lowestCommonAncestor(node5, node1)
print(lca.val)  # Should output 3

```

This code can now be run directly on the LeetCode platform, ensuring compliance with their coding conventions and requirements.

