# 974. Subarray Sums Divisible by K

### Problem Description 
Given an array `A` of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by `K`.


Example 1:
Input: A = [4,5,0,-2,-3,1], K = 5
Output: 7
Explanation: There are 7 subarrays with a sum divisible by K = 5:
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
Note:
`1 <= A.length <= 30000`
`-10000 <= A[i] <= 10000`
`2 <= K <= 10000`

### Solution 
 We can use a prefix sum technique along with a dictionary to tackle this problem efficiently. The key idea is based on the fact that if the sum of a subarray from indices `i` to `j` is divisible by `K`, then the difference between prefix sums up to `j` and `i-1` is divisible by `K`. To put it differently, `(prefixSum[j] - prefixSum[i-1]) % K == 0`, which can also be stated as `prefixSum[j] % K == prefixSum[i-1] % K`.

To solve the problem:
1. Calculate the prefix sum as we iterate through the array.
2. At each step, calculate the modulo `K` of this prefix sum.
3. Use a hash map (dictionary) to keep track of how many times each modulo value has occurred so far.
4. Upon encountering a new prefix sum modulo value, if the same value occurred before, it means there are subarrays ending at the current index which have a sum divisible by `K`.

Let's implement the solution:



```python
class Solution:
    def subarraysDivByK(self, A, K):
        count_modulo = {0: 1}  # Base case: there is one way to have a zero sum modulo K (by not including any elements)
        prefix_sum = 0
        result = 0

        for num in A:
            # Add the current number to the prefix sum
            prefix_sum += num
            # We use modulo K, but we need to correct negative values
            mod_value = prefix_sum % K
            if mod_value < 0:
                mod_value += K

            # If this mod_value has been seen before, it means there are subarrays ending here with sum divisible by K
            if mod_value in count_modulo:
                result += count_modulo[mod_value]
            
            # Update the count of this mod_value in the map
            if mod_value in count_modulo:
                count_modulo[mod_value] += 1
            else:
                count_modulo[mod_value] = 1

        return result

# This class can be added to a Python file and run as a submission on LeetCode platform.

```

Details of the code:
- We initialize a dictionary `count_modulo` with the key `0` set to `1` to handle the count of subarrays which exactly equal some `t * K`.
- `prefix_sum` keeps the sum including the current element.
- In cases where the `prefix_sum % K` turns out negative, we correct it (`mod_value += K`).
- At each step, if `mod_value` exists in `count_modulo`, it increments the `result` by the count stored, since it represents matching subarrays ending at the current element.
- Finally, we use either a `get` function or a conditional to manage counts in `count_modulo`.

This approach is efficient with a time complexity of `O(n)` and a space complexity of `O(K)`, where `n` is the length of the array and `K` is the divisor.

# 977. Squares of a Sorted Array

### Problem Description 
Given an integer array `nums` sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.


Example 1:
Input: nums = [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Explanation: After squaring, the array becomes [16,1,0,9,100].

After sorting, it becomes [0,1,9,16,100].


Example 2:
Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]

Constraints:
`1 <= nums.length <= 104`
`-104 <= nums[i] <= 104`
`nums` is sorted in non-decreasing order.

Follow up: Squaring each element and sorting the new array is very trivial, could you find an `O(n)` solution using a different approach?

### Solution 
 Below is a Python code that solves the problem efficiently in O(n) time complexity. The key observation here is that the array is already sorted in non-decreasing order, but the squared values might not be due to negative numbers. When a number is squared, its sign does not affect the result, but its order might require rethinking.

The idea is to use two pointers to handle negatives and non-negatives separately since the largest squared values could either be at the start or at the end of the original sorted list depending on the magnitudes of negatives and positives. By comparing these, we can construct a sorted array of squared numbers directly without needing an extra sort operation.



```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [0] * n
        left = 0
        right = n - 1
        position = n - 1    # We start filling from the end of the result array
        
        while left <= right:
            left_square = nums[left] ** 2
            right_square = nums[right] ** 2
            if left_square > right_square:
                result[position] = left_square
                left += 1
            else:
                result[position] = right_square
                right -= 1
            position -= 1
        
        return result

# Example usage:
# sol = Solution()
# print(sol.sortedSquares([-4,-1,0,3,10]))  # Output: [0,1,9,16,100]
# print(sol.sortedSquares([-7,-3,2,3,11]))  # Output: [4,9,9,49,121]

```

Detailed explanation of the algorithm:
1. The algorithm uses two pointers: `left` initialized at the beginning of the array and `right` initialized at the end.
2. An array `result` is created to hold the sorted squares with the same length as `nums`.
3. The position in the `result` array is filled from the end going backwards (`position` variable initialized to the last index `n-1`).
4. Iterate until the `left` pointer is greater than the `right` pointer.
   - Calculate the square of the values at the `left` and `right` pointers.
   - Compare these squares:
     - Place the larger square at the current `position` in `result` and move the pointer that had the larger square value (to cover all elements properly).
   - Decrease `position` by one.
5. Once all positions are filled, return the `result` array.

This approach handles all squared values directly in their correct order, avoiding the need for sorting after the squares are calculated, thus achieving an O(n) time complexity solution.

# 978. Longest Turbulent Subarray

### Problem Description 
Given an integer array `arr`, return the length of a maximum size turbulent subarray of `arr`.

A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.

More formally, a subarray `[arr[i], arr[i + 1], ..., arr[j]]` of `arr` is said to be turbulent if and only if:
For `i <= k < j`:
	
`arr[k] > arr[k + 1]` when `k` is odd, and
`arr[k] < arr[k + 1]` when `k` is even.

Or, for `i <= k < j`:
	
`arr[k] > arr[k + 1]` when `k` is even, and
`arr[k] < arr[k + 1]` when `k` is odd.


Example 1:
Input: arr = [9,4,2,10,7,8,8,1,9]
Output: 5
Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]

Example 2:
Input: arr = [4,8,12,16]
Output: 2

Example 3:
Input: arr = [100]
Output: 1

Constraints:
`1 <= arr.length <= 4 * 104`
`0 <= arr[i] <= 109`

### Solution 
 Here is a Python solution using a sliding window approach to find the length of the maximum turbulent subarray. Follow the explanation and format below which will allow you to run this solution on LeetCode:



```python
class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -> int:
        if len(arr) < 2:
            return len(arr)
        
        max_len = 1
        left = 0
        
        # Initialize the flag to handle the pattern check. None indicates start of a possible turbulence
        flag = None
        
        for right in range(1, len(arr)):
            if arr[right] > arr[right-1]:
                current_flag = 1
            elif arr[right] < arr[right-1]:
                current_flag = -1
            else:
                current_flag = 0
                
            if current_flag == 0:
                # Reset window since equal elements can't be part of turbulent subarray
                left = right
            elif flag is None or current_flag != flag:
                # Continue expanding the window
                flag = current_flag
            else:
                # A pattern was broken, set a new start for potential turbulence
                left = right - 1
                flag = current_flag
            
            # Calculate the max length by considering the current window size
            max_len = max(max_len, right - left + 1)
        
        return max_len

```

### Explanation:
- **Initialization**:
  - `max_len` is initialized to 1 as the minimum length of a subarray is 1 (even a single element is a subarray).
  - `left` serves as the start of a potential turbulent subarray, initialized to 0.
  - `flag` indicates the direction of the previous comparison (`1` for >, `-1` for <, `0` for ==).

- **Main Loop**:
  - Loop through the array beginning from the second element (index 1).
  - Compare each element with its previous element:
    - Set `current_flag` based on the comparison result.
    - If `current_flag` is 0 (elements are equal), reset the start because turbulence requires changing relations.
    - If `current_flag` differs from `flag` or if it's the start of potential turbulence (`flag` is None), it simply continues the subarray.
    - If `current_flag` matches `flag`, a turbulence pattern broke; hence update the start of the new subarray (`left`).

- **Updating Max Length**:
  - At every iteration, consider the length of subarray from `left` to current `right` and update `max_len`.

- This approach has a time complexity of *O(n)* where *n* is the number of elements in the input array `arr`. This is because it processes each element once. The space complexity is *O(1)*, using only constant space beyond the input size. 

Thus, the given solution should handle even the largest constraints effectively.

# 985. Sum of Even Numbers After Queries

### Problem Description 
We have an array `A` of integers, and an array `queries` of queries.

For the `i`-th query `val = queries[i][0], index = queries[i][1]`, we add val to `A[index]`.  Then, the answer to the `i`-th query is the sum of the even values of `A`.

(Here, the given `index = queries[i][1]` is a 0-based index, and each query permanently modifies the array `A`.)
Return the answer to all queries.  Your `answer` array should have `answer[i]` as the answer to the `i`-th query.


Example 1:
Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
Output: [8,6,2,4]
Explanation: 
At the beginning, the array is [1,2,3,4].

After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.

After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.

After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.

After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.

Note:
`1 <= A.length <= 10000`
`-10000 <= A[i] <= 10000`
`1 <= queries.length <= 10000`
`-10000 <= queries[i][0] <= 10000`
`0 <= queries[i][1] < A.length`

### Solution 
 To solve this problem efficiently, we need to deal with the updates and computation of the sum of even numbers after each modification. Here's a clear and effective approach for solving the problem:

1. **Initial Setup**: Calculate the sum of the even numbers from the original array `A`. This sum helps us avoid recalculating the even sum from scratch after every update.

2. **Processing Queries**:
    - For each query, extract the value to be added (`val`) and the index to be updated (`index`).
    - Before updating `A[index]`, check if `A[index]` is even:
        - If yes, subtract it from the current sum of even numbers because the update might turn it odd.
    - Update `A[index]` by adding `val` to it.
    - After updating `A[index]`, check if `A[index]` is now even:
        - If yes, add it back to the current sum of even numbers.
    - Append the current sum of even numbers to the results list.

3. **Return the results** of all queries as required.

This solution is efficient because we maintain and update the sum of even numbers dynamically based on the operations provided in `queries`, ensuring we don't unnecessarily recalculate the sum from scratch. Here's the actual Python code implementing this approach:



```python
class Solution:
    def sumEvenAfterQueries(self, A: List[int], queries: List[List[int]]) -> List[int]:
        # Calculate initial sum of even numbers
        sum_even = sum(x for x in A if x % 2 == 0)
        
        result = []
        for val, index in queries:
            # If the current element is even, subtract it from sum_even before changing
            if A[index] % 2 == 0:
                sum_even -= A[index]
                
            # Update the element
            A[index] += val
            
            # If the updated element is even, add it to sum_even
            if A[index] % 2 == 0:
                sum_even += A[index]
                
            # Append the current sum of even numbers to the result
            result.append(sum_even)
        
        return result

```

This code should directly run on the LeetCode system as it uses their format, including the use of typing for input lists (`List[int]`), and matches the method signature they would expect for Python solutions. Furthermore, this approach ensures a complexity that is linear with respect to the number of queries and the initial sum computation, making it efficient enough for the problem constraints.

# 989. Add to Array-Form of Integer

### Problem Description 
The array-form of an integer `num` is an array representing its digits in left to right order.

For example, for `num = 1321`, the array form is `[1,3,2,1]`.

Given `num`, the array-form of an integer, and an integer `k`, return the array-form of the integer `num + k`.


Example 1:
Input: num = [1,2,0,0], k = 34
Output: [1,2,3,4]
Explanation: 1200 + 34 = 1234

Example 2:
Input: num = [2,7,4], k = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455

Example 3:
Input: num = [2,1,5], k = 806
Output: [1,0,2,1]
Explanation: 215 + 806 = 1021

Example 4:
Input: num = [9,9,9,9,9,9,9,9,9,9], k = 1
Output: [1,0,0,0,0,0,0,0,0,0,0]
Explanation: 9999999999 + 1 = 10000000000

Constraints:
`1 <= num.length <= 104`
`0 <= num[i] <= 9`
`num` does not contain any leading zeros except for the zero itself.

`1 <= k <= 104`

### Solution 
 Here's a Python solution for the provided problem statement, formatted in a way suitable for submission on LeetCode. The solution involves converting the list of digits back to an integer, adding the integer `k`, and then converting the sum back into its array form.



```python
class Solution:
    def addToArrayForm(self, num: List[int], k: int) -> List[int]:
        # Convert the num list back to an integer
        num_as_int = 0
        for digit in num:
            num_as_int = num_as_int * 10 + digit
        
        # Add k to this integer
        total = num_as_int + k
        
        # Convert the resulting integer back to a list of digits
        return [int(x) for x in str(total)]

```

### Explanation:

1. **Integer Conversion**: The digits given in the list `num` are input as items where each item represents a decimal digit. First, we convert this list back into a single integer (`num_as_int`). This is done using a loop that multiplies the accumulating total by 10 and adds the next digit, thereby shifting previous digits left by one decimal place and adding the new digit at the unit place.

2. **Addition Operation**: Once we have the integer representation of `num`, we simply add `k` to it (`total = num_as_int + k`).

3. **Array Conversion**: Finally, to get the result in the required array form, we convert this total sum back into its string representation to easily iterate over each character (corresponding to a digit), converting each character back to an integer and forming a list from these integers. 

This approach makes use of Python's ability to handle arbitrarily-large integers efficiently and Python's list and string manipulations to perform conversions.

# 999. Available Captures for Rook

### Problem Description 
On an `8 x 8` chessboard, there is exactly one white rook `'R'` and some number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.

When the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered attacking a pawn if the rook can capture the pawn on the rook's turn. The number of available captures for the white rook is the number of pawns that the rook is attacking.

Return the number of available captures for the white rook.


Example 1:
Input: board = [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
Output: 3
Explanation: In this example, the rook is attacking all the pawns.


Example 2:
Input: board = [[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
Output: 0
Explanation: The bishops are blocking the rook from attacking any of the pawns.


Example 3:
Input: board = [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
Output: 3
Explanation: The rook is attacking the pawns at positions b5, d6, and f5.


Constraints:
`board.length == 8`
`board[i].length == 8`
`board[i][j]` is either `'R'`, `'.'`, `'B'`, or `'p'`
There is exactly one cell with `board[i][j] == 'R'`

### Solution 
 To solve the chessboard problem mentioned above, the approach involves finding the position of the rook and then checking all four cardinal directions (north, east, south, west) to determine if there are any pawns ('p') the rook can attack. We continue in each direction until we are blocked by the edge of the board, a bishop ('B'), or after capturing a pawn. 

We can implement this solution in Python and it's structurally formatted for use on platforms like LeetCode:



```python
class Solution:
    def numRookCaptures(self, board: List[List[str]]) -> int:
        # First, locate the rook ('R')
        rook_position = (-1, -1)
        for i in range(8):
            for j in range(8):
                if board[i][j] == 'R':
                    rook_position = (i, j)
                    break
            if rook_position[0] != -1:
                break
        
        captures = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # east, south, west, north
        
        # Now, for each direction, check if the rook can capture a pawn
        for dx, dy in directions:
            x, y = rook_position
            while True:
                x += dx
                y += dy
                if x < 0 or x >= 8 or y < 0 or y >= 8 or board[x][y] == 'B':
                    break
                if board[x][y] == 'p':
                    captures += 1
                    break

        return captures

# Example usage:
if __name__ == "__main__":
    board1 = [[".",".",".",".",".",".",".","."],
              [".",".",".","p",".",".",".","."],
              [".",".",".","R",".",".",".","p"],
              [".",".",".",".",".",".",".","."],
              [".",".",".",".",".",".",".","."],
              [".",".",".","p",".",".",".","."],
              [".",".",".",".",".",".",".","."],
              [".",".",".",".",".",".",".","."]]
    board2 = [[".",".",".",".",".",".",".","."],
              [".","p","p","p","p","p",".","."],
              [".","p","p","B","p","p",".","."],
              [".","p","B","R","B","p",".","."],
              [".","p","p","B","p","p",".","."],
              [".","p","p","p","p","p",".","."],
              [".",".",".",".",".",".",".","."],
              [".",".",".",".",".",".",".","."]]
    board3 = [[".",".",".",".",".",".",".","."],
              [".",".",".","p",".",".",".","."],
              [".",".",".","p",".",".",".","."],
              ["p","p",".","R",".","p","B","."],
              [".",".",".",".",".",".",".","."],
              [".",".",".","B",".",".",".","."],
              [".",".",".","p",".",".",".","."],
              [".",".",".",".",".",".",".","."]]
    
    sol = Solution()
    print(sol.numRookCaptures(board1))  # Output: 3
    print(sol.numRookCaptures(board2))  # Output: 0
    print(sol.numRookCaptures(board3))  # Output: 3

```

This code defines a class `Solution` with a method `numRookCaptures` that takes the chessboard (2D list) as an argument and returns the number of pawns the rook can capture based on the rules defined in the problem statement. The logic involves locating the rook, then checking each direction one after another, stopping the search upon encountering a bishop or the edge of the board or after capturing a pawn. The code additionally includes some example usage which demonstrates applying the function to different board configurations.

# 1002. Find Common Characters

### Problem Description 
Given an array `A` of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.

You may return the answer in any order.


Example 1:
Input: ["bella","label","roller"]
Output: ["e","l","l"]

Example 2:
Input: ["cool","lock","cook"]
Output: ["c","o"]
Note:
`1 <= A.length <= 100`
`1 <= A[i].length <= 100`
`A[i][j]` is a lowercase letter

### Solution 
 To solve this problem, we can follow these steps:

1. Initialize a counting map (`common_count`) with very high values for each unique character between 'a' and 'z'. This ensures all possible characters are considered, and we set high initial count values as they will be minimized with counts of actual string characters.

2. Traverse each word in the list and construct a frequency count for that word (`current_count`). This will tell us how frequently each character appears in the current word.

3. Update `common_count` by comparing with `current_count` for each character. For each character, update the `common_count` with the minimum count found so far across all strings processed. This ensures that for each character, it's counted in the output only as many times as it appears in every string.

4. Finally, based on the `common_count`, create the result characters. For each character that has a count greater than 0, add it to the result list the number of times indicated by its count.

Here's the Python code that can be executed on LeetCode:



```python
from typing import List
from collections import Counter

class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        if not A:
            return []
        
        # Initialize dictionary with high values to use min function later
        common_count = {chr(i): float('inf') for i in range(ord('a'), ord('z') + 1)}
        
        # Update count for each character in each string
        for word in A:
            current_count = Counter(word)
            for char in common_count:
                if char in current_count:
                    # Update common count to the minimum appearance across all strings
                    common_count[char] = min(common_count[char], current_count[char])
                else:
                    # If the character doesn't exist in the current word
                    common_count[char] = 0
        
        # Construct the result list based on common counts
        result = []
        for char, count in common_count.items():
            if count > 0:
                result.extend([char] * count)
        
        return result

# Example usage
sol = Solution()
print(sol.commonChars(["bella", "label", "roller"]))  # Output: ['e', 'l', 'l']
print(sol.commonChars(["cool", "lock", "cook"]))  # Output: ['c', 'o']

```

This approach efficiently calculates the intersection of character counts across multiple strings by consistently updating a common count map and pays special attention to the character frequency in each word to ensure duplicated characters are handled correctly. It runs in O(N*M) time complexity where N is the number of strings and M is the average length of these strings.

# 1007. Minimum Domino Rotations For Equal Row

### Problem Description 
In a row of dominoes, `A[i]` and `B[i]` represent the top and bottom halves of the `ith` domino.  (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)
We may rotate the `ith` domino, so that `A[i]` and `B[i]` swap values.

Return the minimum number of rotations so that all the values in `A` are the same, or all the values in `B` are the same.

If it cannot be done, return `-1`.


Example 1:
Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]
Output: 2
Explanation: 
The first figure represents the dominoes as given by A and B: before we do any rotations.

If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.


Example 2:
Input: A = [3,5,1,2,3], B = [3,6,3,3,4]
Output: -1
Explanation: 
In this case, it is not possible to rotate the dominoes to make one row of values equal.


Constraints:
`2 <= A.length == B.length <= 2 * 104`
`1 <= A[i], B[i] <= 6`

### Solution 
 Here's a Python solution that follows the LeetCode format and can be run directly on the website. The solution leverages the characteristics of the problem constraints, focusing on manipulating and counting items with values between 1 and 6.

The solution involves checking for each of the possible values (1 through 6) if all the tiles can be turned to either show that value on the top (`A`) or on the bottom (`B`). It does this efficiently by determining how many tiles are already showing the desired number on the top or bottom, and how many can potentially be rotated to show it.



```python
class Solution:
    def minDominoRotations(self, A: List[int], B: List[int]) -> int:
        def check(x):
            """ Return min number of swaps if one side shows all `x`. Otherwise, return -1. """
            rotations_a = rotations_b = 0  # Counts the min swaps needed to make all values x.
            for i in range(len(A)):
                if A[i] != x and B[i] != x:
                    return -1  # if neither match, it's not possible to make all tiles show x.
                elif A[i] != x:
                    rotations_a += 1  # A needs to be swapped to show x.
                elif B[i] != x:
                    rotations_b += 1  # B needs to be swapped to show x.
            # Min number of swaps to make all values in a row the same.
            return min(rotations_a, rotations_b)
        
        # Try to make all values the same for each potential value from 1 to 6.
        # We only need to check for A[0] or B[0], because at least one must be present
        # in each position if a solution exists.
        for x in [A[0], B[0]]:
            result = check(x)
            if result != -1:
                return result
        
        return -1  # If no single value x could make all dominoes have the same value on one side.

# Example usage:
# sol = Solution()
# print(sol.minDominoRotations([2,1,2,4,2,2], [5,2,6,2,3,2]))  # Output: 2

```

### Explanation:

1. **Function `check(x)`:** This helper function determines the minimum number of rotations required to make all `A` or all `B` show the value `x`. It returns `-1` if it's not possible.
2. **Main Logic:**
   - The function tries to align all dominos to show either the value of the first domino top (`A[0]`) or first domino bottom (`B[0]`) across all dominoes. This is because for a viable solution, at least one of these numbers has to be the common face for all dominos if no switch occurs.
   - It uses the `check` function on those initial numbers and, if it finds a solution for either, returns the minimum rotations required.
   - If neither work, the function returns `-1`.

This approach focuses on each number possibility efficiently, as only two numbers are actually checked in the worst case scenario (compared to checking all numbers from 1-6), because if a solution is possible, one of the first two dominos must be part of it.

# 1010. Pairs of Songs With Total Durations Divisible by 60

### Problem Description 
You are given a list of songs where the ith song has a duration of `time[i]` seconds.

Return the number of pairs of songs for which their total duration in seconds is divisible by `60`. Formally, we want the number of indices `i`, `j` such that `i < j` with `(time[i] + time[j]) % 60 == 0`.


Example 1:
Input: time = [30,20,150,100,40]
Output: 3
Explanation: Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60

Example 2:
Input: time = [60,60,60]
Output: 3
Explanation: All three pairs have a total duration of 120, which is divisible by 60.


Constraints:
`1 <= time.length <= 6 * 104`
`1 <= time[i] <= 500`

### Solution 
 To solve this problem efficiently, you can use a dictionary to count occurrences of each song duration modulo 60. The key observation is that if `time[i] % 60 + time[j] % 60 == 60` or equals `0` (if both are exactly divisible by 60), then the pair `(i, j)` is valid. 

Hereâ€™s the optimized approach, step by step:

1. **Modulo Count Mapping**: For each song, calculate its duration modulo 60 and store the count of each remainder in a dictionary. This helps in identifying complements directly without double iteration.
   
2. **Calculating Pairs**: For each remainder:
   - If the remainder is `0`, then any pair amongst its count can be paired together. Calculate using combination formula: `count * (count - 1) / 2`.
   - For remainders not equal to `0`, find its complement that would add up to `60`. For example, remainder `20` will need `40` to make their sum divisible by `60`. If we have counted both remainders, the number of such valid pairs is product of their counts.

3. **Avoid Double Counting**: As pairs are symmetric (pairing `i` with `j` is the same as `j` with `i`), ensure each is counted once.

This approach runs in O(n) time, since we pass through the list a few times independently of its size, which is efficient given the constraints.

Now, let's write the solution code adhering to the guidelines mentioned:



```python
class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        remainders = [0] * 60
        count = 0
        
        # Count each time's remainder when divided by 60
        for t in time:
            remainder = t % 60
            remainders[remainder] += 1
        
        # Calculate pairs
        # Special case for remainder 0
        count += (remainders[0] * (remainders[0] - 1)) // 2
        
        # Pairs from remainder 1 to 29 (30 is handled separately as it pairs with itself)
        for i in range(1, 30):
            count += remainders[i] * remainders[60 - i]
        
        # Special case for remainder 30 (as 30 + 30 = 60)
        count += (remainders[30] * (remainders[30] - 1)) // 2
        
        return count

# Example usage:
# sol = Solution()
# print(sol.numPairsDivisibleBy60([30,20,150,100,40]))  # Output: 3
# print(sol.numPairsDivisibleBy60([60,60,60]))          # Output: 3

```

This solution provides an effective and direct way to count the desired song pairs for the given problem.

# 1011. Capacity To Ship Packages Within D Days

### Problem Description 
A conveyor belt has packages that must be shipped from one port to another within `D` days.

The ith package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `D` days.


Example 1:
Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5
Output: 15
Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10
Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.


Example 2:
Input: weights = [3,2,2,4,1,4], D = 3
Output: 6
Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:
1st day: 3, 2
2nd day: 2, 4
3rd day: 1, 4

Example 3:
Input: weights = [1,2,3,1,1], D = 4
Output: 3
Explanation:
1st day: 1
2nd day: 2
3rd day: 3
4th day: 1, 1

Constraints:
`1 <= D <= weights.length <= 5 * 104`
`1 <= weights[i] <= 500`

### Solution 
 The problem can be solved using the binary search technique on the capacity of the ship. The core idea is to define a binary search between a minimum and maximum possible ship capacity and using a helper function to check whether a given capacity allows for shipping all packages within `D` days.

Constraints:
1. We must respect the order of packages, i.e., packages must be loaded as listed without reordering.
2. We should try to find the minimum capacity that enables all the packages to be shipped in 'D' or fewer days.

Steps to solve:
1. **Range Setting for Binary Search**:
   - Lower limit (`left`): This should be at least the weight of the heaviest package because the ship must be able to carry the heaviest package. Thus, `left = max(weights)`.
   - Upper limit (`right`): This can be set as the sum of all weights since a ship with that capacity can take all weights in one go. Thus, `right = sum(weights)`.

2. **Binary Search**:
   - Calculate the mid-value (`mid`) of the current `left` and `right` which represents a guess of the ship's capacity.
   - Check if using `mid` as capacity allows all packages to be shipped within `D` days. This is done using a helper function.
   - Adjust the `left` and `right` bounds of the binary search based on whether the guessed capacity was sufficient or not.

3. **Helper Function (`canShipInDDays`)**:
   - Simulate the shipping process given a capacity and count the days required.
   - If the total days exceed `D`, return False; otherwise, True.

This algorithm efficiently zones in on the smallest capacity needed to ship all the packages in `D` or fewer days. Now, let's implement this in code.



```python
class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        # Helper function to determine if a given capacity can ship all packages within D days
        def canShipInDDays(capacity):
            current_weight = 0
            days_needed = 1  # Start counting days, at least one day is always needed
            for weight in weights:
                if current_weight + weight > capacity:
                    days_needed += 1
                    current_weight = weight
                    if days_needed > D:  # Early exit if days exceed D
                        return False
                else:
                    current_weight += weight
            return True
        
        # Start of the binary search method
        left, right = max(weights), sum(weights)
        
        while left < right:
            mid = (left + right) // 2
            if canShipInDDays(mid):
                right = mid  # Try a smaller capacity
            else:
                left = mid + 1  # Increase capacity

        return left

# As required by LeetCode, you would typically not include the imports explicitly in the solution pane
# from typing import List  # This should be implicitly understood in the LeetCode environment

```

This solution correctly implements the binary search algorithm to find the minimal ship capacity required to ship all packages within `D` days while adhering to weights' order constraints.

# 1013. Partition Array Into Three Parts With Equal Sum

### Problem Description 
Given an array of integers `arr`, return `true` if we can partition the array into three non-empty parts with equal sums.

Formally, we can partition the array if we can find indexes `i + 1 < j` with `(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])`

Example 1:
Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]
Output: true
Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1

Example 2:
Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]
Output: false

Example 3:
Input: arr = [3,3,6,5,-2,2,5,1,-9,4]
Output: true
Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4

Constraints:
`3 <= arr.length <= 5 * 104`
`-104 <= arr[i] <= 104`

### Solution 
 To solve this problem on LeetCode, you can implement the solution using the following steps:

1. **Calculate the Total Sum of the Array:** First, calculate the sum of all elements in the array, which we'll denote as `total_sum`.

2. **Check for Divisibility by Three:** If `total_sum` is not divisible by three, it's impossible to partition the array into three parts with equal sums. Thus, return `False` immediately.

3. **Determine the Target Partition Sum:** The target sum for each of the three partitions would be `target = total_sum / 3`.

4. **Iterate Through the Array to locate Partition Points:** Traverse the array while maintaining a running sum (`current_sum`). Each time `current_sum` matches the `target`, you potentially have one part of the partition. Count these matches.

5. **Check Secure Partition Locations:** If you can find three partitions, then between the first match (`current_sum == target`) and the final element of the array, check if you can hit the target two more times (dividing the subsequent segments similarly). 

6. **Evaluate the Final Condition:** If you found three segments where `current_sum` equals the `target` three times before reaching the end of the array, return `True`. Otherwise, `False`.

Here's how this might be implemented in Python:



```python
class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total_sum = sum(arr)
        if total_sum % 3 != 0:
            return False
        
        target = total_sum // 3
        current_sum = 0
        count = 0
        
        for num in arr:
            current_sum += num
            if current_sum == target:
                count += 1
                current_sum = 0
        
        return count >= 3  # Check if we found at least three parts

```

### Explanation:
1. **`total_sum` Calculation**: The total sum of the array elements is calculated with `sum(arr)`.
2. **Divisibility Check**: We check if `total_sum` is divisible by 3. If not, evenly dividing the array into three parts with equal sums is impossible.
3. **Partitioning**: As we iterate through the array, we count occurrences where segments sum to `target`. We reset `current_sum` each time we achieve `target`.
4. **Final Evaluation**: After the loop, we check if we found at least three such partitions. The reason why `count >= 3` suffices instead of exactly three is because any excess partitions (exceeding three perfect partitions but still summing to zero) do not affect the division's correctness.

This code meets the challenge constraints, considers all edge cases, and can be run directly in LeetCode's Python environment for a solution.

# 1014. Best Sightseeing Pair

### Problem Description 
You are given an integer array `values` where values[i] represents the value of the `ith` sightseeing spot. Two sightseeing spots `i` and `j` have a distance `j - i` between them.

The score of a pair (`i < j`) of sightseeing spots is `values[i] + values[j] + i - j`: the sum of the values of the sightseeing spots, minus the distance between them.

Return the maximum score of a pair of sightseeing spots.


Example 1:
Input: values = [8,1,5,2,6]
Output: 11
Explanation: i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11

Example 2:
Input: values = [1,2]
Output: 2

Constraints:
`2 <= values.length <= 5 * 104`
`1 <= values[i] <= 1000`

### Solution 
 To solve this problem efficiently, we can benefit from breaking down the scoring formula and processing it in a manner that allows us to keep track of potential maximums in an adaptive way. 

The score for a pair of sightseeing spots (i < j) is:
\[ \text{score} = \text{values}[i] + \text{values}[j] + i - j \]
This can be rearranged as follows:
\[ \text{score} = (\text{values}[i] + i) + (\text{values}[j] - j) \]

Given this breakdown, for any `j`, the score is determined by combining:
- values[j] adjusted by subtracting `j`
- The maximum value of `(values[i] + i)` that we've seen for all previous `i`

To solve this:
1. We traverse the `values` array while keeping track of the maximum value of `values[i] + i` seen so far.
2. For each `j`, we compute the potential maximum score using the current value at `j` and the max `values[i] + i` observed.
3. Update the overall maximum score found during the traversal.

Now, let's implement this solution in Python, adhering to LeetCode's format.



```python
class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:
        max_score = 0
        max_value_plus_i = 0  # This will keep track of the maximum value of `values[i] + i`
        
        for j in range(len(values)):
            # Compute the score as we've split up in the explanation, using the max_value_plus_i found until `j-1`
            if j > 0:
                max_score = max(max_score, max_value_plus_i + values[j] - j)
            
            # Update the max_value_plus_i for use in future calculations
            max_value_plus_i = max(max_value_plus_i, values[j] + j)
        
        return max_score
        
# This solution has a time complexity of O(n) and a space complexity of O(1).

```

This code uses efficient updating and comparison operations to determine the maximum sightseeing score for any valid pairs (`i < j`) from the input list.

# 1031. Maximum Sum of Two Non-Overlapping Subarrays

### Problem Description 
Given an array `A` of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths `L` and `M`.  (For clarification, the `L`-length subarray could occur before or after the `M`-length subarray.)
Formally, return the largest `V` for which `V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1])` and either:
`0 <= i < i + L - 1 < j < j + M - 1 < A.length`, or
`0 <= j < j + M - 1 < i < i + L - 1 < A.length`.


Example 1:
Input: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2
Output: 20
Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.


Example 2:
Input: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2
Output: 29
Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.


Example 3:
Input: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3
Output: 31
Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.

Note:
`L >= 1`
`M >= 1`
`L + M <= A.length <= 1000`
`0 <= A[i] <= 1000`

### Solution 
 Here is a Python solution to the problem using a sliding window approach:



```python
class Solution:
    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
        def maxSumFixedFirst(A, firstLen, secondLen):
            # Precompute prefix sums
            prefixSums = [0] * len(A)
            prefixSums[0] = A[0]
            
            for i in range(1, len(A)):
                prefixSums[i] = prefixSums[i-1] + A[i]

            # Find the best blocks using a sliding window approach
            maxFirst = prefixSums[firstLen-1]  # Max sum of the first block
            maxResult = 0
            maxSecond = 0
            
            # Start from rightmost possible end of the second block
            for j in range(firstLen + secondLen - 1, len(A)):
                maxSecond = max(maxSecond, prefixSums[j] - prefixSums[j-secondLen])
                maxFirst = max(maxFirst, prefixSums[j-secondLen] - (prefixSums[j-secondLen-firstLen] if j >= secondLen + firstLen - 1 else 0))
                total = maxFirst + maxSecond
                maxResult = max(maxResult, total)

            return maxResult

        # The maximum of fixing first L and then M, or fixing first M and then L.
        return max(maxSumFixedFirst(A, L, M), maxSumFixedFirst(A, M, L))


# Example usage:
sol = Solution()
print(sol.maxSumTwoNoOverlap([0,6,5,2,2,5,1,9,4], 1, 2))  # Output: 20
print(sol.maxSumTwoNoOverlap([3,8,1,3,2,1,8,9,0], 3, 2)) # Output: 29
print(sol.maxSumTwoNoOverlap([2,1,5,6,0,9,5,0,3,8], 4, 3)) # Output: 31

```

### Explanation:
1. **Function `maxSumFixedFirst(A, firstLen, secondLen)`:** The main idea is to find the maximum sum of two non-overlapping subarrays, where the first subarray is of length `firstLen` and the second one is of length `secondLen`.

2. **Prefix Sums:** We first compute prefix sums for the array which helps in calculating the sum of any subarray in constant time.

3. **Sliding Window for Max Sums:** Two windows are used:
   - `maxFirst` keeps track of the maximum sum of a subarray of length `firstLen` seen so far.
   - We slide a second window that computes the sum of a subarray of length `secondLen`, updating `maxSecond` for the best such sum immediately after the current maximum `maxFirst`.

4. **Total Calculation:** For each position where both subarrays can be placed without overlap, compute the aggregate sum and maintain the maximum found so far.

5. **Max of Two Configurations:** Since either subarray `L` or `M` can appear first, the solution need to take the maximum of either configuration (`L` then `M` or `M` then `L`).

### Complexity:
- **Time Complexity:** O(n), where n is the length of the array, since each subarray sum calculation and update is handled in constant time.
- **Space Complexity:** O(n) due to the storage required for the prefix sum array.

# 1035. Uncrossed Lines

### Problem Description 
We write the integers of `A` and `B` (in the order they are given) on two separate horizontal lines.

Now, we may draw connecting lines: a straight line connecting two numbers `A[i]` and `B[j]` such that:
`A[i] == B[j]`;
The line we draw does not intersect any other connecting (non-horizontal) line.

Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.

Return the maximum number of connecting lines we can draw in this way.


Example 1:
Input: A = [1,4,2], B = [1,2,4]
Output: 2
Explanation: We can draw 2 uncrossed lines as in the diagram.

We cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.


Example 2:
Input: A = [2,5,1,2,5], B = [10,5,2,1,5,2]
Output: 3

Example 3:
Input: A = [1,3,7,1,7,5], B = [1,9,2,5,1]
Output: 2
Note:
`1 <= A.length <= 500`
`1 <= B.length <= 500`
`1 <= A[i], B[i] <= 2000`

### Solution 
 The problem described can be viewed as finding the Longest Common Subsequence (LCS) between two sequences, as the rules of connecting lines mirror the conditions of the elements in an LCS:

1. Elements from both sequences that are part of the LCS are pairwise equal (`A[i] == B[j]` in this case).
2. The sequence of elements in each LCS must appear in the same order in both original sequences, ensuring that the lines do not intersect.

Thus, our task is to compute the LCS of the two input arrays `A` and `B`.

To implement this, we can leverage dynamic programming. We create a 2D array `dp` where `dp[i][j]` represents the length of the LCS between the first `i` elements of `A` and the first `j` elements of `B`. The relations can be derived as:

- If `A[i-1] == B[j-1]`, then `dp[i][j] = dp[i-1][j-1] + 1` because the current elements add one to the length of LCS found so far without these elements.
- If `A[i-1] != B[j-1]`, then `dp[i][j] = max(dp[i-1][j], dp[i][j-1])` because the LCS could be maximum by either ignoring the last element of `A` or the last element of `B`.

The LCS length for the entire sequences will be found in `dp[len(A)][len(B)]`.

Here is the Python code for the same to be run directly on LeetCode:



```python
class Solution:
    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:
        m, n = len(A), len(B)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if A[i - 1] == B[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[m][n]


```

This solution will compute the maximum number of uncrossed lines (LCS) that can be drawn between the two arrays A and B. Each position of `dp` is filled based on the above rules, thereby filling the entire table in O(m*n) time, where m and n are lengths of the arrays A and B. The space complexity is also O(m*n) due to the `dp` table used.

# 1040. Moving Stones Until Consecutive II

### Problem Description 
On an infinite number line, the position of the i-th stone is given by `stones[i]`.  Call a stone an endpoint stone if it has the smallest or largest position.

Each turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.

In particular, if the stones are at say, `stones = [1,2,5]`, you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.

The game ends when you cannot make any more moves, ie. the stones are in consecutive positions.

When the game ends, what is the minimum and maximum number of moves that you could have made?  Return the answer as an length 2 array: `answer = [minimum_moves, maximum_moves]`

Example 1:
Input: [7,4,9]
Output: [1,2]
Explanation: 
We can move 4 -> 8 for one move to finish the game.

Or, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.


Example 2:
Input: [6,5,4,3,10]
Output: [2,3]
We can move 3 -> 8 then 10 -> 7 to finish the game.

Or, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.

Notice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.


Example 3:
Input: [100,101,104,102,103]
Output: [0,0]
Note:
`3 <= stones.length <= 10^4`
`1 <= stones[i] <= 10^9`
`stones[i]` have distinct values.

### Solution 
 Here is a Python solution that can be run directly on the LeetCode platform:



```python
class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        n = len(stones)
        max_moves = max(stones[-1] - stones[1] - (n - 2), stones[-2] - stones[0] - (n - 2))
        
        i, min_moves = 0, float('inf')
        for j in range(n):
            while stones[j] - stones[i] >= n:
                i += 1
            if j - i + 1 == n - 1 and stones[j] - stones[i] == n - 2:
                min_moves = min(min_moves, 2)
            else:
                min_moves = min(min_moves, n - (j - i + 1))
        
        return [min_moves, max_moves]


```

### Explanation

The solution follows these steps:

1. **Sorting the Array**: First, we sort the list of stone positions. This helps to easily identify the endpoint stones for processing.

2. **Calculating Maximum Moves**:
    - We calculate how many stones are not in the position just next to the first stone (`stones[-1] - stones[1] - (n-2)`). It counts the gap between the last stone and the second stone minus the number of stones that should ideally be between them if they were consecutive.
    - Similarly, we calculate for the gap between the second-last stone and the first stone (`stones[-2] - stones[0] - (n-2)`).
    - The maximum number of moves is the maximum of these two gaps.

3. **Calculating Minimum Moves**:
    - We use a sliding window of size `n` to find the smallest range of stones that can be transformed into a consecutive sequence with the minimum number of moves.
    - For every ending stone in the sorted array (indexed by `j`), we adjust the starting point of the window (`i`), ensuring the size of the gap covered by the stones between `i` and `j` (both inclusive) is less than `n`.
    - If the window size (`j-i+1`) is `n-1` and the gap is exactly `n-2`, this means we can cover the gap in exactly two specific moves. Otherwise, the number of moves required would be enough to fill in the missing stones in our current window - which is `n - (j - i + 1)`.

### Example Walkthrough:

For example `stones = [6,5,4,3,10]`:
- **Sorting**: Becomes `[3, 4, 5, 6, 10]`
- **Maximum Moves**: 
    - Between `10` and `4` (skipping `3`), where the count of missing stones is `10 - 4 - 4 = 2`.
    - Between `6` and `3`, where the count of missing stones is `6 - 3 - 3 = 0`. 
    - Hence the maximum moves are `3`.
- **Minimum Moves**: 
    - We aim to use windows to find a set that would be quickest to make consecutive.
    - The number of moves would be `2`, eventually determined by moving the smaller stones or the outlier stone (`10`) closer to the main group.

In the application, these calculations provide the correct minimum and maximum moves in optimal time.

# 1051. Height Checker

### Problem Description 
A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array `expected` where `expected[i]` is the expected height of the `ith` student in line.

You are given an integer array `heights` representing the current order that the students are standing in. Each `heights[i]` is the height of the `ith` student in line (0-indexed).

Return the number of indices where `heights[i] != expected[i]`.


Example 1:
Input: heights = [1,1,4,2,1,3]
Output: 3
Explanation: 
heights:  [1,1,4,2,1,3]
expected: [1,1,1,2,3,4]
Indices 2, 4, and 5 do not match.


Example 2:
Input: heights = [5,1,2,3,4]
Output: 5
Explanation:
heights:  [5,1,2,3,4]
expected: [1,2,3,4,5]
All indices do not match.


Example 3:
Input: heights = [1,2,3,4,5]
Output: 0
Explanation:
heights:  [1,2,3,4,5]
expected: [1,2,3,4,5]
All indices match.


Constraints:
`1 <= heights.length <= 100`
`1 <= heights[i] <= 100`

### Solution 
 To solve this problem, we can follow these steps:

1. Copy the given `heights` array into a new array `expected`.
2. Sort the `expected` array in non-decreasing order. This sorted array represents the expected order of students by height.
3. Iterate through the `heights` array and compare each element with the corresponding element in the `expected` array.
4. Count the indices where `heights[i]` does not match `expected[i]`.
5. Return this count.

The logic behind sorting the `expected` array is to align students as the problem demands â€“ in non-decreasing order by height. We then simply measure discrepancies between this ideally ordered array and the given `heights` array.

Here is the Python code that follows these steps using a function that can be used for testing on LeetCode:



```python
class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        # Step 2: Sort heights to get the expected order
        expected = sorted(heights)
        
        # Step 4: Count the mismatched indices
        mismatch_count = 0
        # Step 3: Iterate through heights and compare
        for i in range(len(heights)):
            if heights[i] != expected[i]:
                mismatch_count += 1
                
        return mismatch_count

```

This function is designed as part of a class, `Solution`, with the method `heightChecker` taking a list `heights` and returning the count of mismatched indices. The functionality is efficient since sorting the list `expected` takes O(n log n) time and the iteration for comparison takes O(n) time, where `n` is the length of `heights`. Given the constraints (1 <= heights.length <= 100), this solution is computationally feasible.

# 1052. Grumpy Bookstore Owner

### Problem Description 
Today, the bookstore owner has a store open for `customers.length` minutes.  Every minute, some number of customers (`customers[i]`) enter the store, and all those customers leave after the end of that minute.

On some minutes, the bookstore owner is grumpy.  If the bookstore owner is grumpy on the i-th minute, `grumpy[i] = 1`, otherwise `grumpy[i] = 0`.  When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.

The bookstore owner knows a secret technique to keep themselves not grumpy for `X` minutes straight, but can only use it once.

Return the maximum number of customers that can be satisfied throughout the day.


Example 1:
Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
Output: 16
Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. 
The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.

Note:
`1 <= X <= customers.length == grumpy.length <= 20000`
`0 <= customers[i] <= 1000`
`0 <= grumpy[i] <= 1`

### Solution 
 To solve this problem, the key idea is to use the sliding window technique. The goal is to find a window of `X` consecutive minutes during which, if the bookstore owner applies their technique to stay not grumpy, it will lead to the maximum possible increase in the number of satisfied customers.

Here's how we can approach the solution:
1. **Initial Count of Satisfied Customers**: First, compute the number of satisfied customers without using the special technique. These are the customers for whom `grumpy[i] == 0`.
2. **Use Sliding Window to Find Optimal `X` Minutes**: Apply a sliding window to find a period of `X` minutes where the owner being not grumpy has the maximum impact. This impact is assessed in terms of the sum of `customers[i]` whose `grumpy[i] == 1` within that window. Just slide this window across the entire day and keep track of the highest potential gain in satisfaction.
3. **Combine Results**: The result will be the initial count of satisfied customers plus the maximum gain in potential satisfaction found from the sliding window approach.

Below is the implementation in Python which fits the LeetCode format:



```python
class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:
        n = len(customers)
        already_satisfied = 0
        max_gain = 0
        current_gain = 0
        
        # Calculate already satisfied customers and initial gain from using X on first window
        for i in range(n):
            if grumpy[i] == 0:
                already_satisfied += customers[i]

        # Calculate initial potential gain if X is applied starting at index 0
        for i in range(X):
            if grumpy[i] == 1:
                current_gain += customers[i]
        
        max_gain = current_gain

        # Slide the window, calculate potential gain, and update max_gain if current_gain is higher
        for i in range(X, n):
            if grumpy[i] == 1:
                current_gain += customers[i]
            if grumpy[i - X] == 1:
                current_gain -= customers[i - X]
            if current_gain > max_gain:
                max_gain = current_gain
        
        return already_satisfied + max_gain


```
In this code:
- `already_satisfied` keeps track of the number of satisfied customers without applying the special technique.
- `max_gain` and `current_gain` are used to determine how many additional customers can be satisfied using the special technique for specific X minute intervals.
- We slide over the duration once, making the algorithm O(n) in complexity, which is efficient given the constraints.

# 1053. Previous Permutation With One Swap

### Problem Description 
Given an array of positive integers `arr` (not necessarily distinct), return the lexicographically largest permutation that is smaller than `arr`, that can be made with exactly one swap (A swap exchanges the positions of two numbers `arr[i]` and `arr[j]`). If it cannot be done, then return the same array.


Example 1:
Input: arr = [3,2,1]
Output: [3,1,2]
Explanation: Swapping 2 and 1.


Example 2:
Input: arr = [1,1,5]
Output: [1,1,5]
Explanation: This is already the smallest permutation.


Example 3:
Input: arr = [1,9,4,6,7]
Output: [1,7,4,6,9]
Explanation: Swapping 9 and 7.


Example 4:
Input: arr = [3,1,1,3]
Output: [1,3,1,3]
Explanation: Swapping 1 and 3.


Constraints:
`1 <= arr.length <= 104`
`1 <= arr[i] <= 104`

### Solution 
 In solving the problem of finding the lexicographically largest permutation less than a given list by making exactly one swap, we need to adhere to a methodology that ensures efficiency given the constraints.

## Approach

1. **Identify Decreasing Subsequence**:
   - Parse the array from the right towards the left and identify the first position `i` where the sequence starts to increase (`arr[i] < arr[i+1]`). If no such `i` exists, the list is sorted in non-increasing order, and therefore, no larger permutation can be made with a single swap. Return the array as-is.
   
2. **Find the Correct Swap Position**:
   - Once position `i` is identified, find the largest element on the right of `i` but smaller than `arr[i]` to make the required swap. This ensures that the swap results in the largest permutation that is still smaller than the original.
   
3. **Swap and Construct Result**:
   - After identifying the positions `i` and the position `j` of the correctly identified swap element, perform a swap between these positions. This leads to the largest permutation smaller than the original list with one swap condition met.

4. **Return the Result**:
   - After performing the swap, return the modified array.

By carefully inspecting conditions and executing the swap only when beneficial, this method effectively responds to the problem requirements.

Below is the Python code illustrating the outlined approach. It fits the problem statement and works efficiently within the given constraints.



```python
class Solution:
    def prevPermOpt1(self, arr: List[int]) -> List[int]:
        # Find the first position 'i' from the end where arr[i] > arr[i + 1]
        n = len(arr)
        i = n - 2
        while i >= 0 and arr[i] <= arr[i + 1]:
            i -= 1
        
        if i == -1:
            # no valid 'i' was found, the array is non-decreasing
            return arr
        
        # Find the largest element on the right of i which is less than arr[i]
        j = i + 1
        for k in range(i + 2, n):
            if arr[k] < arr[i] and arr[k] > arr[j]:
                j = k
        
        # Swap elements at i and j
        arr[i], arr[j] = arr[j], arr[i]
        
        return arr

# Example:
# sol = Solution()
# print(sol.prevPermOpt1([1,9,4,6,7]))  # Output: [1,7,4,6,9]

```

## Explanation:
- The example `arr = [1,9,4,6,7]` identifies `i` at position 1 (9). The largest element less than 9 after this position is 7 at position 4.
- A swap is performed between positions 1 and 4 resulting in `[1,7,4,6,9]`.
- The code is made in a format ready to be run directly on the LeetCode site and addresses potential edge cases as described in the constraints.

# 1064. Fixed Point

### Problem Description 
Given an array of distinct integers `arr`, where `arr` is sorted in ascending order, return the smallest index `i` that satisfies `arr[i] == i`. If there is no such index, return `-1`.


Example 1:
Input: arr = [-10,-5,0,3,7]
Output: 3
Explanation: For the given array, `arr[0] = -10, arr[1] = -5, arr[2] = 0, arr[3] = 3`, thus the output is 3.


Example 2:
Input: arr = [0,2,5,8,17]
Output: 0
Explanation: `arr[0] = 0`, thus the output is 0.


Example 3:
Input: arr = [-10,-5,3,4,7,9]
Output: -1
Explanation: There is no such `i` that `arr[i] == i`, thus the output is -1.


Constraints:
`1 <= arr.length < 104`
`-109 <= arr[i] <= 109`
Follow up: The `O(n)` solution is very straightforward. Can we do better?

### Solution 
 The problem asks to find the smallest index `i` such that `arr[i] == i` in a sorted array of distinct integers. Given the array is sorted and contains distinct elements, we can use binary search instead of a linear search to optimize the solution, aiming for O(log n) complexity rather than O(n).

### Python Solution with Binary Search

We will utilize binary search approach:
1. Check the middle element of the array.
2. If `arr[mid] == mid`, then we found a candidate. However, to find the smallest index satisfying our condition, we need to continue searching in the left half.
3. If `arr[mid] > mid`, no element at indices greater than `mid` can satisfy the condition because elements are distinct and sorted (therefore always incrementing at least by 1). We search in the left half.
4. If `arr[mid] < mid`, no element before `mid` can satisfy the condition for the same reason mentioned above. Hence, search in the right half.

### Implementation:



```python
class Solution:
    def fixedPoint(self, arr: List[int]) -> int:
        left, right = 0, len(arr) - 1
        result = -1
        
        while left <= right:
            mid = (left + right) // 2
            
            if arr[mid] == mid:
                result = mid
                right = mid - 1  # Continue searching for a smaller index
            elif arr[mid] > mid:
                right = mid - 1
            else:
                left = mid + 1
            
        return result

```

### Explanation:

- We initialize `left` and `right` pointers to cover the entire array.
- In each step, we calculate `mid` and check:
  - if `arr[mid] == mid`: Update `result` to `mid`, and set `right` to `mid - 1` to potentially find an even smaller index satisfying the condition.
  - If `arr[mid] > mid`, set `right` to `mid - 1` to search in the left subarray.
  - If `arr[mid] < mid`, set `left` to `mid + 1` to search in the right subarray.
- The loop continues until `left` is greater than `right`.
- If the condition is never satisfied, `result` remains `-1`, which is returned.

This solution efficiently utilizes the properties of sorted distinct arrays to minimize the number of elements checked, thereby achieving a time complexity of O(log n).

# 1074. Number of Submatrices That Sum to Target

### Problem Description 
Given a `matrix` and a `target`, return the number of non-empty submatrices that sum to target.

A submatrix `x1, y1, x2, y2` is the set of all cells `matrix[x][y]` with `x1 <= x <= x2` and `y1 <= y <= y2`.

Two submatrices `(x1, y1, x2, y2)` and `(x1', y1', x2', y2')` are different if they have some coordinate that is different: for example, if `x1 != x1'`.


Example 1:
Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
Output: 4
Explanation: The four 1x1 submatrices that only contain 0.


Example 2:
Input: matrix = [[1,-1],[-1,1]], target = 0
Output: 5
Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.


Example 3:
Input: matrix = [[904]], target = 0
Output: 0

Constraints:
`1 <= matrix.length <= 100`
`1 <= matrix[0].length <= 100`
`-1000 <= matrix[i] <= 1000`
`-10^8 <= target <= 10^8`

### Solution 
 

```python
class Solution:
    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        rows, cols = len(matrix), len(matrix[0])
        
        # Compute prefix sum for each row
        prefix_sum = [[0] * (cols + 1) for _ in range(rows)]
        for r in range(rows):
            for c in range(cols):
                prefix_sum[r][c+1] = prefix_sum[r][c] + matrix[r][c]
        
        count = 0
        
        # Now, let's use the prefix sums to compute the sums of all possible submatrices.
        # We will fix two columns c1 and c2 and then compute sum for rows between these two columns for all possible row ranges.
        for c1 in range(cols):
            for c2 in range(c1, cols):
                # We now have a submatrix defined from column c1 to c2 for all rows.
                # We need to find all sub row ranges [r1, r2] having sum = target.
                submatrix_sum = defaultdict(int)
                submatrix_sum[0] = 1  # There's one way to have sum = 0 (with an empty subarray)
                current_sum = 0
                
                # Compute the sum of submatrix from c1 to c2 for each row and check how many times (current_sum - target) happened before.
                for r in range(rows):
                    # Sum from row start to current row for fixed columns c1 to c2
                    current_sum += prefix_sum[r][c2+1] - prefix_sum[r][c1]
                    
                    # If current_sum - target is found in the previously found sums, those many submatrices end here that sum to target.
                    count += submatrix_sum[current_sum - target]
                    
                    # Store the occurrence of this sum
                    submatrix_sum[current_sum] += 1
        
        return count


# The Solution class can be used in the following way:
sol = Solution()
result = sol.numSubmatrixSumTarget([[0,1,0],[1,1,1],[0,1,0]], 0)
print(result)  # Output should be 4

```

### Explanation:
The solution involves converting the 2D submatrix sum problem into a series of 1D subarray sum problems:

1. **Prefix Sum Calculation for Rows**:
   - Compute prefix sums for each row which will help in efficient computation of subarrays sums between columns `c1` and `c2`.

2. **Two pointers for columns (c1, c2)**:
   - Fix two columns `c1` and `c2` and consider all submatrices that stretch from `c1` to `c2` for any row pair `(r1, r2)`.

3. **HashMap Based Sum Counting for Rows Between c1 and c2**:
   - For every pair of columns, use a hashmap (`submatrix_sum`) to keep track of cumulative sums. By iterating over all rows `r` between `c1` and `c2`, compute the sum of submatrix from top row to current row `r` and use hashmap to find how many times the adjusted sum `(current_sum - target)` has occurred.
   - This helps us compute the count of submatrices ending in row `r` which have the required target sum.

4. **Result Computation**:
   - Sum up all valid submatrices (which are identified using the hashmap) for all pairs `(c1, c2)` and all row ranges within these two columns.

### Complexity:
- Time complexity is roughly O(n^2 * m), where `n` is the number of rows and `m` is the number of columns. This is due to:
  - O(m^2) for all pairs of columns `(c1, c2)`.
  - O(n) for iterating through all rows to compute sums and checking hashmap for existing sums.
- Space complexity is O(n + m) which comes from the space for the row prefix sums and the hashmap used for keeping cumulative sums.

# 1085. Sum of Digits in the Minimum Number

### Problem Description 
Given an array `A` of positive integers, let `S` be the sum of the digits of the minimal element of `A`.

Return 0 if `S` is odd, otherwise return 1.


Example 1:
Input: [34,23,1,24,75,33,54,8]
Output: 0
Explanation: 
The minimal element is 1, and the sum of those digits is S = 1 which is odd, so the answer is 0.


Example 2:
Input: [99,77,33,66,55]
Output: 1
Explanation: 
The minimal element is 33, and the sum of those digits is S = 3 + 3 = 6 which is even, so the answer is 1.


Constraints:
`1 <= A.length <= 100`
`1 <= A[i] <= 100`

### Solution 
 To solve this problem, we first need to find the minimal element of the input list `A`. Once we identify the minimum, we sum its digits and check whether the sum is odd or even. If it's odd, we return 0; otherwise, we return 1.

Here's a breakdown of the steps:
1. Identify the smallest element in the array `A`.
2. Calculate the sum of the digits of this minimum value.
3. Determine if the sum is odd or even.
4. Return 0 if the sum is odd, otherwise return 1.

We can make efficient use of Python's built-in functions to achieve the following:
- Use `min()` to find the minimum of the list.
- Convert this minimum value into a string to easily iterate over each digit, then convert each digit back to integer to calculate the sum.
- Finally, check the odd/even nature of this sum using modulus operator `%`.

Here is a direct implementation that can be used on LeetCode:



```python
class Solution:
    def sumOfDigits(self, A: List[int]) -> int:
        # Find the smallest element in A
        minimum = min(A)
        
        # Compute the sum of the digits of the smallest element
        sum_digits = sum(int(digit) for digit in str(minimum))
        
        # Determine if the sum of the digits is odd or even
        # Return 0 if odd, 1 if even
        if sum_digits % 2 == 0:
            return 1
        else:
            return 0

```

This implementation follows the defined constraints and efficiently uses Python features for concise and readable code. It directly integrates with the function definition expected by LeetCode, ensuring compatibility for direct execution and testing on the platform.

# 1086. High Five

### Problem Description 
Given a list of the scores of different students, `items`, where `items[i] = [IDi, scorei]` represents one score from a student with `IDi`, calculate each student's top five average.

Return the answer as an array of pairs `result`, where `result[j] = [IDj, topFiveAveragej]` represents the student with `IDj` and their top five average. Sort `result` by `IDj` in increasing order.

A student's top five average is calculated by taking the sum of their top five scores and dividing it by `5` using integer division.


Example 1:
Input: items = [[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]
Output: [[1,87],[2,88]]
Explanation: 
The student with ID = 1 got scores 91, 92, 60, 65, 87, and 100. Their top five average is (100 + 92 + 91 + 87 + 65) / 5 = 87.

The student with ID = 2 got scores 93, 97, 77, 100, and 76. Their top five average is (100 + 97 + 93 + 77 + 76) / 5 = 88.6, but with integer division their average converts to 88.


Example 2:
Input: items = [[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100]]
Output: [[1,100],[7,100]]

Constraints:
`1 <= items.length <= 1000`
`items[i].length == 2`
`1 <= IDi <= 1000`
`0 <= scorei <= 100`
For each `IDi`, there will be at least five scores.

### Solution 
 To solve this problem, we need to efficiently calculate the top five average score for each student given their ID and list of scores. Here is the step-by-step approach:

1. **Initialize Data Structures**: Use a dictionary to gather all scores for each student's ID. The keys will be student IDs, and the values will be lists of scores for those IDs.

2. **Group Scores by ID**: Traverse through each `[ID, score]` in `items` and group the scores into the dictionary initialized in step 1.

3. **Calculate Top Five Average**: For each student ID, retrieve the list of scores, sort them, and take the last five elements (top five highest scores) to compute the integer division of their sum by 5.

4. **Prepare Result**: Collect results into a list of `[ID, topFiveAverage]` pairs. Sort this list by student IDs.

5. **Return the Sorted Results**: Return the sorted result list.

This solution is efficient and handles the most scores per student gracefully due to Python's efficiency in sorting and list management.

Here's the code based on the above steps:



```python
class Solution:
    def highFive(self, items: List[List[int]]) -> List[List[int]]:
        from collections import defaultdict
        
        # 1. Initialize the data structure to store scores based on student IDs
        score_map = defaultdict(list)
        
        # 2. Group scores by ID
        for item in items:
            id, score = item
            score_map[id].append(score)
        
        # 3. Calculate top five average and prepare the results
        result = []
        for id in sorted(score_map.keys()):
            # Get all scores for a student, sort them, and pick the top five
            scores = sorted(score_map[id], reverse=True)[:5]
            # Calculate the top five average using integer division
            top_five_average = sum(scores) // 5
            # Append to the result list
            result.append([id, top_five_average])
        
        return result

# Example of how to run the solution (this part isn't needed when submitting on LeetCode)
sol = Solution()
print(sol.highFive([[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]))

```

This Python code will integrate well into a LeetCode submission for a problem with the outlined characteristics. Replace `List` with `list` if running this outside of the LeetCode environment or a similar setting where `List` isn't recognized due to potential IDE or environment settings not importing `typing`. The main design uses a dictionary of lists to achieve efficient score gathering and processing.

# 1089. Duplicate Zeros

### Problem Description 
Given a fixed length array `arr` of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.

Note that elements beyond the length of the original array are not written.

Do the above modifications to the input array in place, do not return anything from your function.


Example 1:
Input: [1,0,2,3,0,4,5,0]
Output: null
Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]

Example 2:
Input: [1,2,3]
Output: null
Explanation: After calling your function, the input array is modified to: [1,2,3]
Note:
`1 <= arr.length <= 10000`
`0 <= arr[i] <= 9`

### Solution 
 To solve the problem of duplicating zeros in a fixed-length array in-place, we can approach it using a two-pass solution:
1. **First Pass:** We count the number of zeros which can be duplicated within the bounds of the original array size.
2. **Second Pass:** We modify the array from the end toward the beginning. This allows us to shift elements to the right without using additional space to hold intermediate results.

Here are the detailed steps for the implementation:
- **Counting Zeros:** Walk through the array and count zeros until the point where duplicating any further zeros would exceed the array bounds.
- **Shifting Elements:** Using a pointer starting from the end of the array, we fill in the array by considering zeros to be duplicated and all other elements to be shifted. By handling the array modification from the end, we avoid overwriting elements that we have not yet processed.

This approach ensures all operations are done directly on the array, which results in an in-place solution with O(n) time complexity, where n is the length of the array.

Here is the Python code that follows this idea and can be run directly on LeetCode:



```python
class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """
        Do not return anything, modify arr in-place instead.
        """
        n = len(arr)
        zeros_to_duplicate = 0
        # First, determine the size of the effective array including duplicated zeros fitting within array length
        for i in range(n):
            if i > n - zeros_to_duplicate - 1:
                break
            if arr[i] == 0:
                # If zero is at the edge of the resized array, it cannot be duplicated
                if i == n - zeros_to_duplicate - 1:
                    arr[n-1] = 0
                    n -= 1
                    break
                zeros_to_duplicate += 1

        # Second, fill in the array from the back 
        i = n - zeros_to_duplicate - 1
        j = n - 1

        while zeros_to_duplicate:
            if arr[i] == 0:
                arr[j] = 0
                j -= 1
                arr[j] = 0
                zeros_to_duplicate -= 1
            else:
                arr[j] = arr[i]
            j -= 1
            i -= 1

```

### Explanation
1. **First Part - Counting and Validation:** We traverse through the array only until the point where adding another duplicated zero would overflow the fixed size of the input array (`n` represents the effective end of the array after expansion consideration). If the last possible zero overlaps the array boundary, it is handled specifically by setting the last position to zero.
   
2. **Second Part - Backward Population:** The indices `i` move from the original logical end, and `j` is used to populate from the physical end of the array. If a zero is encountered, it is duplicated, else the value is just copied. By processing from the end, no values are overwritten prematurely.

This method correctly shifts array elements and duplicates zeros as specified in-place, and it operates efficiently on the input without requiring additional space proportional to the array size.

# 1099. Two Sum Less Than K

### Problem Description 
Given an array `nums` of integers and integer `k`, return the maximum `sum` such that there exists `i < j` with `nums[i] + nums[j] = sum` and `sum < k`. If no `i`, `j` exist satisfying this equation, return `-1`.


Example 1:
Input: nums = [34,23,1,24,75,33,54,8], k = 60
Output: 58
Explanation: We can use 34 and 24 to sum 58 which is less than 60.


Example 2:
Input: nums = [10,20,30], k = 15
Output: -1
Explanation: In this case it is not possible to get a pair sum less that 15.


Constraints:
`1 <= nums.length <= 100`
`1 <= nums[i] <= 1000`
`1 <= k <= 2000`

### Solution 
 Here's a Python code implementing a solution to the problem described. The program seeks to find the maximum sum of pairs within a given array (`nums`) where the sum is less than a specified integer (`k`). The `TwoSumLessThanK` function uses a sorting method alongside a two-pointer technique for optimal performance.



```python
class Solution:
    def twoSumLessThanK(self, nums: List[int], k: int) -> int:
        # Sort the array to use two-pointer technique
        nums.sort()
        
        # Initialize two pointers
        left, right = 0, len(nums) - 1
        
        # Variable to track the maximum sum found that's less than k
        max_sum = -1
        
        while left < right:
            current_sum = nums[left] + nums[right]
            
            # Check if current_sum of two numbers is less than k
            if current_sum < k:
                # Update max_sum if current_sum is greater than max_sum
                max_sum = max(max_sum, current_sum)
                # Move the left pointer to the right to try to increase the sum
                left += 1
            else:
                # If current_sum is greater or equal to k, move the right pointer to the left
                right -= 1
                
        return max_sum

# Example usage:
# sol = Solution()
# print(sol.twoSumLessThanK([34,23,1,24,75,33,54,8], 60))  # Output: 58
# print(sol.twoSumLessThanK([10,20,30], 15))  # Output: -1

```

### Explanation of the code:

1. **Sorting**: The array `nums` is first sorted. Sorting is important here as it allows efficient browsing of possible pairs using the two-pointer approach.

2. **Two-pointer approach**: This utilizes two pointers - `left` starting from the beginning of the array, and `right` from the end of the array. If the sum of the pair pointed by these pointers (`current_sum`) is less than `k`, the sum is compared with `max_sum`, updating `max_sum` if it is greater. The left pointer then moves one step to the right (`left += 1`) aiming to potentially increase the `current_sum`. If the `current_sum` is greater than or equal to `k`, the pair sum needs to be reduced, so the right pointer decrements (`right -= 1`).

3. **Efficiency**: This solution is very efficient, with a time complexity of \(O(n \log n)\) due to the sorting step, while the two-pointer traversal itself is \(O(n)\). Comparatively, a naive \(O(n^2)\) solution would involve checking all possible pairs with nested loops.

4. **Edge Cases**: If no pair sums under `k` are found, the function returns `-1` as required. Moreover, this solution handles arrays of minimum length (1), though the problem guarantees at least one possible pair by ensuring `1 <= nums.length`.

This script conforms to typical LeetCode format, ensuring that it can be run directly on the platform as requested. The class `Solution` containing the function `twoSumLessThanK` directly corresponds to how problems are structured on LeetCode.

# 1109. Corporate Flight Bookings

### Problem Description 
There are `n` flights that are labeled from `1` to `n`.

You are given an array of flight bookings `bookings`, where `bookings[i] = [firsti, lasti, seatsi]` represents a booking for flights `firsti` through `lasti` (inclusive) with `seatsi` seats reserved for each flight in the range.

Return an array `answer` of length `n`, where `answer[i]` is the total number of seats reserved for flight `i`.


Example 1:
Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
Output: [10,55,45,25,25]
Explanation:
Flight labels:        1   2   3   4   5
Booking 1 reserved:  10  10
Booking 2 reserved:      20  20
Booking 3 reserved:      25  25  25  25
Total seats:         10  55  45  25  25
Hence, answer = [10,55,45,25,25]

Example 2:
Input: bookings = [[1,2,10],[2,2,15]], n = 2
Output: [10,25]
Explanation:
Flight labels:        1   2
Booking 1 reserved:  10  10
Booking 2 reserved:      15
Total seats:         10  25
Hence, answer = [10,25]

Constraints:
`1 <= n <= 2 * 104`
`1 <= bookings.length <= 2 * 104`
`bookings[i].length == 3`
`1 <= firsti <= lasti <= n`
`1 <= seatsi <= 104`

### Solution 
 To solve the problem of calculating the total number of seats reserved for each flight using the flight bookings data, we can employ an efficient approach using the difference array technique. This technique helps in updating a range of values in an array efficiently.

### Explanation:

When a range of values in an array need to be increased uniformly, instead of updating each element individually, which could be inefficient and slow, we can use the difference array approach which involves:

1. Incrementing the start of the range by the required value.
2. Decrementing just after the end of the range (if it exists within the bounds) by the same value.

At the end, we derive the actual values by taking the prefix sum of the modified array.

### Steps:

1. Create an array `answer` of size `n` initialized with zeros.
2. For each booking:
   - Increment `answer[firsti - 1]` by `seatsi` (since flight numbers are 1-based and indexes in Python are 0-based).
   - If `lasti < n`, decrement `answer[lasti]` (position after lasti) by `seatsi` to ensure increase is only up to `lasti`.
3. Compute the prefix sum on `answer` to get the actual counts of reserved seats.

### Python Code:



```python
class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        answer = [0] * n
        
        # Applying the range update using difference array technique
        for firsti, lasti, seatsi in bookings:
            answer[firsti - 1] += seatsi
            if lasti < n:
                answer[lasti] -= seatsi
        
        # Computing the prefix sum to get the reservation count on each flight
        for i in range(1, n):
            answer[i] += answer[i - 1]
        
        return answer

```

### How it works:
- The `answer` array first acts as the difference array where we perform efficient range updates.
- The prefix sum transformation converts this difference information into actual totals.

This method is both time and space efficient, with time complexity being \( O(n + m) \) where \( m \) is the number of bookings, and space complexity being \( O(n) \) for storing the result. The direct approach of updating each flight in each booking individually would lead to a time complexity of \( O(n \times m) \), which can be too slow given the constraints.

# 1122. Relative Sort Array

### Problem Description 
Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.

Sort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`.  Elements that don't appear in `arr2` should be placed at the end of `arr1` in ascending order.


Example 1:
Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
Output: [2,2,2,1,4,3,3,9,6,7,19]

Constraints:
`1 <= arr1.length, arr2.length <= 1000`
`0 <= arr1[i], arr2[i] <= 1000`
All the elements of `arr2` are distinct.

Each `arr2[i]` is in `arr1`.

### Solution 
 To solve the problem, you can follow the steps:

1. **Count Frequencies:** Firstly, count the frequencies of each element in `arr1` using a dictionary. This will be useful to know how many times to place each element in the final sorted order.

2. **Follow arr2 Order:** Iterate over the elements of `arr2`. Since the order of the elements in `arr2` determines their order in the sorted `arr1`, add each element from `arr2` into the `result` list the number of times it appears in `arr1`.

3. **Sort Remaining Elements:** Finally, for the elements in `arr1` that are not in `arr2`, sort these elements and append them to the `result`. You know these elements by comparing your frequency map and reducing the count as you add elements to the `result`.

4. **Output:** Combine the elements from step 2 and 3 to get the required sorted list.

Now, let's implement these steps in Python code using the format suitable for submission on LeetCode:



```python
class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        # Step 1: Count frequencies of elements in arr1
        frequency_map = {}
        for num in arr1:
            if num in frequency_map:
                frequency_map[num] += 1
            else:
                frequency_map[num] = 1
        
        result = []
        
        # Step 2: Append according to arr2's order
        for num in arr2:
            count = frequency_map[num]
            result.extend([num] * count)
            frequency_map[num] = 0  # Clear the count after using
        
        # Step 3: Append remaining elements that are not in arr2
        remaining_elements = []
        for num, count in frequency_map.items():
            if count > 0:
                remaining_elements.extend([num] * count)
        
        # Sort the remaining elements since they should be added in ascending order
        remaining_elements.sort()
        
        # Append to the result
        result.extend(remaining_elements)
        
        return result

```

**Explanation:**
- `frequency_map` counts how often each value appears in `arr1`.
- Iterate over `arr2` to place the duplicates of its elements in the `result` list in the correct order.
- Any elements not in `arr2` but present in `arr1` are added to `remaining_elements`, sorted, and then added to the `result`.

The code adheres to the constraints:
- It efficiently manages the counts using a dictionary, and sorting is done only for the elements not in `arr2`.
- The number of operations is proportional to the size of `arr1` and some additional operations for sorting non-`arr2` elements, making it efficient given the problem's constraints.

# 1128. Number of Equivalent Domino Pairs

### Problem Description 
Given a list of `dominoes`, `dominoes[i] = [a, b]` is equivalent to `dominoes[j] = [c, d]` if and only if either (`a==c` and `b==d`), or (`a==d` and `b==c`) - that is, one domino can be rotated to be equal to another domino.

Return the number of pairs `(i, j)` for which `0 <= i < j < dominoes.length`, and `dominoes[i]` is equivalent to `dominoes[j]`.


Example 1:
Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]
Output: 1

Constraints:
`1 <= dominoes.length <= 40000`
`1 <= dominoes[i][j] <= 9`

### Solution 
 The problem is to find how many pairs of dominoes are equivalent, where two dominoes are considered equivalent if one can be rotated to become identical to the other. Given the constraints and the nature of the problem, a hash map based approach can be quite efficient.

Here's the Python code that can be run directly on LeetCode:



```python
from typing import List
from collections import defaultdict

class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        # This dictionary will store the frequencies of canonical representations of dominoes.
        count = defaultdict(int)
        # This variable will store the count of equivalent domino pair groups.
        res = 0
        
        for a, b in dominoes:
            # Generate a canonical form for each domino using tuple sorting:
            # (min(a,b), max(a,b)) ensures that both (a,b) and (b,a) are counted as the same.
            key = (min(a, b), max(a, b))
            res += count[key]  # If the same key was encountered before, add that count to result.
            count[key] += 1  # Increase the count for this specific key.
        
        return res

# Example usage:
sol = Solution()
print(sol.numEquivDominoPairs([[1,2],[2,1],[3,4],[5,6]]))  # Output: 1

```

### Explanation and Approach:

1. **Data Structure**: A `defaultdict` of integers is used to count occurrences of each domino in its canonical form. Canonical form means encoding a pair in a consistent way regardless of rotation; here, it is done by `key = (min(a, b), max(a, b))`.

2. **Counting the Pairs**: As you go through each domino and transform it into its canonical form, the existing count of that domino represents how many dominoes it can be paired with. So, you can immediately add that count to the result when encountering a new (yet existing) domino.

3. **Efficiency**: This method only involves a single pass through the list of dominoes (`O(n)`) and uses hashing for fast lookup, addition, and update operations (`O(1)` average time complexity), resulting in an overall efficient solution.

4. **Space Complexity**: This approach utilizes space proportional to the number of unique domino representations encountered, which is bound by `9*9 = 81` considering the domino values range from `1` to `9`.

This solution should comfortably handle the problem constraints and provide results in a timely manner on the LeetCode platform.

# 1133. Largest Unique Number

### Problem Description 
Given an array of integers `A`, return the largest integer that only occurs once.

If no integer occurs once, return -1.


Example 1:
Input: [5,7,3,9,4,9,8,3,1]
Output: 8
Explanation: 
The maximum integer in the array is 9 but it is repeated. The number 8 occurs only once, so it's the answer.


Example 2:
Input: [9,9,8,8]
Output: -1
Explanation: 
There is no number that occurs only once.

Note:
`1 <= A.length <= 2000`
`0 <= A[i] <= 1000`

### Solution 
 To solve this problem, one effective way is to use a frequency table to track how many times each integer appears in the array. After constructing the frequency table (using a dictionary in Python for instance), we can then iterate through the dictionary to find the maximum integer that occurs only once. If no such integer exists, the function should return -1.

Hereâ€™s the step-by-step approach:
1. Count the frequency of each integer using a dictionary.
2. Initialize a variable to record the largest single occurrence (`max_single`). Set this initially to -1.
3. Iterate through the items in the frequency dictionary:
   - If the count of an integer is exactly 1 and the integer itself is greater than the current `max_single`, update `max_single`.
4. Return the value of `max_single` after traversing the dictionary. If `max_single` remains -1, it means no integer in the array occurs exactly once.

Let's code this approach:



```python
from typing import List

class Solution:
    def largestUniqueNumber(self, A: List[int]) -> int:
        # Step 1: Create a frequency dictionary
        frequency = {}
        for num in A:
            if num in frequency:
                frequency[num] += 1
            else:
                frequency[num] = 1
        
        # Step 2: Find the maximum integer that occurs exactly once
        max_single = -1
        for number, count in frequency.items():
            if count == 1 and number > max_single:
                max_single = number
        
        return max_single

# Example usage:
sol = Solution()
print(sol.largestUniqueNumber([5,7,3,9,4,9,8,3,1]))  # Output: 8
print(sol.largestUniqueNumber([9,9,8,8]))            # Output: -1

```

This code defines the class `Solution` with the method `largestUniqueNumber` as required on LeetCode. It uses a dictionary to track the frequency of each number and then finds the largest number that occurs exactly once by checking the frequency dictionary. The complexity of this approach is O(N) for creating the frequency dictionary and O(N) for navigating through it, leading to an overall linear time complexity, which is efficient enough for the input limits given (1 <= A.length <= 2000).

# 1144. Decrease Elements To Make Array Zigzag

### Problem Description 
Given an array `nums` of integers, a move consists of choosing any element and decreasing it by 1.

An array `A` is a zigzag array if either:
Every even-indexed element is greater than adjacent elements, ie. `A[0] > A[1] < A[2] > A[3] < A[4] > ...`
OR, every odd-indexed element is greater than adjacent elements, ie. `A[0] < A[1] > A[2] < A[3] > A[4] < ...`
Return the minimum number of moves to transform the given array `nums` into a zigzag array.


Example 1:
Input: nums = [1,2,3]
Output: 2
Explanation: We can decrease 2 to 0 or 3 to 1.


Example 2:
Input: nums = [9,6,1,6,2]
Output: 4

Constraints:
`1 <= nums.length <= 1000`
`1 <= nums[i] <= 1000`

### Solution 
 The problem is about transforming an array into a "zigzag" pattern using the minimum number of decrement operations on the elements. It is necessary to choose the best zigzag pattern (either even-indexed elements higher or odd-indexed elements higher) to minimize the operations.

To solve this problem, we will:

1. Calculate the total number of moves required to enforce the zigzag pattern, where every even-indexed element is higher than its neighbors.
2. Calculate the total number of moves required to enforce the zigzag pattern, where every odd-indexed element is higher than its neighbors.
3. Return the minimum of the two calculated values from steps 1 and 2.

The detailed steps:
- For each element `i` in the list `nums`, adjust it downward to be less than both its neighbors if necessary, while enforcing the chosen zigzag pattern.
  - Calculate the needed decrement based on the neighboring values (either previous or next based on the even or odd indexed check).
  - Accumulate the total decrement steps needed for each pattern.
- Return the minimum of the adjustments needed for either pattern (even higher or odd higher).

Here is the Python code for this solution:



```python
class Solution:
    def movesToMakeZigzag(self, nums: List[int]) -> int:
        def computeMoves(nums, start):
            moves = 0
            n = len(nums)
            for i in range(start, n, 2):
                left = nums[i - 1] if i > 0 else float('inf')
                right = nums[i + 1] if i < n - 1 else float('inf')
                # The current element should be less than the minimum of both neighbors
                decrement = max(0, nums[i] - min(left, right) + 1)
                moves += decrement
            return moves
        
        # Option 1: Make even-indexed elements larger than their neighbors
        moves_even = computeMoves(nums, start=1)
        
        # Option 2: Make odd-indexed elements larger than their neighbors
        moves_odd = computeMoves(nums, start=0)
        
        # Return the minimum of the two options
        return min(moves_even, moves_odd)


```

Explanations for example cases according to the above algorithm:
1. For `nums = [1, 2, 3]`:
   - For `even` pattern, we adjust `2` to `0` (2 decrements), total cost is 2.
   - For `odd` pattern, we adjust `1` to `0` (1 decrement) and `3` to `1` (1 decrement), totaling 2.
   Thus, output is 2 (minimal adjustment effort of both patterns).

2. For `nums = [9, 6, 1, 6, 2]`:
   - For `even` pattern, we adjust `9` to `5` and `6` to `0` increment, totaling 5 (which is not optimal).
   - For `odd` pattern, adjustments would amount to a total of 4 moves.
   Thus, output is 4.

This algorithm efficiently decides the necessary adjustments for each pattern and opts for the minimal one.

# 1146. Snapshot Array

### Problem Description 
Implement a SnapshotArray that supports the following interface:
`SnapshotArray(int length)` initializes an array-like data structure with the given length.  Initially, each element equals 0.

`void set(index, val)` sets the element at the given `index` to be equal to `val`.

`int snap()` takes a snapshot of the array and returns the `snap_id`: the total number of times we called `snap()` minus `1`.

`int get(index, snap_id)` returns the value at the given `index`, at the time we took the snapshot with the given `snap_id`

Example 1:
Input: ["SnapshotArray","set","snap","set","get"]
[[3],[0,5],[],[0,6],[0,0]]
Output: [null,null,0,null,5]
Explanation: 
SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3
snapshotArr.set(0,5);  // Set array[0] = 5
snapshotArr.snap();  // Take a snapshot, return snap_id = 0
snapshotArr.set(0,6);
snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5

Constraints:
`1 <= length <= 50000`
At most `50000` calls will be made to `set`, `snap`, and `get`.

`0 <= index < length`
`0 <= snap_id < `(the total number of times we call `snap()`)
`0 <= val <= 10^9`

### Solution 
 To solve this problem optimally, we need to consider an efficient data structure to maintain snapshots without redundantly copying all elements for each snapshot, especially since the constraints allow up to \(50,000\) calls and each "get" operation needs quick access.

A suitable data structure is an array composed of dictionaries. Each dictionary will represent changes in individual indexes of the array at distinct times (snap_id) when `snap()` is called:

- For the `set` method, we will record the value at the specified index only when it's changed.
- The `snap` method will increase the snapshot counter but will not immediately commit any state in memory.
- The `get` method must traverse these dictionaries to find the most recent value before or at the requested snap_id using binary search.

We'll use Python's `bisect` module for efficient searching, which provides an O(log n) way to search through sorted lists.

Here's a complete solution that can be run on LeetCode:



```python
import bisect

class SnapshotArray:
    def __init__(self, length: int):
        self.snapshotArray = [list() for _ in range(length)]
        self.snap_id = 0

    def set(self, index: int, val: int) -> None:
        # If the value stays unchanged at the last operation, no new record is needed.
        if self.snapshotArray[index] and self.snapshotArray[index][-1][0] == self.snap_id:
            self.snapshotArray[index][-1] = (self.snap_id, val)
        else:
            self.snapshotArray[index].append((self.snap_id, val))

    def snap(self) -> int:
        # Increase the snapshot id and return the previous id.
        self.snap_id += 1
        return self.snap_id - 1

    def get(self, index: int, snap_id: int) -> int:
        snaps = self.snapshotArray[index]
        # Binary search to find the last changed value before or at snap_id
        i = bisect.bisect_right(snaps, (snap_id + 1, )) - 1
        if i >= 0:
            return snaps[i][1]
        else:
            return 0


# Example of how this class can be used (similar to the given example):
# Your SnapshotArray object will be instantiated and called as such:
obj = SnapshotArray(3)
obj.set(0, 5)
param_2 = obj.snap()
obj.set(0, 6)
param_4 = obj.get(0, 0)
print(param_4)  # Output: 5

```

Explanation of this script:

1. **Initialization**: Create a list of lists (one list for each index in the array).
2. **Set**: Append to the list at the `index` the tuple of `(current_snap_id, val)`, but only if the current operation is changing the value or it's the first set operation at that snapshot.
3. **Snap**: Increment the `snap_id` and return the previous id.
4. **Get**: Perform a binary search on the snapshot list at the `index` to locate the closest snapshot not greater than `snap_id` and return the corresponding value.

This solution is efficient as each operation (`set`, `snap`, `get`) has approximately O(log n) in the worst case. The efficiency mainly arises from using the `bisect` library for quick lookup in the snapshots (subset).


# 1150. Check If a Number Is Majority Element in a Sorted Array

### Problem Description 
Given an array `nums` sorted in non-decreasing order, and a number `target`, return `True` if and only if `target` is a majority element.

A majority element is an element that appears more than `N/2` times in an array of length `N`.


Example 1:
Input: nums = [2,4,5,5,5,5,5,6,6], target = 5
Output: true
Explanation: 
The value 5 appears 5 times and the length of the array is 9.

Thus, 5 is a majority element because 5 > 9/2 is true.


Example 2:
Input: nums = [10,100,101,101], target = 101
Output: false
Explanation: 
The value 101 appears 2 times and the length of the array is 4.

Thus, 101 is not a majority element because 2 > 4/2 is false.


Constraints:
`1 <= nums.length <= 1000`
`1 <= nums[i] <= 10^9`
`1 <= target <= 10^9`

### Solution 
 

```python
from typing import List

class Solution:
    def isMajorityElement(self, nums: List[int], target: int) -> bool:
        # Calculate length of the array
        n = len(nums)
        
        # A majority element must appear more than n//2 times
        required_count = n // 2
        
        # To count occurrences of target
        count = 0
        
        # Iterate through the array to count occurrences of target
        for num in nums:
            if num == target:
                count += 1
                
            # Early exit if we already have more than the required counts
            if count > required_count:
                return True
        
        # Check if the final count is greater than required_count
        return count > required_count

# Examples to run

sol = Solution()

# Example 1
print(sol.isMajorityElement([2, 4, 5, 5, 5, 5, 5, 6, 6], 5))  # Expected output: True

# Example 2
print(sol.isMajorityElement([10, 100, 101, 101], 101))  # Expected output: False

```

### Explanation:

The provided Python code defines a class `Solution` with a single method `isMajorityElement`, which aims to solve the problem of determining if a target value is a majority element in a sorted array `nums`.

1. **Parameter and Return Type**:
   - Input: `nums` (List of integers) and `target` (integer)
   - Output: Boolean indicating if `target` is a majority element.

2. **Functionality**:
   - To determine whether a number is a majority element (i.e., appears more than half the array length), the function first calculates the required majority count as `n // 2`, where `n` is the length of `nums`.
   - A count variable keeps track of how many times `target` appears in the array.
   - As the function iterates through the list, it increases the count whenever the current number equals the `target`.
   - If during iteration the count becomes greater than the required majority count, the function can immediately return `True` for efficiency.
   - After the iteration, if the `target` count is still greater than the required count, then it returns `True`, else `False`.

3. **Optimization**:
   - The early exit (`count > required_count`) reduces unnecessary iterations, especially if the majority condition is met early in the array.
  
4. **Given Constraints and Aims**:
   - Ensures that even for arrays at the constraint limits (up to 1000 elements), performance remains efficient given the linear complexity of O(n).

By following this approach, we efficiently determine if the target element is a majority element in the given sorted array. This solution can be directly pasted into the LeetCode editor and executed.

# 1151. Minimum Swaps to Group All 1's Together

### Problem Description 
Given a binary array `data`, return the minimum number of swaps required to group all `1`â€™s present in the array together in any place in the array.


Example 1:
Input: data = [1,0,1,0,1]
Output: 1
Explanation: 
There are 3 ways to group all 1's together:
[1,1,1,0,0] using 1 swap.

[0,1,1,1,0] using 2 swaps.

[0,0,1,1,1] using 1 swap.

The minimum is 1.


Example 2:
Input: data = [0,0,0,1,0]
Output: 0
Explanation: 
Since there is only one 1 in the array, no swaps needed.


Example 3:
Input: data = [1,0,1,0,1,0,0,1,1,0,1]
Output: 3
Explanation: 
One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].


Example 4:
Input: data = [1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1]
Output: 8

Constraints:
`1 <= data.length <= 105`
`data[i]` is `0` or `1`.

### Solution 
 To solve this problem, we can adopt a sliding window technique that focuses on the number of `1`s in the array. The objective is to minimize the number of swaps required to group all `1`s together. An ideal solution is to have one segment (or window) of consecutive `1`s.

### Steps to approach:

1. **Count the Total `1`s in the Array**: This will give the required window size since all `1`s need to be grouped together.

2. **Sliding Window Technique**:
   - This technique can be efficiently used here to find the window (of size equal to the number of `1`s) that contains the maximum number of `1`s.
   - For each window of size `count_of_ones` in the array, calculate how many `1`s are inside. The idea is to shift this window across the array while maintaining its size.
   - Compute the number of `0`s in each window (Since total `1`s are constant, counting `0`s is sufficient).
   - The lesser number of `0`s in a window, the lesser the number of swaps needed to make that particular segment consist of all `1`s.

3. **Calculate swaps**: For each window, the number of swaps required to group all `1`s is equal to the number of `0`s in that window because each `0` represents a swap of a `1` from outside the window to inside.

4. **Result**:
   - The minimum swaps required will be the minimum number of `0`s in any of these windows.

Let's implement this in Python as per the LeetCode format:



```python
class Solution:
    def minSwaps(self, data: List[int]) -> int:
        n = len(data)
        num_ones = sum(data)          # Total number of ones in the array
        if num_ones <= 1:
            return 0                  # No need to swap if there is only one or zero ones
        
        # Use a sliding window of size num_ones
        max_ones_in_window = 0
        current_ones_count = 0
        left = 0
        
        # Initialize the first window
        for i in range(num_ones):
            if data[i] == 1:
                current_ones_count += 1
        
        max_ones_in_window = current_ones_count
        
        # Slide the window over the rest of the array
        for right in range(num_ones, n):
            # Include the new element in the window
            if data[right] == 1:
                current_ones_count += 1
            # Remove the element going out of the window
            if data[left] == 1:
                current_ones_count -= 1
            
            left += 1
            
            # Record the maximum ones in any window of size num_ones
            max_ones_in_window = max(max_ones_in_window, current_ones_count)
        
        # Calculate minimum swaps
        return num_ones - max_ones_in_window

# Example usage:
sol = Solution()
print(sol.minSwaps([1,0,1,0,1]))  # Output: 1

```

This code defines a `Solution` class with a `minSwaps` method as expected in LeetCode's Python environment. The method calculates the required number of swaps to group all `1`s in the provided binary array. The sliding window concept focuses on maximizing the number of `1`s in each window to minimize needed swaps.

# 1152. Analyze User Website Visit Pattern

### Problem Description 
We are given some website visits: the user with name `username[i]` visited the website `website[i]` at time `timestamp[i]`.

A 3-sequence is a list of websites of length 3 sorted in ascending order by the time of their visits.  (The websites in a 3-sequence are not necessarily distinct.)
Find the 3-sequence visited by the largest number of users. If there is more than one solution, return the lexicographically smallest such 3-sequence.


Example 1:
Input: username = ["joe","joe","joe","james","james","james","james","mary","mary","mary"], timestamp = [1,2,3,4,5,6,7,8,9,10], website = ["home","about","career","home","cart","maps","home","home","about","career"]
Output: ["home","about","career"]
Explanation: 
The tuples in this example are:
["joe", 1, "home"]
["joe", 2, "about"]
["joe", 3, "career"]
["james", 4, "home"]
["james", 5, "cart"]
["james", 6, "maps"]
["james", 7, "home"]
["mary", 8, "home"]
["mary", 9, "about"]
["mary", 10, "career"]
The 3-sequence ("home", "about", "career") was visited at least once by 2 users.

The 3-sequence ("home", "cart", "maps") was visited at least once by 1 user.

The 3-sequence ("home", "cart", "home") was visited at least once by 1 user.

The 3-sequence ("home", "maps", "home") was visited at least once by 1 user.

The 3-sequence ("cart", "maps", "home") was visited at least once by 1 user.

Note:
`3 <= N = username.length = timestamp.length = website.length <= 50`
`1 <= username[i].length <= 10`
`0 <= timestamp[i] <= 10^9`
`1 <= website[i].length <= 10`
Both `username[i]` and `website[i]` contain only lowercase characters.

It is guaranteed that there is at least one user who visited at least 3 websites.

No user visits two websites at the same time.

### Solution 
 To tackle the problem described, we can summarize the solution approach in the following steps:

1. **Data Structure for Storing Visits**: We'll group website visits by users using a dictionary where the key is the username and the value is a list of tuples `(timestamp, website)`.

2. **Sorting Visits for Each User**: Sort the list of visits for each user based on timestamp to keep the order of visiting.

3. **Generating Sequences**: For each user, generate all possible 3-website sequences they visited. To prevent recalculating sequences for every user, we can use combinations from itertools.

4. **Counting Unique Sequences Across Users**: Use another dictionary to count how many unique users have visited each 3-sequence.

5. **Finding the Most Visited Sequence**: Identify which 3-sequence is visited by the highest number of unique users, and amongst ties, choose the lexicographically smallest sequence.

Here is a Python implementation adhering to the outlined steps:



```python
from collections import defaultdict
from itertools import combinations

class Solution:
    def mostVisitedPattern(self, username, timestamp, website):
        # Step 1: Aggregate visits by user
        user_visits = defaultdict(list)
        for user, time, site in zip(username, timestamp, website):
            user_visits[user].append((time, site))
        
        # Step 2: Sort each user's visits by timestamp
        for user in user_visits:
            user_visits[user].sort()
        
        # Step 3: Count sequences across all users
        sequence_count = defaultdict(set)  # set to track unique users
        for user, visits in user_visits.items():
            if len(visits) < 3:
                continue
            # Generate all 3-combinations of visited websites in order
            all_combinations = combinations([site for _, site in visits], 3)
            seen_combinations = set()
            for combo in all_combinations:
                if combo not in seen_combinations:
                    sequence_count[combo].add(user)
                    seen_combinations.add(combo)
        
        # Step 4 and 5: Finding the most visited pattern
        most_visited = []
        max_count = 0
        for sequence, users in sequence_count.items():
            # count how many unique users visited the sequence
            count = len(users)
            if count > max_count:
                max_count = count
                most_visited = sequence
            elif count == max_count:
                if list(sequence) < list(most_visited):
                    most_visited = sequence
        
        return list(most_visited)

# Example usage:
solution = Solution()
username = ["joe","joe","joe","james","james","james","james","mary","mary","mary"]
timestamp = [1,2,3,4,5,6,7,8,9,10]
website = ["home","about","career","home","cart","maps","home","home","about","career"]
print(solution.mostVisitedPattern(username, timestamp, website))

```

This script defines the `Solution` class with the method `mostVisitedPattern`, which accepts the lists `username`, `timestamp`, and `website`. The method follows the procedure outlined and returns the most visited 3-sequence in the desired format. The sample usage demonstrates running the provided example, yielding the output `["home", "about", "career"]`, which is the expected result.

# 1157. Online Majority Element In Subarray

### Problem Description 
Implementing the class `MajorityChecker`, which has the following API:
`MajorityChecker(int[] arr)` constructs an instance of MajorityChecker with the given array `arr`;
`int query(int left, int right, int threshold)` has arguments such that:
	
`0 <= left <= right < arr.length` representing a subarray of `arr`;
`2 * threshold > right - left + 1`, ie. the threshold is always a strict majority of the length of the subarray
Each `query(...)` returns the element in `arr[left], arr[left+1], ..., arr[right]` that occurs at least `threshold` times, or `-1` if no such element exists.


Example:
MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);
majorityChecker.query(0,5,4); // returns 1
majorityChecker.query(0,3,3); // returns -1
majorityChecker.query(2,3,2); // returns 2

Constraints:
`1 <= arr.length <= 20000`
`1 <= arr[i] <= 20000`
For each query, `0 <= left <= right < len(arr)`
For each query, `2 * threshold > right - left + 1`
The number of queries is at most `10000`

### Solution 
 To solve the problem, a Python class `MajorityChecker` is implemented with efficient data structures and algorithms, primarily employing the Boyer-Moore Voting Algorithm for fast majority detection in subarrays.

The Boyer-Moore Voting Algorithm identifies a potential majority element by offsetting contributions from other elements, maintaing a candidate and confidence score. If it's correct, any majority element should survive these cancellations in a segment.

Additional query optimizations using a dictionary and range of queries will ensure that frequent repetitive checks are efficient.

Here's the complete implementation of the class, ready to run directly on LeetCode:



```python
from collections import defaultdict

class MajorityChecker:

    def __init__(self, arr):
        self.arr = arr
        # Dictionary to store the indexes of each value
        self.indices = defaultdict(list)
        for i, num in enumerate(arr):
            self.indices[num].append(i)

    def query(self, left, int right, int threshold):
        # A straightforward approach using a dictionary to count occurrences
        # within the specified range optimized with candidate elimination.
        from random import randint
        
        for _ in range(20):  # Trying 20 times to find a majority element randomly
            candidate = self.arr[randint(left, right)]
            l_bound = self.lower_bound(self.indices[candidate], left)
            r_bound = self.upper_bound(self.indices[candidate], right)
            
            if r_bound - l_bound >= threshold:
                return candidate
        
        return -1

    def lower_bound(self, index_list, x):
        """ Binary search helper function to find the lower bound of x in sorted list """
        lo, hi = 0, len(index_list)
        while lo < hi:
            mid = (lo + hi) // 2
            if index_list[mid] < x:
                lo = mid + 1
            else:
                hi = mid
        return lo

    def upper_bound(self, index_list, x):
        """ Binary search helper function to find the upper bound of x in sorted list """
        lo, hi = 0, len(index_list)
        while lo < hi:
            mid = (lo + hi) // 2
            if index_list[mid] <= x:
                lo = mid + 1
            else:
                hi = mid
        return lo

# Your MajorityChecker object will be instantiated and called as such:
# obj = MajorityChecker(arr)
# param_1 = obj.query(left,right,threshold)

```

### Explanation:

1. **Initialization (`__init__`)**:
   - We store the given `arr` and generate a dictionary `self.indices` storing indices of each element appearance for rapid range checks.

2. **Query (`query`)**:
   - To perform the query, Boyer-Moore is implicitly used here by repeatedly picking random elements in the range and rapidly checking if they occur `>= threshold` times via effective index querying using binary search (via the `lower_bound` and `upper_bound` helper functions).

3. **Binary Search Helpers (`lower_bound`, `upper_bound`)**:
   - `lower_bound` and `upper_bound` quickly find the position in the list where a number should be inserted to maintain order, making the counting within a range efficient.

The solution is efficient for up to the given constraints with a reasonable number of queries, assuming an average balanced distribution between queries and number of elements. Repeated confirmations (20 trials) reduce the likelihood of missing a true majority due to randomness.

# 1160. Find Words That Can Be Formed by Characters

### Problem Description 
You are given an array of strings `words` and a string `chars`.

A string is good if it can be formed by characters from `chars` (each character can only be used once).

Return the sum of lengths of all good strings in `words`.


Example 1:
Input: words = ["cat","bt","hat","tree"], chars = "atach"
Output: 6
Explanation: 
The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.


Example 2:
Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
Output: 10
Explanation: 
The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.

Note:
`1 <= words.length <= 1000`
`1 <= words[i].length, chars.length <= 100`
All strings contain lowercase English letters only.

### Solution 
 To solve this problem on LeetCode, we'll follow these steps:

1. Count the frequency of each character in the given string `chars`. This will allow us to quickly look up how many times a character can be used.
2. For each word in `words`, count the frequency of each character and compare it with the frequency in `chars`.
3. Check if for every character in the word, its frequency does not exceed the available frequency in `chars`. If this condition holds, then the word can be formed using `chars`.
4. Sum the lengths of all words that can be formed using `chars`.

By following this approach, our algorithm handles the scenarios effectively where characters need to be reused across multiple words and some characters may be missing in the `chars` string.

Here is the Python code adhering to the LeetCode format:



```python
class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        from collections import Counter
        
        # Count the frequency of each character in 'chars'
        chars_count = Counter(chars)
        total_length = 0

        # Process each word in the list
        for word in words:
            word_count = Counter(word)
            can_form = True

            # Check if the word can be formed with the characters in 'chars'
            for char, count in word_count.items():
                if count > chars_count.get(char, 0):
                    can_form = False
                    break

            # If the word can be formed, add its length to the total length
            if can_form:
                total_length += len(word)

        # Return the sum of lengths of all good strings
        return total_length

# The code can be submitted directly as this in the class definition on LeetCode.

```

This code uses Python's `collections.Counter` to easily count character frequencies in both `chars` and each word in `words`. The decision to add a word's length to the total is based on checking if each character in the word does not exceed its available count in `chars`. This allows the function to operate efficiently within the constraints.

# 1169. Invalid Transactions

### Problem Description 
A transaction is possibly invalid if:
the amount exceeds `$1000`, or;
if it occurs within (and including) `60` minutes of another transaction with the same name in a different city.

You are given an array of strings `transaction` where `transactions[i]` consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.

Return a list of `transactions` that are possibly invalid. You may return the answer in any order.


Example 1:
Input: transactions = ["alice,20,800,mtv","alice,50,100,beijing"]
Output: ["alice,20,800,mtv","alice,50,100,beijing"]
Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.


Example 2:
Input: transactions = ["alice,20,800,mtv","alice,50,1200,mtv"]
Output: ["alice,50,1200,mtv"]

Example 3:
Input: transactions = ["alice,20,800,mtv","bob,50,1200,mtv"]
Output: ["bob,50,1200,mtv"]

Constraints:
`transactions.length <= 1000`
Each `transactions[i]` takes the form `"{name},{time},{amount},{city}"`
Each `{name}` and `{city}` consist of lowercase English letters, and have lengths between `1` and `10`.

Each `{time}` consist of digits, and represent an integer between `0` and `1000`.

Each `{amount}` consist of digits, and represent an integer between `0` and `2000`.

### Solution 
 To solve this problem, we need to identify transactions that are potentially invalid based on the given criteria:
1. The transaction amount exceeds $1000.
2. It occurs within 60 minutes of another transaction with the same name but in a different city.

Given these, we can approach the solution with the following steps:
- Parse each transaction entry to extract the required fields: name, time, amount, and city.
- Store transactions in a dictionary where the key is the transaction name to easily check other transactions by the same person. Each entry in the dictionary should maintain details of the transaction including the index, time, amount, and city.
- Iterate through each transaction and check:
  - If the amount exceeds $1000, mark it as invalid.
  - If another transaction by the same name occurs within 60 minutes at a different city, mark both transactions as invalid.
- Use a set to store indices of invalid transactions to avoid duplicates.
- Convert indices back to the transaction strings to prepare the final output.

Here's the Python code that implements this solution in the required format.



```python
class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        from collections import defaultdict
        transaction_details = defaultdict(list)
        invalid_indices = set()
        
        # Parse transactions and store by name for easy lookup
        for i, transaction in enumerate(transactions):
            name, time, amount, city = transaction.split(',')
            time = int(time)
            amount = int(amount)
            transaction_details[name].append((i, time, amount, city))
        
        # Validate transactions
        for name, details in transaction_details.items():
            details.sort(key=lambda x: x[1])  # Sort by time for easier time window comparison
            for i in range(len(details)):
                idx_current, time_current, amount_current, city_current = details[i]
                
                # Check for amount violation
                if amount_current > 1000:
                    invalid_indices.add(idx_current)
                
                # Check for time and city violation
                for j in range(i + 1, len(details)):
                    idx_other, time_other, _, city_other = details[j]
                    if time_other > time_current + 60:
                        break  # No need to check further as the rest are outside the 60 mins window
                    if city_other != city_current:
                        invalid_indices.add(idx_current)
                        invalid_indices.add(idx_other)
        
        # Prepare output using the invalid indices
        result = []
        for idx in invalid_indices:
            result.append(transactions[idx])
        return result


```

The function `invalidTransactions` is part of a class, assuming a list of strings input for transactions. We utilize default dictionaries and sort operations effectively to find invalid transactions based on conditions. This solution should be efficient enough given the constraints provided.

# 1170. Compare Strings by Frequency of the Smallest Character

### Problem Description 
Let the function `f(s)` be the frequency of the lexicographically smallest character in a non-empty string `s`. For example, if `s = "dcce"` then `f(s) = 2` because the lexicographically smallest character is `'c'`, which has a frequency of 2.

You are given an array of strings `words` and another array of query strings `queries`. For each query `queries[i]`, count the number of words in `words` such that `f(queries[i])` < `f(W)` for each `W` in `words`.

Return an integer array `answer`, where each `answer[i]` is the answer to the `ith` query.


Example 1:
Input: queries = ["cbd"], words = ["zaaaz"]
Output: [1]
Explanation: On the first query we have f("cbd") = 1, f("zaaaz") = 3 so f("cbd") < f("zaaaz").


Example 2:
Input: queries = ["bbb","cc"], words = ["a","aa","aaa","aaaa"]
Output: [1,2]
Explanation: On the first query only f("bbb") < f("aaaa"). On the second query both f("aaa") and f("aaaa") are both > f("cc").


Constraints:
`1 <= queries.length <= 2000`
`1 <= words.length <= 2000`
`1 <= queries[i].length, words[i].length <= 10`
`queries[i][j]`, `words[i][j]` consist of lowercase English letters.

### Solution 
 To solve this problem, we can break the solution into these steps:

1. **Define a Function for Frequency Calculation**:
   Create a helper function `f(s)` that computes the frequency of the smallest character lexicographically in a given string `s`.

2. **Compute Frequencies for all Words**:
   Calculate `f(W)` for all strings `W` in `words` and store these frequencies in a list `frequencies_words`.

3. **Sorting for Efficient Comparison**:
   Sort `frequencies_words` to utilize efficient searching techniques later when comparing with frequencies from `queries`.

4. **Compute Frequency For Each Query and Compare**:
   For each query `queries[i]`, calculate `f(queries[i])`. Count how many elements in the sorted `frequencies_words` are greater than this frequency using binary search. A library like `bisect` can be used to find the appropriate count efficiently.

5. **Store Results for Each Query**:
   Store the count found for each query in a results list and return this list as the final output.

By using a sorted list of `words` frequencies and `bisect` for fast comparison, we can effectively reduce the complexity of comparing each query against all word frequencies individually. This solution scales well given the constraints of the problem.

Here's the implementation:



```python
from typing import List
from collections import Counter
import bisect

class Solution:
    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
        def f(s: str) -> int:
            # We can count letters and return the count of the smallest letter found
            counter = Counter(s)
            smallest_char = min(counter) # getting the lexicographically smallest char
            return counter[smallest_char]
        
        # Calculate f(w) for all words and sort the results
        frequencies_words = sorted(f(w) for w in words)
        
        res = []  # result array
        for query in queries:
            freq_query = f(query)
            # We want to count entries in frequencies_words that are greater than freq_query
            # bisect_right gives us the index of the first element > freq_query
            count = len(frequencies_words) - bisect.bisect_right(frequencies_words, freq_query)
            res.append(count)
        
        return res

# Example usage:
sol = Solution()
print(sol.numSmallerByFrequency(queries=["cbd"], words=["zaaaz"]))  # Output: [1]
print(sol.numSmallerByFrequency(queries=["bbb","cc"], words=["a","aa","aaa","aaaa"]))  # Output: [1,2]

```

This code provides a practical, efficient solution to the problem by using sorting and binary search, conforming to the best practices for competitive programming on platforms like LeetCode.

# 1176. Diet Plan Performance

### Problem Description 
A dieter consumes `calories[i]` calories on the `i`-th day. 
Given an integer `k`, for every consecutive sequence of `k` days (`calories[i], calories[i+1], ..., calories[i+k-1]` for all `0 <= i <= n-k`), they look at T, the total calories consumed during that sequence of `k` days (`calories[i] + calories[i+1] + ... + calories[i+k-1]`):
If `T < lower`, they performed poorly on their diet and lose 1 point; 
If `T > upper`, they performed well on their diet and gain 1 point;
Otherwise, they performed normally and there is no change in points.

Initially, the dieter has zero points. Return the total number of points the dieter has after dieting for `calories.length` days.

Note that the total points can be negative.


Example 1:
Input: calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3
Output: 0
Explanation: Since k = 1, we consider each element of the array separately and compare it to lower and upper.

calories[0] and calories[1] are less than lower so 2 points are lost.

calories[3] and calories[4] are greater than upper so 2 points are gained.


Example 2:
Input: calories = [3,2], k = 2, lower = 0, upper = 1
Output: 1
Explanation: Since k = 2, we consider subarrays of length 2.

calories[0] + calories[1] > upper so 1 point is gained.


Example 3:
Input: calories = [6,5,0,0], k = 2, lower = 1, upper = 5
Output: 0
Explanation:
calories[0] + calories[1] > upper so 1 point is gained.

lower <= calories[1] + calories[2] <= upper so no change in points.

calories[2] + calories[3] < lower so 1 point is lost.


Constraints:
`1 <= k <= calories.length <= 10^5`
`0 <= calories[i] <= 20000`
`0 <= lower <= upper`

### Solution 
 Here is a Python solution for the problem described, formatted to be run directly on the LeetCode platform.



```python
class Solution:
    def dietPlanPerformance(self, calories: List[int], k: int, lower: int, upper: int) -> int:
        n = len(calories)
        points = 0
        current_calories = 0
        
        # Calculate the sum of the first 'k' days
        for i in range(k):
            current_calories += calories[i]
        
        # Initially evaluate the first 'k' days result
        if current_calories < lower:
            points -= 1
        elif current_calories > upper:
            points += 1
        
        # Using sliding window technique to recalculate the sum for subsequent windows
        for i in range(k, n):
            current_calories += calories[i] - calories[i - k]
            if current_calories < lower:
                points -= 1
            elif current_calories > upper:
                points += 1
        
        return points

```

Explanation:
- This code defines a method `dietPlanPerformance` which accepts the list `calories`, integers `k`, `lower`, and `upper`.
- The approach used here is a sliding window technique to calculate the sum of every consecutive `k` days calories efficiently.
- First, we compute the sum of calories for the first `k` days.
- Based on the initial `k` days sum, we update the point count depending on whether the total is less than `lower`, more than `upper`, or in between (in which case, no action is taken).
- For each subsequent day, rather than recalculating the sum from scratch, we adjust the previous window's sum by subtracting the calories that have exited the window (i.e., `calories[i - k]`) and adding the calories that have entered the window (i.e., `calories[i]`). This keeps the time complexity manageable, particularly important given the constraints.
- Then, we again adjust the points based on the updated sum.
- Finally, the total points are returned.

This solution operates in O(n) time complexity, where `n` is the length of the `calories` array, fulfilling the constraints efficiently.

# 1177. Can Make Palindrome from Substring

### Problem Description 
Given a string `s`, we make queries on substrings of `s`.

For each query `queries[i] = [left, right, k]`, we may rearrange the substring `s[left], ..., s[right]`, and then choose up to `k` of them to replace with any lowercase English letter. 
If the substring is possible to be a palindrome string after the operations above, the result of the query is `true`. Otherwise, the result is `false`.

Return an array `answer[]`, where `answer[i]` is the result of the `i`-th query `queries[i]`.

Note that: Each letter is counted individually for replacement so if for example `s[left..right] = "aaa"`, and `k = 2`, we can only replace two of the letters.  (Also, note that the initial string `s` is never modified by any query.)

Example :
Input: s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
Output: [true,false,false,true,true]
Explanation:
queries[0] : substring = "d", is palidrome.

queries[1] : substring = "bc", is not palidrome.

queries[2] : substring = "abcd", is not palidrome after replacing only 1 character.

queries[3] : substring = "abcd", could be changed to "abba" which is palidrome. Also this can be changed to "baab" first rearrange it "bacd" then replace "cd" with "ab".

queries[4] : substring = "abcda", could be changed to "abcba" which is palidrome.


Constraints:
`1 <= s.length, queries.length <= 10^5`
`0 <= queries[i][0] <= queries[i][1] < s.length`
`0 <= queries[i][2] <= s.length`
`s` only contains lowercase English letters.

### Solution 
 To solve the problem of determining if a substring can be transformed into a palindrome with up to `k` replacements, we first need to understand the properties of palindromes:
1. In a palindrome, every character except at most one appears an even number of times.

Given the constraints on `s` length and the number of queries, all up to \(10^5\), we need an efficient solution, possibly \(O(n \log n)\) or \(O(n)\).

We'll approach this problem using:
1. **Prefix Sum Array for Frequency Count:** To efficiently get the frequency of each letter in any substring, we'll use a 2D prefix sum array. `prefix[k][i]` will denote the count of character `chr(k + ord('a'))` up to index `i` in `s`.

2. **Processing each query using the prefix sum array:** For a substring `s[left:right+1]`, utilizing the prefix sum array, the frequency count can be quickly obtained. From there, we'll determine the number of odd-count characters.

3. **Checking palindrome conditions:** Post frequency computation, if the number of characters with odd counts is less than or equal to `2 * k + 1`, where `k` is the number of allowed replacements, then the substring can be reordered into a palindrome (since each replacement can change 1 odd-count character).

Below is the Python code utilizing these concepts:



```python
class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        # Constant for total lowercase letters
        NUM_LETTERS = 26  
        
        # Prefix sum array for alphabet counts
        # To manage easily, we use 1-based indexing for calculation
        prefix = [[0] * (len(s) + 1) for _ in range(NUM_LETTERS)]
        
        # Fill prefix sum array
        for i in range(len(s)):
            for j in range(NUM_LETTERS):
                # We carry forward the previous counts
                prefix[j][i + 1] = prefix[j][i] + (1 if ord(s[i]) == j + ord('a') else 0)
                
        results = []
        
        for left, right, k in queries:
            odd_count = 0
            # Calculate how many characters have an odd frequency in substring s[left:right+1]
            for j in range(NUM_LETTERS):
                count = prefix[j][right + 1] - prefix[j][left]
                if count % 2 == 1:
                    odd_count += 1

            # Check if we can form a palindrome (odd_count // 2 replacements needed at most)
            # If it's possible to replace such that odd count is less than or equal to k
            results.append(odd_count // 2 <= k)
        
        return results

```

This code is structured to work in a LeetCode-compatible format, and it offers an efficient solution to the given problem by preprocessing the string into a frequency counting matrix that enables quick resolution of each query. Each query is processed in \(O(1)\) for frequency retrieval and \(O(26)\) for counting odd occurrences, hence overall \(O(26 * Q)\) where \(Q\) is the number of queries, leading to efficient handling of up to \(10^5\) operations.

# 1184. Distance Between Bus Stops

### Problem Description 
A bus has `n` stops numbered from `0` to `n - 1` that form a circle. We know the distance between all pairs of neighboring stops where `distance[i]` is the distance between the stops number `i` and `(i + 1) % n`.

The bus goes along both directions i.e. clockwise and counterclockwise.

Return the shortest distance between the given `start` and `destination` stops.


Example 1:
Input: distance = [1,2,3,4], start = 0, destination = 1
Output: 1
Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.


Example 2:
Input: distance = [1,2,3,4], start = 0, destination = 2
Output: 3
Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.


Example 3:
Input: distance = [1,2,3,4], start = 0, destination = 3
Output: 4
Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.


Constraints:
`1 <= n <= 10^4`
`distance.length == n`
`0 <= start, destination < n`
`0 <= distance[i] <= 10^4`

### Solution 
 

```python
class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        # Ensure start is always less than destination for easier calculation
        if start > destination:
            start, destination = destination, start
        
        # Calculate the clockwise distance
        clockwise_distance = sum(distance[start:destination])
        
        # Calculate the counterclockwise distance
        counterclockwise_distance = sum(distance) - clockwise_distance
        
        # Return the minimum of the two possible distances
        return min(clockwise_distance, counterclockwise_distance)

# Example usage:
# sol = Solution()
# print(sol.distanceBetweenBusStops([1, 2, 3, 4], 0, 1))  # Output: 1
# print(sol.distanceBetweenBusStops([1, 2, 3, 4], 0, 2))  # Output: 3
# print(sol.distanceBetweenBusStops([1, 2, 3, 4], 0, 3))  # Output: 4

```

### Explanation:
1. **Input Parameters and Preprocessing**: The method `distanceBetweenBusStops` takes `distance` (a list where the ith element represents the distance from stop `i` to stop `(i+1) % n`), `start`, and `destination`. If `start` is greater than `destination`, they are swapped to simplify distance calculation.

2. **Calculate Clockwise Distance**: The clockwise distance from `start` to `destination` is the sum of all distances in the array slice `distance[start:destination]`.

3. **Calculate Counterclockwise Distance**: The counterclockwise distance can be found by subtracting the clockwise distance from the total distance around the circle, which is `sum(distance)`.

4. **Return Result**: The function returns the smaller of the two calculated distances, ensuring the shortest path is chosen.

This solution effectively computes the required distances in two slicing operations and operates under constraints given by the problem, with a time complexity of O(n) primarily due to the sum operations and a space complexity of O(1) since only a few extra variables are used.

# 1185. Day of the Week

### Problem Description 
Given a date, return the corresponding day of the week for that date.

The input is given as three integers representing the `day`, `month` and `year` respectively.

Return the answer as one of the following values `{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}`.


Example 1:
Input: day = 31, month = 8, year = 2019
Output: "Saturday"

Example 2:
Input: day = 18, month = 7, year = 1999
Output: "Sunday"

Example 3:
Input: day = 15, month = 8, year = 1993
Output: "Sunday"

Constraints:
The given dates are valid dates between the years `1971` and `2100`.

### Solution 
 The given problem is to find the day of the week for a date represented by the `day`, `month`, and `year`. Python provides the `datetime` module which includes utilities to handle date and time calculations efficiently, one of which can directly solve our problem.

The `datetime.date(year, month, day).weekday()` function returns the day of the week as an integer, where Monday is 0 and Sunday is 6. Knowing this, we can easily map these integers to the string representations of the days.

Here is a solution following the LeetCode format:



```python
class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        import datetime

        # Create a list to map weekday numbers to day strings
        days_of_week = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
        
        # Create a datetime.date object
        date = datetime.date(year, month, day)
        
        # Get the weekday number using the weekday() method which starts with 0=Monday
        day_index = date.weekday()
        
        # Return the name of the weekday
        return days_of_week[day_index]

# Example usage:
# solver = Solution()
# result = solver.dayOfTheWeek(31, 8, 2019)
# print(result)  # Output: "Saturday"

```

### Explanation:

1. **Importing Module**: The solution first imports the `datetime` module, which allows us to work with dates.

2. **List of Days**: A list `days_of_week` is created to map the day numbers returned by `weekday()` to string names.

3. **Creating Date Object**: A `datetime.date` object is created with the provided year, month, and day.

4. **Getting Day of the Week**: The `weekday()` method of the `date` object returns the day of the week as an integer.

5. **Return the Result**: The function uses the integer returned by `weekday()` to fetch the corresponding day from the `days_of_week` list and return it.

This solution is direct and makes use of Python's built-in capabilities to handle dates and times, providing an efficient and clear method to solve the problem.

# 1200. Minimum Absolute Difference

### Problem Description 
Given an array of distinct integers `arr`, find all pairs of elements with the minimum absolute difference of any two elements. 
Return a list of pairs in ascending order(with respect to pairs), each pair `[a, b]` follows
`a, b` are from `arr`
`a < b`
`b - a` equals to the minimum absolute difference of any two elements in `arr`

Example 1:
Input: arr = [4,2,1,3]
Output: [[1,2],[2,3],[3,4]]
Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.


Example 2:
Input: arr = [1,3,6,10,15]
Output: [[1,3]]

Example 3:
Input: arr = [3,8,-10,23,19,-4,-14,27]
Output: [[-14,-10],[19,23],[23,27]]

Constraints:
`2 <= arr.length <= 10^5`
`-10^6 <= arr[i] <= 10^6`

### Solution 
 To solve this problem, we can leverage the properties of sorted arrays to find the minimum absolute difference between any pair of elements efficiently. Here's the step-by-step approach:

1. **Sort the Array:** Start by sorting the array. The reason for this is that once the array is sorted, the minimum absolute difference will be between some consecutive elements in this sorted array. Sorting takes O(n log n) time, which is efficient enough given the constraints.

2. **Compute Minimum Absolute Difference:** Once the array is sorted, traverse through the array and calculate the differences between consecutive elements to determine the minimum absolute difference.

3. **Collect All Minimum Difference Pairs:** Traverse the sorted array again and collect all pairs of consecutive elements that have this minimum difference.

This approach is efficient, with the main time complexity coming from the sorting step O(n log n), and two linear traversals through the array O(n), resulting in an overall complexity of O(n log n).

Here is the Python code for the given problem:



```python
class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        # Sort the array
        arr.sort()
        
        # Initialize the result list and a large minimum difference
        result = []
        min_difference = float('inf')
        
        # Calculate the smallest difference by comparing consecutive pairs in the sorted list
        for i in range(len(arr) - 1):
            diff = arr[i+1] - arr[i]
            if diff < min_difference:
                # Found a new smaller difference, reset the result list and update min_difference
                min_difference = diff
                result = [[arr[i], arr[i+1]]]
            elif diff == min_difference:
                # Current pair has the same minimum difference, so add to result list
                result.append([arr[i], arr[i+1]])
                
        return result

# Example usage:
sol = Solution()
print(sol.minimumAbsDifference([4,2,1,3]))  # Output: [[1,2],[2,3],[3,4]]
print(sol.minimumAbsDifference([1,3,6,10,15]))  # Output: [[1,3]]
print(sol.minimumAbsDifference([3,8,-10,23,19,-4,-14,27]))  # Output: [[-14,-10],[19,23],[23,27]]

```

This Python class `Solution` contains a method `minimumAbsDifference` that accepts a list of integers and returns a list of pairs representing the pairs with the minimum absolute difference. The usage examples demonstrate the function calls with the test data provided in the prompt.

# 1202. Smallest String With Swaps

### Problem Description 
You are given a string `s`, and an array of pairs of indices in the string `pairs` where `pairs[i] = [a, b]` indicates 2 indices(0-indexed) of the string.

You can swap the characters at any pair of indices in the given `pairs` any number of times.

Return the lexicographically smallest string that `s` can be changed to after using the swaps.


Example 1:
Input: s = "dcab", pairs = [[0,3],[1,2]]
Output: "bacd"
Explaination: 
Swap s[0] and s[3], s = "bcad"
Swap s[1] and s[2], s = "bacd"

Example 2:
Input: s = "dcab", pairs = [[0,3],[1,2],[0,2]]
Output: "abcd"
Explaination: 
Swap s[0] and s[3], s = "bcad"
Swap s[0] and s[2], s = "acbd"
Swap s[1] and s[2], s = "abcd"

Example 3:
Input: s = "cba", pairs = [[0,1],[1,2]]
Output: "abc"
Explaination: 
Swap s[0] and s[1], s = "bca"
Swap s[1] and s[2], s = "bac"
Swap s[0] and s[1], s = "abc"

Constraints:
`1 <= s.length <= 10^5`
`0 <= pairs.length <= 10^5`
`0 <= pairs[i][0], pairs[i][1] < s.length`
`s` only contains lower case English letters.

### Solution 
 This problem can be addressed using a union-find data structure (also known as Disjoint Set Union, DSU) to manage the swappable groups of indices effectively. The main idea is to track the connected components (swappable groups) where each character can be freely swapped within those components. You need to:

1. Initially treat each character index in the string as a separate component.
2. Union the indices in the input pairs to form connected components.
3. For each component, collect all characters residing at those indices, sort them lexicographically, and reassemble them in the component's indices to get the smallest lexicographical order.
4. Construct the resultant string based on these sorted components.

I'll provide a detailed Python solution based on the described concept. Here is the code with comprehensive comments to ensure clarity:



```python
class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        # Union-Find class to manage connected components
        class UnionFind:
            def __init__(self, size):
                self.root = list(range(size))
                self.rank = [1] * size
            
            def find(self, x):
                if self.root[x] != x:
                    self.root[x] = self.find(self.root[x])
                return self.root[x]
            
            def union(self, x, y):
                rootX = self.find(x)
                rootY = self.find(y)
                
                if rootX != rootY:
                    if self.rank[rootX] > self.rank[rootY]:
                        self.root[rootY] = rootX
                    elif self.rank[rootX] < self.rank[rootY]:
                        self.root[rootX] = rootY
                    else:
                        self.root[rootY] = rootX
                        self.rank[rootX] += 1
        
        # Number of characters in the string
        n = len(s)
        
        # Create a Union-Find instance for n elements
        uf = UnionFind(n)
        
        # Apply union operation for each pair, connecting indices
        for a, b in pairs:
            uf.union(a, b)
        
        # Dictionary to store characters by their root index
        from collections import defaultdict
        root_to_chars = defaultdict(list)
        
        # Group characters by their component root index
        for i in range(n):
            root = uf.find(i)
            root_to_chars[root].append(s[i])
        
        # Sort the characters in each component to form lexicographically smallest order
        for chars in root_to_chars.values():
            chars.sort(reverse=True)
        
        # Build the resultant string using the characters in correct order
        result = []
        for i in range(n):
            root = uf.find(i)
            result.append(root_to_chars[root].pop())
        
        return ''.join(result)

```

This Python code is structured to be directly used in a coding challenge environment like LeetCode and performs efficiently by leveraging the union-find data structure for connecting components and dictionary-based mapping for sorting and generating the resultant string. Remember, sorting runs efficiently due to the compact size of individual components compared to the entire string size in a general scenario.

# 1208. Get Equal Substrings Within Budget

### Problem Description 
You are given two strings `s` and `t` of the same length. You want to change `s` to `t`. Changing the `i`-th character of `s` to `i`-th character of `t` costs `|s[i] - t[i]|` that is, the absolute difference between the ASCII values of the characters.

You are also given an integer `maxCost`.

Return the maximum length of a substring of `s` that can be changed to be the same as the corresponding substring of `t`with a cost less than or equal to `maxCost`.

If there is no substring from `s` that can be changed to its corresponding substring from `t`, return `0`.


Example 1:
Input: s = "abcd", t = "bcdf", maxCost = 3
Output: 3
Explanation: "abc" of s can change to "bcd". That costs 3, so the maximum length is 3.


Example 2:
Input: s = "abcd", t = "cdef", maxCost = 3
Output: 1
Explanation: Each character in s costs 2 to change to charactor in `t, so the maximum length is 1.`

Example 3:
Input: s = "abcd", t = "acde", maxCost = 0
Output: 1
Explanation: You can't make any change, so the maximum length is 1.


Constraints:
`1 <= s.length, t.length <= 10^5`
`0 <= maxCost <= 10^6`
`s` and `t` only contain lower case English letters.

### Solution 
 To address this problem, we can utilize the "sliding window" technique to efficiently determine the maximum length substring that can be transformed from `s` to `t` within the allowable cost constraint (`maxCost`). This technique lets us adjust the size and position of the window dynamically based on the cumulative difference in ASCII values between characters of `s` and `t`.

Here is the detailed approach:

1. **Compute Costs:** First, calculate the difference in ASCII values between corresponding characters of `s` and `t`. This gives us an array, `costs`, where each element `costs[i]` represents the cost to change `s[i]` to `t[i]`.

2. **Sliding Window Technique:** Initialize two pointers (`start` and `end`) that represent the boundaries of our sliding window on the input string `s`. Expand the window by advancing the `end` pointer and add the corresponding cost from the `costs` array to a cumulative total (`currentCost`). 

3. **Check Costs Against `maxCost`:** Each time we expand the window by moving the `end` pointer, check if `currentCost` exceeds `maxCost`. If it does, contract the window from the `start` side until the `currentCost` is less than or equal to `maxCost`.

4. **Track Maximum Length:** Throughout the sliding window process, keep track of the maximum length of substrings that can be transformed within the given `maxCost`. This is essentially capturing the maximum length between the `start` and `end` pointers whenever our conditions are satisfied.

5. **Return Result:** The maximum length recorded is our final result.

This method is efficient because it only involves a single pass over the input strings, resulting in a time complexity of O(n), where n is the length of the string. Here is the implementation:



```python
class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        start = 0
        currentCost = 0
        maxLength = 0
        
        # Calculate costs and perform sliding window
        costs = [abs(ord(sc) - ord(tc)) for sc, tc in zip(s, t)]
        
        # Use the sliding window technique
        for end in range(len(s)):
            currentCost += costs[end]
            
            # Check if currentCost exceeds maxCost and adjust the window
            while currentCost > maxCost:
                currentCost -= costs[start]
                start += 1
            
            # Calculate max length
            maxLength = max(maxLength, end - start + 1)
        
        return maxLength

# Examples provided for LeetCode format
# You can test the code with these example cases directly on LeetCode's platform by submitting this code.

```

This solution efficiently handles the maximum substring length calculation by incrementing potential substring lengths whilst ensuring the cost does not exceed `maxCost`, using a practical sliding window approach.

# 1217. Minimum Cost to Move Chips to The Same Position

### Problem Description 
We have `n` chips, where the position of the `ith` chip is `position[i]`.

We need to move all the chips to the same position. In one step, we can change the position of the `ith` chip from `position[i]` to:
`position[i] + 2` or `position[i] - 2` with `cost = 0`.

`position[i] + 1` or `position[i] - 1` with `cost = 1`.

Return the minimum cost needed to move all the chips to the same position.


Example 1:
Input: position = [1,2,3]
Output: 1
Explanation: First step: Move the chip at position 3 to position 1 with cost = 0.

Second step: Move the chip at position 2 to position 1 with cost = 1.

Total cost is 1.


Example 2:
Input: position = [2,2,2,3,3]
Output: 2
Explanation: We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.


Example 3:
Input: position = [1,1000000000]
Output: 1

Constraints:
`1 <= position.length <= 100`
`1 <= position[i] <= 10^9`

### Solution 
 The given problem revolves around moving chips to a single position while minimizing the cost involved. The key observation here is that moving a chip by 2 units (either forward or backward) is free. This makes positions effectively binary in nature where only odd and even categorizations matter:

- Moving from one odd position to another or from one even position to another has no cost.
- Moving from an odd position to an even position or vice versa has a cost.

Thus, the solution only needs to calculate the minimum cost to move all chips either to an odd position or to an even position.

To achieve this:
1. Count the number of chips in odd positions and the number of chips in even positions.
2. The optimal target position for all chips will be:
    - odd positions if there are fewer chips at even positions (as moving to odd is cheaper), or
    - even positions if there are fewer chips at odd positions.
3. The total cost then will be the count of the fewer group (either odd or even), since moving each of those chips will cost 1.

Hereâ€™s the Python code implementing the approach described:



```python
class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        odd_count = 0
        even_count = 0
        
        # Count the number of chips in odd and even positions
        for pos in position:
            if pos % 2 == 0:
                even_count += 1
            else:
                odd_count += 1
        
        # The minimal cost is the number of chips in the minority position (either odd or even)
        # because it's cheaper to move minority to majority if the moving cost between classification is 1.
        return min(odd_count, even_count)


```

Assume the above code is placed in a module where `List` is already imported from the `typing` module (as `from typing import List`). This code counts odd and even positioned chips using a simple iteration over the `position` list. Finally, it returns the count of the fewer group as the minimum cost for positioning all chips at the same spot considering the described movement rules. This is the optimal approach because we don't need to care about the specific positions but only about the parity of positions.

# 1222. Queens That Can Attack the King

### Problem Description 
On an 8x8 chessboard, there can be multiple Black Queens and one White King.

Given an array of integer coordinates `queens` that represents the positions of the Black Queens, and a pair of coordinates `king` that represent the position of the White King, return the coordinates of all the queens (in any order) that can attack the King.


Example 1:
Input: queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
Output: [[0,1],[1,0],[3,3]]
Explanation:  
The queen at [0,1] can attack the king cause they're in the same row. 
The queen at [1,0] can attack the king cause they're in the same column. 
The queen at [3,3] can attack the king cause they're in the same diagnal. 
The queen at [0,4] can't attack the king cause it's blocked by the queen at [0,1]. 
The queen at [4,0] can't attack the king cause it's blocked by the queen at [1,0]. 
The queen at [2,4] can't attack the king cause it's not in the same row/column/diagnal as the king.


Example 2:
Input: queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]
Output: [[2,2],[3,4],[4,4]]

Example 3:
Input: queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]
Output: [[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]

Constraints:
`1 <= queens.length <= 63`
`queens[i].length == 2`
`0 <= queens[i][j] < 8`
`king.length == 2`
`0 <= king[0], king[1] < 8`
At most one piece is allowed in a cell.

### Solution 
 To tackle this problem, we need to determine which queens on the 8x8 chessboard can directly threaten the king based on the rules of chess. A queen threatens another piece if it is in the same row, column, or diagonal and there are no other pieces in between.

### Strategy:

1. **Initialize a Board:** Use a set to record the positions of the queens for faster lookup.

2. **Directions of Movement:** The queen can move in 8 possible directions - vertically up and down, horizontally left and right, and the four diagonals (top-right, top-left, bottom-right, bottom-left).

3. **Check Each Direction:** For each direction, start from the king's position and move step by step. If a queen is encountered, record its position as a threatening queen and stop checking further in that direction (since any further queen would be blocked). If the edge of the board is reached without encountering a queen, just finish that direction.

4. **Output Resulting Queens' Coordinates:** The coordinates of all queens that can attack the king in the described manner.



```python
class Solution:
    def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:
        # Create a set of queen coordinates for O(1) lookups
        queen_set = {(qx, qy) for qx, qy in queens}
        
        result = []
        
        # Eight possible directions vectors
        directions = [
            (-1, 0),  # north
            (1, 0),   # south
            (0, 1),   # east
            (0, -1),  # west
            (-1, -1), # north-west
            (-1, 1),  # north-east
            (1, -1),  # south-west
            (1, 1)    # south-east
        ]
        
        # Check each direction
        for dx, dy in directions:
            x, y = king
            while 0 <= x + dx < 8 and 0 <= y + dy < 8:
                x += dx
                y += dy
                # Check if there is a queen at the current position
                if (x, y) in queen_set:
                    result.append([x, y])
                    break  # Stop this direction as a queen can block further queens
        
        return result


```

### Explanation:

- **Initialization:** Convert the list of queens into a set for fast existence checks.

- **Directions Array:** A list of tuples defining movements in all 8 possible directions a queen can attack.

- **Traversal and Collection:** Use a loop to iterate over all directions, moving from the king's position in the specified direction. Stop if the edge of the board is reached or a queen is found (which then blocks further movement in that direction).

This approach efficiently checks the threat to the king by moving outward from the king until it encounters queens or board edges, making it suitable for the board size and maximum configurations given by the problem constraints.

# 1232. Check If It Is a Straight Line

### Problem Description 
You are given an array `coordinates`, `coordinates[i] = [x, y]`, where `[x, y]` represents the coordinate of a point. Check if these points make a straight line in the XY plane.


Example 1:
Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
Output: true

Example 2:
Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
Output: false

Constraints:
`2 <= coordinates.length <= 1000`
`coordinates[i].length == 2`
`-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4`
`coordinates` contains no duplicate point.

### Solution 
 To solve this problem, we aim to determine if the points in the given list `coordinates` form a straight line in the x-y plane. 

**Approach:**

A straight line in the x-y plane can be determined by checking the slopes between consecutive points. If all the points are indeed on the same line, the slopes between each consecutive pair of points must be the same.

1. **Calculate Slope:** For any two given points \((x_1, y_1)\) and \((x_2, y_2)\), the slope is calculated by the formula:
\[ \text{slope} = \frac{y_2 - y_1}{x_2 - x_1} \]

2. **Check Equal Slope:** To avoid the issues related to floating point arithmetic (division by zero, precision errors), we can use the cross multiplication form to check the slopes equality:
\[ (y_2 - y_1) \times (x_3 - x_2) = (y_3 - y_2) \times (x_2 - x_1) \]
This checks if the slope between points 1 and 2 is the same as the slope between points 2 and 3.

3. **Iterate:** Using a loop, perform the above step for all consecutive pairs of points in the list.

Here's the code:



```python
class Solution:
    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
        # Get differences for the first two points
        x0, y0 = coordinates[0]
        x1, y1 = coordinates[1]
        dx = x1 - x0
        dy = y1 - y0
        
        # Check the condition for all subsequent points
        for i in range(2, len(coordinates)):
            x, y = coordinates[i]
            # Check if the cross product of the vectors differs from 0, which means they are non collinear
            if dx * (y - y1) != dy * (x - x1):
                return False
        
        return True

# We can run this solution directly on LeetCode for the provided test cases

```

This solution efficiently checks if all points lie on the same line without performing actual slope calculations with division, hence it's less prone to precision errors and runs in O(n) time where n is the number of points, adhering to the optimal time complexity for this problem. Each coordinate is accessed a constant number of times, resulting in constant space complexity, O(1), beyond the input storage.

# 1233. Remove Sub-Folders from the Filesystem

### Problem Description 
Given a list of folders, remove all sub-folders in those folders and return in any order the folders after removing.

If a `folder[i]` is located within another `folder[j]`, it is called a sub-folder of it.

The format of a path is one or more concatenated strings of the form: `/` followed by one or more lowercase English letters. For example, `/leetcode` and `/leetcode/problems` are valid paths while an empty string and `/` are not.


Example 1:
Input: folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
Output: ["/a","/c/d","/c/f"]
Explanation: Folders "/a/b/" is a subfolder of "/a" and "/c/d/e" is inside of folder "/c/d" in our filesystem.


Example 2:
Input: folder = ["/a","/a/b/c","/a/b/d"]
Output: ["/a"]
Explanation: Folders "/a/b/c" and "/a/b/d/" will be removed because they are subfolders of "/a".


Example 3:
Input: folder = ["/a/b/c","/a/b/ca","/a/b/d"]
Output: ["/a/b/c","/a/b/ca","/a/b/d"]

Constraints:
`1 <= folder.length <= 4 * 10^4`
`2 <= folder[i].length <= 100`
`folder[i]` contains only lowercase letters and '/'
`folder[i]` always starts with character '/'
Each folder name is unique.

### Solution 
 To solve this problem in LeetCode format, we need to ensure the solution is efficient given the constraints on the number of folders and the length of each path.

### Solution Approach
1. **Sorting**: First sort the list of folders. This makes subfolder relations easier to identify because any potential subfolder would appear directly after its parent folder in the sorted order.
2. **Using Prefix Match**: By iterating through the sorted list of folders:
   - Check each folder against the last valid folder added to the resulting list.
   - If the current folder is a subfolder of the last added folder (checked using prefix matching and ensuring `/` delimiter), skip adding it to the result.
   - Otherwise, add the current folder to the result.
3. **Return Result**: The list constructed this way will contain only folders without their subfolders.

Now, with the idea in mind, let's translate this approach into Python code with a proper function signature to be executed on LeetCode.



```python
class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        folder.sort()
        res = []

        # Start with the first folder in the sorted list
        prev = folder[0]
        res.append(prev)
        
        # Iterate over the remaining folders
        for f in folder[1:]:
            # To ensure f is not a subfolder of the last appended folder `prev`
            # It should not start with `prev + '/'` pattern
            if not f.startswith(prev + '/'):
                res.append(f)
                prev = f  # Update previous valid folder
        
        return res

# Example usage (this part won't be included during LeetCode submission):
# sol = Solution()
# print(sol.removeSubfolders(["/a","/a/b","/c/d","/c/d/e","/c/f"]))  # Output: ["/a", "/c/d", "/c/f"]
# print(sol.removeSubfolders(["/a","/a/b/c","/a/b/d"]))  # Output: ["/a"]
# print(sol.removeSubfolders(["/a/b/c","/a/b/ca","/a/b/d"]))  # Output: ["/a/b/c", "/a/b/ca", "/a/b/d"]

```

### Explanation of Sample Runs

- **Example 1**: Input `["/a","/a/b","/c/d","/c/d/e","/c/f"]`
  - Sorted: `["/a", "/a/b", "/c/d", "/c/d/e", "/c/f"]`
  - Output: For `/a`, any folder path starting with `/a/` is a subfolder and is therefore eliminated. Similar logic applies to `/c/d`.
- **Example 2**: Input `["/a","/a/b/d","/a/b/c"]`
  - Sorted and processed similarly; all under `/a` are removed.

### Efficiency
Given the bounds of the constraints, sorting will take \(O(N \log N)\) time, and the check operation in the main loop runs in \(O(1)\) average time for each folder, making the solution efficient given the problem constraints.

# 1243. Array Transformation

### Problem Description 
Given an initial array `arr`, every day you produce a new array using the array of the previous day.

On the `i`-th day, you do the following operations on the array of day `i-1` to produce the array of day `i`:
If an element is smaller than both its left neighbor and its right neighbor, then this element is incremented.

If an element is bigger than both its left neighbor and its right neighbor, then this element is decremented.

The first and last elements never change.

After some days, the array does not change. Return that final array.


Example 1:
Input: arr = [6,2,3,4]
Output: [6,3,3,4]
Explanation: 
On the first day, the array is changed from [6,2,3,4] to [6,3,3,4].

No more operations can be done to this array.


Example 2:
Input: arr = [1,6,3,4,3,5]
Output: [1,4,4,4,4,5]
Explanation: 
On the first day, the array is changed from [1,6,3,4,3,5] to [1,5,4,3,4,5].

On the second day, the array is changed from [1,5,4,3,4,5] to [1,4,4,4,4,5].

No more operations can be done to this array.


Constraints:
`3 <= arr.length <= 100`
`1 <= arr[i] <= 100`

### Solution 
 

```python
class Solution:
    def transformArray(self, arr: List[int]) -> List[int]:
        # We need to make a copy of the array because we will be modifying it in-place
        # but we need references to the original values
        while True:
            changes = False
            new_arr = arr[:]
            for i in range(1, len(arr) - 1):
                if arr[i] < arr[i - 1] and arr[i] < arr[i + 1]:
                    new_arr[i] += 1
                    changes = True
                elif arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:
                    new_arr[i] -= 1
                    changes = True
            arr = new_arr
            # If no changes were made in the last pass, the array is stable and we can exit
            if not changes:
                break
        return arr

# As per the conventions of LeetCode solutions, the necessary imports and base structure would be provided,
# and you would only supply the logic inside the `RangeFreqQuery` class.

```

### Explanation:

The `Solution` class implements a function `transformArray`, which takes an array `arr` and returns a transformed array when no more transformations are possible.

1. **Copy of Original Array**:
    - An initial copy of `arr` called `new_arr` is made to be used in the transformation process, to avoid modifying the array that is being checked.
  
2. **Iterative Transformation**:
    - The process potentially loops until there are no more changes to be made. This uses a flag variable `changes` initialized to `False` at the start of the loop.

3. **Conditions for Modification**:
    - Inside the loop, every element (except the first and last) is checked:
        - **Increment**: If an element is smaller than both neighbors, it is incremented.
        - **Decrement**: If an element is greater than both neighbors, it is decremented.
    - If any change is made (`changes` is set to `True`), the process continues.

4. **Stable State**:
    - If a complete iteration happens without any adjustments (i.e., `changes` is `False` after the loop), the array is considered stable, and the loop breaks.

5. **Output**:
    - Finally, the stable array `arr` is returned.

This approach effectively handles the simulation of day-by-day transformations and stops as soon as a stable state (an unchanged array from one day to the next) is reached. The constraints are manageable given the known range sizes, making the transformation feasible within a reasonable time frame.

# 1260. Shift 2D Grid

### Problem Description 
Given a 2D `grid` of size `m x n` and an integer `k`. You need to shift the `grid` `k` times.

In one shift operation:
Element at `grid[i][j]` moves to `grid[i][j + 1]`.

Element at `grid[i][n - 1]` moves to `grid[i + 1][0]`.

Element at `grid[m - 1][n - 1]` moves to `grid[0][0]`.

Return the 2D grid after applying shift operation `k` times.


Example 1:
Input: `grid` = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[9,1,2],[3,4,5],[6,7,8]]

Example 2:
Input: `grid` = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]

Example 3:
Input: `grid` = [[1,2,3],[4,5,6],[7,8,9]], k = 9
Output: [[1,2,3],[4,5,6],[7,8,9]]

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m <= 50`
`1 <= n <= 50`
`-1000 <= grid[i][j] <= 1000`
`0 <= k <= 100`

### Solution 
 Below is a Python solution to the described grid shifting problem, formatted for submission to LeetCode:



```python
class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        # Reduce k since every m*n shifts bring the grid back to the original configuration
        k = k % (m * n)
        
        # Convert to 1D list to simplify rotation.
        # Flatten the grid row-wise using list comprehension
        flat_list = [grid[i][j] for i in range(m) for j in range(n)]
        
        # Rotate the list by k elements using slicing
        flat_list = flat_list[-k:] + flat_list[:-k]
        
        # Convert back to grid
        new_grid = []
        for i in range(m):
            row = []
            for j in range(n):
                row.append(flat_list[i * n + j])
            new_grid.append(row)
        
        return new_grid

# Example usage:
# sol = Solution()
# grid = [[1,2,3],[4,5,6],[7,8,9]]
# k = 1
# print(sol.shiftGrid(grid, k))  # Output: [[9,1,2],[3,4,5],[6,7,8]]

```

### Explanation:

1. **Reduce k**: If k is large, many shifts will result in returning to the original layout of the grid. To optimize, we use `k = k % (m * n)`, where `m * n` is the total number of elements in the grid.

2. **Flatten the 2D Grid**: We convert the 2D grid into a 1D list (`flat_list`) to manage the elements more straightforwardly.

3. **Rotate the List**: We perform the rotation by taking the last `k` elements to the front of the list, using slicing: `flat_list[-k:] + flat_list[:-k]`.

4. **Reshape into 2D Grid**: Convert the rotated 1D list back to a 2D grid with dimensions `m x n`.

This solution ensures efficiency in terms of time complexity, being generally O(m*n) due to list operations. The space complexity is also O(m*n) because of storing the flattened list and the new grid. Note that `k` influences only preprocessing to determine the effective number of shifts; the list operations remain constant with respect to `k`.

