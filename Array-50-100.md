# 153. Find Minimum in Rotated Sorted Array

### Problem Description 
Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:
`[4,5,6,7,0,1,2]` if it was rotated `4` times.

`[0,1,2,4,5,6,7]` if it was rotated `7` times.

Notice that rotating an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of unique elements, return the minimum element of this array.


Example 1:
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.


Example 2:
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.


Example 3:
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 

Constraints:
`n == nums.length`
`1 <= n <= 5000`
`-5000 <= nums[i] <= 5000`
All the integers of `nums` are unique.

`nums` is sorted and rotated between `1` and `n` times.

### Solution 
 To solve the problem of finding the minimum element in a rotated sorted array, a binary search approach can be highly effective. Here's why and how it works:

### Reasoning:
1. **Rotated Sorted Array**: The array, though rotated, retains sorted order in its segments. For example, in `[4, 5, 6, 7, 0, 1, 2]` both `[4, 5, 6, 7]` and `[0, 1, 2]` are sorted.
2. **Binary Search Adaptation**: By comparing elements at mid point with the rightmost (or leftmost) element, we can determine which half is normally sorted. The minimum element will be in the unsorted half or might be the point of change between sorted and unsorted halves.

### Algorithm:
1. Start with two pointers pointing at the beginning (`left`) and end (`right`) of the array.
2. While the `left` pointer is less than `right`:
   - Find the `mid` index.
   - If element at `mid` is greater than element at `right`, it means the smallest value is to the right of `mid`. Hence, set `left` to `mid + 1`.
   - Otherwise, it means the segment from `left` to `mid` is sorted and the minimum lies within this segment or at `mid`, set `right` to `mid`.
3. Continue the loop until `left` equals `right`.
4. The answer is at the index pointed by `left` (or `right` since they are the same at the end).

### Implementation:

Below is the Python code corresponding to the explained solution, formatted in the typical manner for a submission to LeetCode:



```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            else:
                right = mid
        
        return nums[left]

```

### Explanation:
- **Edge Cases**: The algorithm works for arrays of any size (within the problem constraints), including the minimum size of 1.
- **Time Complexity**: O(log n) due to the binary search approach.
- **Space Complexity**: O(1) since no extra space relative to the input size is used.

The provided solution should fit directly into the LeetCode environment, owing to the definition being encapsulated within the `Solution` class and the usage of LeetCode's `List[int]` type hint for the parameter.

# 154. Find Minimum in Rotated Sorted Array II

### Problem Description 
Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:
`[4,5,6,7,0,1,4]` if it was rotated `4` times.

`[0,1,4,4,5,6,7]` if it was rotated `7` times.

Notice that rotating an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` that may contain duplicates, return the minimum element of this array.


Example 1:
Input: nums = [1,3,5]
Output: 1

Example 2:
Input: nums = [2,2,2,0,1]
Output: 0

Constraints:
`n == nums.length`
`1 <= n <= 5000`
`-5000 <= nums[i] <= 5000`
`nums` is sorted and rotated between `1` and `n` times.

Follow up: This is the same as Find Minimum in Rotated Sorted Array but with duplicates. Would allow duplicates affect the run-time complexity? How and why?

### Solution 
 Here is the Python code using the binary search technique to find the minimum element in a rotated sorted array which may contain duplicates. The presence of duplicates means that certain edge cases like completely uniform arrays or arrays where the breakpoint is blurred by repeated elements need special consideration. The solution below is written to be executable directly on the LeetCode platform.



```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        if not nums:
            return None
        
        low, high = 0, len(nums) - 1
        
        while low < high:
            mid = (low + high) // 2
            
            # If element at mid is greater than element at high, min must be to the right of mid
            if nums[mid] > nums[high]:
                low = mid + 1
            # If element at mid is less than element at high, min must be at mid or to the left of mid
            elif nums[mid] < nums[high]:
                high = mid
            else:  # nums[mid] == nums[high]
                # If middle and high are the same, we can't be sure of the position of minimum,
                # but we can reduce high by one to move closer to a potential breakpoint
                if high != low:
                    high -= 1
        
        return nums[low]

# Examples to run the solution:
# sol = Solution()
# print(sol.findMin([2,2,2,0,1]))  # Output: 0
# print(sol.findMin([1,3,5]))  # Output: 1

```
### Explanation:

1. **Initialization of pointers:** The method starts by setting two pointers, `low` and `high`, pointing to the beginning and the end of the array respectively.

2. **Binary Search Loop:** The loop continues until `low` is less than `high`. This loop will contract the search range:
   - **Middle Element Calculation:** `mid` is calculated as the midpoint between `low` and `high`.
   - **Case Analysis based on Middle Element:**
       - If `nums[mid] > nums[high]`, then the minimum value must be to the right of `mid`, so move `low` to `mid + 1`.
       - If `nums[mid] < nums[high]`, then the minimum value could be at `mid` (or to its left), so we set `high` to `mid`.
       - If `nums[mid] == nums[high]`, there's an ambiguity due to possible duplicates. By decrementing `high`, we safely approach the potential minimum without skipping it.

3. **Return the minimum:** After exiting the loop, `low` should be pointing to the minimum element, so `nums[low]` is returned.

### Follow-up Discussion:

- **Impact of Duplicates:** The presence of duplicates affects the run-time complexity because it prevents us from confidently eliminating one half of the search space when the elements at mid and high indices are the same. This leads to the worst-case time complexity degrading to O(n) in cases where decrementing `high` repeatedly is necessary (i.e., when most of the array contains the same element).

This solution works effectively for finding the minimum in a binary search fashion, even in the presence of duplicates, ensuring the implementation is concise and efficient given the constraints.

# 162. Find Peak Element

### Problem Description 
A peak element is an element that is strictly greater than its neighbors.

Given an integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that `nums[-1] = nums[n] = -âˆž`.


Example 1:
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.


Example 2:
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.


Constraints:
`1 <= nums.length <= 1000`
`-231 <= nums[i] <= 231 - 1`
`nums[i] != nums[i + 1]` for all valid `i`.

Follow up: Could you implement a solution with logarithmic complexity?

### Solution 
 To solve the problem of finding a peak element in an array, we can leverage a binary search method to achieve logarithmic complexity, i.e., O(log n). 

### Explanation:
1. **Binary Search Insight**: Since the array values are distinct and considered to extend to negative infinity at both ends, every peak forms when the array stops ascending and starts descending. Thus, if the middle element of a subarray is greater than the next element, the peak must be to the left (including the middle element); otherwise, it must be towards the right.

2. **Algorithm**:
   - Initialize the search space from the beginning to the end of the array.
   - While the search space has more than one element:
     - Find the middle of the search space.
     - If the element at the middle is less than the next element, it means a peak is to the right, so move the left boundary of the search space to the middle + 1.
     - Otherwise, move the right boundary to the middle because the peak can be at middle or to its left.
   - The loop exits when the search space reduces to one element, the index of which is returned since it is a peak due to how the search space was narrowed.

### Python Code:


```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < nums[mid + 1]:
                left = mid + 1
            else:
                right = mid
                
        return left


```

### Testing the Code:
When tested with the examples provided:

- **Example 1**: `nums = [1,2,3,1]`
  - The binary search will correctly identify index `2` as the peak element since `3` is greater than both its neighbors.
- **Example 2**: `nums = [1,2,1,3,5,6,4]`
  - Depending on the progression of the binary search cuts, index `1` (where `2` is a peak) or index `5` (where `6` is peak) can be valid outputs.

This solution efficiently identifies a peak element in O(log n) time by using a binary search method tailored to the properties of the problem statement.

# 163. Missing Ranges

### Problem Description 
You are given an inclusive range `[lower, upper]` and a sorted unique integer array `nums`, where all elements are in the inclusive range.

A number `x` is considered missing if `x` is in the range `[lower, upper]` and `x` is not in `nums`.

Return the smallest sorted list of ranges that cover every missing number exactly. That is, no element of `nums` is in any of the ranges, and each missing number is in one of the ranges.

Each range `[a,b]` in the list should be output as:
`"a->b"` if `a != b`
`"a"` if `a == b`

Example 1:
Input: nums = [0,1,3,50,75], lower = 0, upper = 99
Output: ["2","4->49","51->74","76->99"]
Explanation: The ranges are:
[2,2] --> "2"
[4,49] --> "4->49"
[51,74] --> "51->74"
[76,99] --> "76->99"

Example 2:
Input: nums = [], lower = 1, upper = 1
Output: ["1"]
Explanation: The only missing range is [1,1], which becomes "1".


Example 3:
Input: nums = [], lower = -3, upper = -1
Output: ["-3->-1"]
Explanation: The only missing range is [-3,-1], which becomes "-3->-1".


Example 4:
Input: nums = [-1], lower = -1, upper = -1
Output: []
Explanation: There are no missing ranges since there are no missing numbers.


Example 5:
Input: nums = [-1], lower = -2, upper = -1
Output: ["-2"]

Constraints:
`-109 <= lower <= upper <= 109`
`0 <= nums.length <= 100`
`lower <= nums[i] <= upper`
All the values of `nums` are unique.

### Solution 
 Here's a Python code implementation for the missing ranges problem, tailored to fit into the style suitable for submission on LeetCode. Below the code, I will provide a detailed explanation of how this code works.

### Python Code:



```python
class Solution:
    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[str]:
        # Helper function to format the range to string
        def formatRange(low, high):
            if low == high:
                return str(low)
            else:
                return "{}->{}".format(low, high)
        
        result = []
        prev = lower - 1  # Starting point is one less than the lower to manage the edge case

        for num in nums + [upper + 1]:  # Including upper + 1 to manage the last range
            if num == prev + 2:  # There is exactly one number missing
                result.append(str(prev + 1))
            elif num > prev + 2:  # There is a range of numbers missing
                result.append(formatRange(prev + 1, num - 1))
            
            prev = num  # Update the prev number to current
        
        return result

```

### Explanation:

1. **Helper Function `formatRange`**:
   - This function is used for formatting the output string. If the two ends of the range are the same (`low == high`), it simply returns the single number as a string. If they are different, the function returns the range in the special format (`"a->b"`).

2. **Initialization**:
   - `result` is initialized as an empty list where we will append all missing ranges.
   - `prev` is initialized to `lower - 1`. This trick simplifies the handling of the first missing range. It is as though we have an imaginary number right before the `lower` bound which helps us manage the edge case naturally within the loop.

3. **Iterating Through the Array**:
   - We loop through `nums` with an addition of `upper + 1` at the end (`nums + [upper + 1]`). The `upper + 1` helps manage the last missing range ending at `upper`.
   - For each `num` in this modified array:
     - If `num` is exactly `prev + 2`, it means there is exactly one number missing, which is `prev + 1`.
     - If `num` is greater than `prev + 2`, there's a range of numbers missing from `prev + 1` to `num - 1`. 
   - After processing each number, we update `prev` to `num`.

4. **Output**:
   - The result list, which collects all the formatted ranges or single numbers, is returned at the end of the function.

This solution is intuitive and efficient, especially considering that the constraints of the problem allow this approach to be highly effective without performance concerns.

# 167. Two Sum II - Input array is sorted

### Problem Description 
Given an array of integers `numbers` that is already sorted in ascending order, find two numbers such that they add up to a specific `target` number.

Return the indices of the two numbers (1-indexed) as an integer array `answer` of size `2`, where `1 <= answer[0] < answer[1] <= numbers.length`.

You may assume that each input would have exactly one solution and you may not use the same element twice.


Example 1:
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.


Example 2:
Input: numbers = [2,3,4], target = 6
Output: [1,3]

Example 3:
Input: numbers = [-1,0], target = -1
Output: [1,2]

Constraints:
`2 <= numbers.length <= 3 * 104`
`-1000 <= numbers[i] <= 1000`
`numbers` is sorted in increasing order.

`-1000 <= target <= 1000`
Only one valid answer exists.

### Solution 
 Here's a Python solution utilizing the two-pointer technique which is well-suited for the problem because the list is sorted. The two-pointer approach works as follows:

1. Initialize two pointers, one pointing at the start (`left`) and the other at the end (`right`) of the array.
2. Calculate the sum of the elements at these two pointers.
3. If the sum is equal to the target, return these indices (adjusted for 1-based index).
4. If the sum is less than the target, move the `left` pointer to the right to increase the sum.
5. If the sum is more than the target, move the `right` pointer to the left to decrease the sum.
6. Repeat until the solution is found.

This approach is efficient for sorted arrays and operates in `O(n)` time complexity with `O(1)` extra space. Here's how you can implement it:



```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, len(numbers) - 1
        while left < right:
            current_sum = numbers[left] + numbers[right]
            if current_sum == target:
                return [left + 1, right + 1]
            elif current_sum < target:
                left += 1
            else:
                right -= 1
        return []

```

### Explanation:

- `left` starts from the beginning of the list (index 0) and `right` from the end (index `len(numbers) - 1`).
- We enter a loop that continues until `left` is less than `right`.
- In each iteration, we calculate `current_sum` using the values pointed to by `left` and `right`.
- If `current_sum` matches the `target`, return the indices `[left + 1, right + 1]` (converted to 1-based index).
- If `current_sum` is less than the `target`, increment `left` to try a larger sum.
- If `current_sum` is greater, decrement `right` to try a smaller sum.
- If no pair is found (though the problem statement guarantees one solution), the outer loop ends and returns an empty list.

This code can be run directly on the LeetCode website by copying and pasting into their code editor. It efficiently handles the searching for two elements summing to a target using a linear scan facilitated by the two-pointer technique, leveraging the property of the sorted array.


# 169. Majority Element

### Problem Description 
Given an array `nums` of size `n`, return the majority element.

The majority element is the element that appears more than `âŒŠn / 2âŒ‹` times. You may assume that the majority element always exists in the array.


Example 1:
Input: nums = [3,2,3]
Output: 3

Example 2:
Input: nums = [2,2,1,1,1,2,2]
Output: 2

Constraints:
`n == nums.length`
`1 <= n <= 5 * 104`
`-231 <= nums[i] <= 231 - 1`
Follow-up: Could you solve the problem in linear time and in `O(1)` space?

### Solution 
 To solve this problem, you can use the Boyer-Moore Voting Algorithm, which is well-suited for finding the majority element that appears more than âŒŠn / 2âŒ‹ times in an array. The algorithm runs in linear time (O(n)) and uses constant space (O(1)). The steps are as follows:

1. Initialize two variables: `candidate` to store the potential majority element and `count` to count the occurrences of this `candidate`.
2. Iterate through the array `nums`. For each element:
   - If `count` is 0, set `candidate` to the current element.
   - If the current element is the same as `candidate`, increment `count`.
   - Otherwise, decrement `count`.
3. Since the majority element always exists in the array, by the end of the iteration, `candidate` will be the majority element.

Here is the Python code targeting the LeetCode problem format:



```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        candidate = None
        count = 0
        
        for num in nums:
            if count == 0:
                candidate = num
            count += 1 if num == candidate else -1
        
        return candidate
        
# Example usage
sol = Solution()
print(sol.majorityElement([3,2,3]))  # Output: 3
print(sol.majorityElement([2,2,1,1,1,2,2]))  # Output: 2

```

This code snippet defines a class `Solution` as typically structured for LeetCode solutions. The method `majorityElement` handles the logic for finding the majority element using the Boyer-Moore Voting Algorithm. By iterating over the list once, we achieve O(n) time complexity, and since we only need a few variables to store the candidate and the count, we also achieve O(1) space complexity. 

Ensure that when you run this code, it is under an environment that supports Python, which includes an import statement for the type hint (`List`), like:


```python
from typing import List

```

# 189. Rotate Array

### Problem Description 
Given an array, rotate the array to the right by `k` steps, where `k` is non-negative.


Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]

Example 2:
Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]

Constraints:
`1 <= nums.length <= 2 * 104`
`-231 <= nums[i] <= 231 - 1`
`0 <= k <= 105`
Follow up:
Try to come up with as many solutions as you can. There are at least three different ways to solve this problem.

Could you do it in-place with `O(1)` extra space?

### Solution 
 To solve the problem of rotating an array to the right by `k` steps on LeetCode, an efficient approach is essential due to the large potential input sizes and constraint conditions.

Let's consider the most space-efficient method that utilizes `O(1)` extra space since this is generally most optimal for large data. This approach involves reversing segments of the array and can be done in-place.

### Explanation of the Approach:
1. **Normalize `k`**: First, we reduce `k` by taking `k % len(nums)`, because rotating the array by its length or multiples doesn't change the array.
2. **Reversal Method**:
    - Reverse the entire array.
    - Reverse the first `k` elements.
    - Reverse the remaining elements from index `k` to end.
   
   This approach intuitively moves the last `k` elements to the front while preserving the order of both the moved elements and the other part of the array.

### Python Code:



```python
class Solution:
    def rotate(self, nums, k):
        n = len(nums)
        k = k % n
        
        def reverse(start, end):
            while start < end:
                nums[start], nums[end] = nums[end], nums[start]
                start, end = start + 1, end - 1
        
        # Reverse the whole array
        reverse(0, n - 1)
        # Reverse the first k elements
        reverse(0, k - 1)
        # Reverse the rest
        reverse(k, n - 1)

        
# Example usage:
sol = Solution()
nums1 = [1,2,3,4,5,6,7]
sol.rotate(nums1, 3)
print(nums1)  # Output: [5, 6, 7, 1, 2, 3, 4]

nums2 = [-1,-100,3,99]
sol.rotate(nums2, 2)
print(nums2)  # Output: [3, 99, -1, -100]

```

### Detailed Walkthrough for Example 1:
- Input: `nums = [1,2,3,4,5,6,7]`, `k = 3`
- Normalized `k` will be `3 % 7 = 3`
- Reverse entire array: `[7,6,5,4,3,2,1]`
- Reverse first 3 elements: `[5,6,7,4,3,2,1]`
- Reverse the rest: `[5,6,7,1,2,3,4]`

This approach leverages reverse operations to achieve an in-place rotation of the array with a time complexity of \(O(n)\) and space complexity of \(O(1)\), which is optimal given the problem constraints.

# 209. Minimum Size Subarray Sum

### Problem Description 
Given an array of positive integers `nums` and a positive integer `target`, return the minimal length of a contiguous subarray `[numsl, numsl+1, ..., numsr-1, numsr]` of which the sum is greater than or equal to `target`. If there is no such subarray, return `0` instead.


Example 1:
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.


Example 2:
Input: target = 4, nums = [1,4,4]
Output: 1

Example 3:
Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0

Constraints:
`1 <= target <= 109`
`1 <= nums.length <= 105`
`1 <= nums[i] <= 105`
Follow up: If you have figured out the `O(n)` solution, try coding another solution of which the time complexity is `O(n log(n))`.

### Solution 
 The optimal approach to solving this problem is to use the sliding window technique, which is an `O(n)` solution. In this technique, we utilize two pointers to create a window which can expand and contract as needed. As we iterate through the array with the right pointer (extending the window), we calculate the sum of the elements within the window and compare it with the target. If the current window's sum is at least the target, we try to reduce the size of the window by moving the left pointer towards the right to find the minimal length of such a window that meets the conditions.

Here's step-by-step guidance:

1. Initialize two pointers, `start` and `end`, both set to the beginning of the list.
2. Maintain a running sum of the elements within the window defined by `start` and `end`.
3. Expand the window by moving `end` until the sum of the window is equal to or exceeds `target`.
4. Once you have a valid window (where sum is greater than or equal to `target`), try to contract the window from the left by moving the `start` pointer towards the right to minimize the window size while still keeping the sum â‰¥ `target`.
5. Keep track of the minimum size of such windows throughout the process.
6. Return the minimum length if found; otherwise, return 0 if no valid subarray exists.

Below is the implementation using this approach:



```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        min_length = float('inf')  # Use inf to handle cases where no valid subarray is found
        current_sum = 0
        start = 0
        
        for end in range(n):
            current_sum += nums[end]  # Expand the window by including the current element
            
            # Contract the window from the left until the sum is < target
            while current_sum >= target:
                min_length = min(min_length, end - start + 1)
                current_sum -= nums[start]
                start += 1
        
        # If min_length is still inf, it means no valid subarray was found
        return min_length if min_length != float('inf') else 0

```

Explanation of the above code:
- `min_length` keeps track of the minimum length of subarrays found that meet the condition. Initially set to `inf` to basically compare with any length we find.
- `current_sum` maintains the sum of the current window between `start` and `end`.
- Loop through the array to expand the window. If a valid subarray sum is found (`current_sum >= target`), try contracting the window from the `start` to see if a smaller subarray also meets the condition.
- If no subarray meets the condition returning 0, otherwise, return the smallest length found. 

This solution effectively iterates over the list a maximum of two times (once by `end` and potentially once by `start`), leading to an `O(n)` time complexity, which is both time-efficient and space-efficient (O(1) space complexity) for large inputs.

# 216. Combination Sum III

### Problem Description 
Find all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true:
Only numbers `1` through `9` are used.

Each number is used at most once.

Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.


Example 1:
Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.


Example 2:
Input: k = 3, n = 9
Output: [[1,2,6],[1,3,5],[2,3,4]]
Explanation:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.


Example 3:
Input: k = 4, n = 1
Output: []
Explanation: There are no valid combinations. [1,2,1] is not valid because 1 is used twice.


Example 4:
Input: k = 3, n = 2
Output: []
Explanation: There are no valid combinations.


Example 5:
Input: k = 9, n = 45
Output: [[1,2,3,4,5,6,7,8,9]]
Explanation:
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45
â€‹â€‹â€‹â€‹â€‹â€‹â€‹There are no other valid combinations.


Constraints:
`2 <= k <= 9`
`1 <= n <= 60`

### Solution 
 To solve this problem, we will use the backtracking approach where we attempt to build the combination of `k` numbers that sum up to `n` using numbers from `1` to `9`. We'll ensure that no number is reused in any particular combination.

**Steps for the approach:**

1. **Initialization:** Start with an empty combination (`combo = []`) and the smallest number (`start = 1`).

2. **Backtracking Function:** This function will attempt to add new numbers to `combo`. For each number from the current `start` to `9`, it will:
    - Add the number to the current combination.
    - Recursively call itself to handle the next number, reducing `n` by the value of the current number and incrementing `start`.
    - If the length of the combination equals `k` and the sum is `n`, add the combination to the result.
    - Backtrack by removing the last added number and trying the next number.
  
3. **Cutoff for Optimization:** 
    - If at any point the sum exceeds `n`, we can prune the remaining subtree of recursive calls, as adding more numbers will only increase the sum.
    - If the combination's length exceeds `k`, stop further exploration.
    
4. **Termination Condition:** When the recursive function has tried all numbers from `1` to `9` and if a valid combination is formed, it adds to the answer list.

5. **Return Result:** After all recursive calls are complete, the result list will contain all valid combinations.

Here's the relevant Python code following LeetCode's required format:



```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        results = []
        
        def backtrack(start, current_combination, current_sum):
            # Edge condition to add the current combination to results
            if len(current_combination) == k and current_sum == n:
                results.append(current_combination.copy())
                return
            
            # If the combination is too long or the sum is too high, no need to continue
            if len(current_combination) > k or current_sum > n:
                return
            
            # Try each number starting from 'start' to 9
            for number in range(start, 10):
                # Avoid duplicates by increasing start for next recursion
                current_combination.append(number)
                backtrack(number + 1, current_combination, current_sum + number)
                current_combination.pop()  # backtrack
        
        # Initial call from number 1
        backtrack(1, [], 0)
        return results

```

This code defines a `Solution` class with a method `combinationSum3` needed by LeetCode. When executed, the method uses the `backtrack` function to explore possible combinations and collects valid ones in `results`. Given the constraints, this method will efficiently find all possible combinations due to both the nature of combination generation (backtracking) and the hardcoded limitation on input numbers (`1` to `9`).

# 217. Contains Duplicate

### Problem Description 
Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.


Example 1:
Input: nums = [1,2,3,1]
Output: true

Example 2:
Input: nums = [1,2,3,4]
Output: false

Example 3:
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true

Constraints:
`1 <= nums.length <= 105`
`-109 <= nums[i] <= 109`

### Solution 
 To address the problem of determining whether any value in the given integer array `nums` appears at least twice, we can utilize a couple of different methods. We aim to write an efficient solution that is easy to understand and compatible with the format required by LeetCode problem submissions.

### Solution Idea

The idea is straightforward:
- Iterate over each element in the array and check whether it has appeared before.
- To keep track of the elements we have seen so far, we can use a set, as it provides O(1) average time complexity for insertions and lookups.

### Plan
1. Create an empty set to store the unique numbers encountered as we iterate through the array.
2. Loop through each number in the `nums` array.
3. If the number exists in the set, return `true` indicating a duplicate is found.
4. If it is not found, add the number to the set.
5. If the loop completes without finding any duplicates, return `false`.

### Python Code



```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False

```

### Explanation

- **set `seen`:** This helps in storing each number we have come across. Sets in Python provide constant time complexity, O(1), for both insertion and membership tests on average.
- **Loop (for num in nums):** We examine each number in the input `nums` array.
  - **if num in seen:** If the current number is already present in the set, it indicates a duplicate exists, thus return `True`.
  - **seen.add(num):** If it is not a duplicate, add this number to the set and continue.
- **Return False:** If no duplicates are found after examining all elements, return `False`.

### Complexity Analysis

- **Time Complexity:** O(n), where n is the number of elements in the array. We do a single pass over all elements, and each operation with the set (check existence or addition) is O(1) on average.
- **Space Complexity:** O(n) in the worst case when all elements are unique, as every element will be stored in the set.

This solution efficiently determines if any duplicates exist in the array using a space-time trade-off by utilizing additional space to achieve linear time complexity.

# 219. Contains Duplicate II

### Problem Description 
Given an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and `abs(i - j) <= k`.


Example 1:
Input: nums = [1,2,3,1], k = 3
Output: true

Example 2:
Input: nums = [1,0,1,1], k = 1
Output: true

Example 3:
Input: nums = [1,2,3,1,2,3], k = 2
Output: false

Constraints:
`1 <= nums.length <= 105`
`-109 <= nums[i] <= 109`
`0 <= k <= 105`

### Solution 
 To solve this problem, we can use a hashmap (or dictionary in Python) to store the most recent indices of each number encountered while iterating through the array. The idea is to check, for each number, if the same number has occurred before and whether the difference between the current index and the last occurrence is less than or equal to `k`.

Here is a step-by-step approach:

1. Initialize an empty dictionary `index_map` to store the last index of each number in the array.
2. Iterate over the array using a loop where the index is `i` and the element is `num`.
3. For each number:
   - Check if `num` is present in `index_map` and if the condition `i - index_map[num] <= k` holds true. If so, return `True` because we have found two indices `i` and `j` (where `j = index_map[num]`) that fulfill both conditions.
   - Update `index_map[num]` to the current index `i`.
4. If we finish the loop without finding any such pair, return `False`.

This approach ensures that each element is added or updated in the hashmap in constant time `O(1)`, leading to an overall time complexity of `O(n)`, where `n` is the size of the array. Since we only store the last occurrence of each number, the space complexity is `O(u)` where `u` is the number of unique elements in the array `nums`.

Here is the actual Python code in the format you can directly run on LeetCode:



```python
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        index_map = {}
        for i, num in enumerate(nums):
            if num in index_map and i - index_map[num] <= k:
                return True
            index_map[num] = i
        return False

# The testing part, usually not included if you are submitting on LeetCode directly
# To run locally you could use:
# sol = Solution()
# print(sol.containsNearbyDuplicate([1,2,3,1], 3)) # Output: True
# print(sol.containsNearbyDuplicate([1,0,1,1], 1)) # Output: True
# print(sol.containsNearbyDuplicate([1,2,3,1,2,3], 2)) # Output: False

```

This Python code defines a `Solution` class with a `containsNearbyDuplicate` method that performs the described algorithm, ensuring to check if two same numbers occur within the distance of `k` indices in the array.

# 228. Summary Ranges

### Problem Description 
You are given a sorted unique integer array `nums`.

Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of `nums` is covered by exactly one of the ranges, and there is no integer `x` such that `x` is in one of the ranges but not in `nums`.

Each range `[a,b]` in the list should be output as:
`"a->b"` if `a != b`
`"a"` if `a == b`

Example 1:
Input: nums = [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
Explanation: The ranges are:
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"

Example 2:
Input: nums = [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
Explanation: The ranges are:
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"

Example 3:
Input: nums = []
Output: []

Example 4:
Input: nums = [-1]
Output: ["-1"]

Example 5:
Input: nums = [0]
Output: ["0"]

Constraints:
`0 <= nums.length <= 20`
`-231 <= nums[i] <= 231 - 1`
All the values of `nums` are unique.

`nums` is sorted in ascending order.

### Solution 
 To solve the problem of identifying consecutive integer sequences from a sorted array of unique numbers, the approach involves walking through the array and building range boundaries as contiguous numbers are found.

Here is the procedure:

1. **Initialization**: Start with an empty list to store the results, and if the input list is empty, return this empty list directly.
2. **Single Element List**: If the list contains only one element, add that element as a string directly to the results and return it.
3. **Multiple Element List**:
    - Iterate over the elements, keeping track of the beginning of a current range.
    - When you find a number that isn't contiguous with the previous (i.e., `current number != previous number + 1`), finalize the previous range and start a new range.
    - Add the finalized ranges in the specified string format â€” `"a->b"` for ranges with more than one number, and `"a"` if the range is a single number.
4. **End of Array**: After the loop, add any remaining range that was being tracked.

This approach ensures that each number and each gap is only checked once, resulting in a linear time complexity relative to the input size (`O(n)`), which is efficient given the constraints.

Below is the Python code following the format required for direct compilation and execution in a LeetCode environment:



```python
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        # Edge case: empty list
        if not nums:
            return []
        
        ranges = []
        start = nums[0]
        
        # Iterate through nums to find ranges
        for i in range(1, len(nums)):
            # Check if the current number is not contiguous with the previous
            if nums[i] != nums[i - 1] + 1:
                # Finish the current range
                if start == nums[i - 1]:
                    ranges.append(str(start))
                else:
                    ranges.append(f"{start}->{nums[i - 1]}")
                
                # Update start to the new range starting point
                start = nums[i]
        
        # Handle the final range
        if start == nums[-1]:
            ranges.append(str(start))
        else:
            ranges.append(f"{start}->{nums[-1]}")
            
        return ranges

# Example usage:
# sol = Solution()
# print(sol.summaryRanges([0,1,2,4,5,7]))  # Output: ["0->2","4->5","7"]
# print(sol.summaryRanges([0,2,3,4,6,8,9]))  # Output: ["0","2->4","6","8->9"]
# print(sol.summaryRanges([]))  # Output: []
# print(sol.summaryRanges([-1]))  # Output: ["-1"]
# print(sol.summaryRanges([0]))  # Output: ["0"]

```

This code is written as a class `Solution` with a method `summaryRanges` which takes a list of integers and returns a list of strings as specified, and aligns with the structure and formatting as typically required by the LeetCode platform.

# 229. Majority Element II

### Problem Description 
Given an integer array of size `n`, find all elements that appear more than `âŒŠ n/3 âŒ‹` times.

Follow-up: Could you solve the problem in linear time and in O(1) space?

Example 1:
Input: nums = [3,2,3]
Output: [3]

Example 2:
Input: nums = [1]
Output: [1]

Example 3:
Input: nums = [1,2]
Output: [1,2]

Constraints:
`1 <= nums.length <= 5 * 104`
`-109 <= nums[i] <= 109`

### Solution 
 The problem requires us to find elements in an array that appear more than `âŒŠ n/3 âŒ‹` times where `n` is the size of the array. Such elements are often referred to as the majority elements of the array.

Boyer-Moore Voting Algorithm:
For this problem, an extension of the Boyer-Moore Voting Algorithm can be employed which targets the elements with a frequency greater than `n/3`. Since any element that appears more than `âŒŠ n/3 âŒ‹` times can be at most 2 such elements, the algorithm maintains two potential candidates and their counts.

Steps:
1. First pass: Identify two potential candidates that could potentially be the elements that occur more than `âŒŠ n/3 âŒ‹` times.
2. Second pass: Verify these candidates by ensuring their counts exceed `âŒŠ n/3 âŒ‹`.

This method ensures a `O(n)` time complexity and `O(1)` space complexity, adhering to the constraints and follow-up question requirements.

Here's the Python code using the mentioned approach:



```python
class Solution:
    def majorityElement(self, nums):
        if not nums:
            return []
        
        # First candidate for the majority element
        candidate1, count1 = None, 0
        # Second candidate for the majority element
        candidate2, count2 = None, 0
        
        # Phase 1: Find candidates
        for num in nums:
            if num == candidate1:
                count1 += 1
            elif num == candidate2:
                count2 += 1
            elif count1 == 0:
                candidate1, count1 = num, 1
            elif count2 == 0:
                candidate2, count2 = num, 1
            else:
                count1 -= 1
                count2 -= 1
        
        # Phase 2: Verify the count of candidates
        count1, count2 = 0, 0
        for num in nums:
            if num == candidate1:
                count1 += 1
            elif num == candidate2:
                count2 += 1

        result = []
        n = len(nums)
        if count1 > n//3:
            result.append(candidate1)
        if count2 > n//3:
            result.append(candidate2)
        
        return result

# Example usage:
sol = Solution()
print(sol.majorityElement([3,2,3]))  # Output: [3]
print(sol.majorityElement([1]))       # Output: [1]
print(sol.majorityElement([1,2]))     # Output: [1, 2]

```

This code defines a function `majorityElement` which takes an array of integers `nums` and returns a list of integers that appear more than `âŒŠ n/3 âŒ‹` times in the array. It's based on iterating through the array to determine potential candidates and another iteration to count these candidates, ensuring the memory and time efficacy promised by applying the Boyer-Moore Voting Algorithm. This function can be tested directly with sample inputs for correctness.


# 238. Product of Array Except Self

### Problem Description 
Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.

The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.


Example 1:
Input: nums = [1,2,3,4]
Output: [24,12,8,6]

Example 2:
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]

Constraints:
`2 <= nums.length <= 105`
`-30 <= nums[i] <= 30`
The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.

Follow up:
Could you solve it in `O(n)` time complexity and without using division?
Could you solve it with `O(1)` constant space complexity? (The output array does not count as extra space for space complexity analysis.)

### Solution 
 Certainly! Below is a Python code to solve the given problem along with a detailed explanation that adheres to the LeetCode format. This solution ensures that it can run directly on the LeetCode platform.



```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        answer = [1] * n
        
        # Initialize the left and right product lists
        left_product = [1] * (n+1)
        right_product = [1] * (n+1)
        
        # Fill the left product array
        for i in range(n):
            left_product[i+1] = left_product[i] * nums[i]
        
        # Fill the right product array
        for i in range(n - 1, -1, -1):
            right_product[i] = right_product[i + 1] * nums[i]
        
        # Constructing the result list
        for i in range(n):
            answer[i] = left_product[i] * right_product[i + 1]
        
        return answer

```

### Detailed Explanation:

1. **Input and Output**:
   - Input: An array `nums` containing integers.
   - Output: An array `answer` where each element `i` is equal to the product of all elements of `nums` except `nums[i]`.

2. **Approach**:
   - We will use two additional arrays, `left_product` and `right_product`.
     - `left_product[i]` will store the product of all the elements to the left of index `i`.
     - `right_product[i]` will store the product of all the elements to the right of index `i`.

   - First, we compute the `left_product` array where each element is the cumulative product of all previous elements of `nums`.
  
   - Next, we compute the `right_product` array where we accumulate products from the rightmost element towards the left.
  
   - The product of all elements except `nums[i]` is then calculated by multiplying `left_product[i]` and `right_product[i+1]`.

3. **Complexity**:
   - **Time Complexity**: O(n), since we make a constant number of passes through the array (3 loops that are not nested and each O(n)).
   - **Space Complexity**: O(1) if we consider the output array doesn't count as extra space. Ignore space used by `left_product` and `right_product` arrays for calculation, otherwise, it would be O(n).

4. **Optimization Consideration**:
   - As mentioned in the follow-up requirement, this solution could be optimized further to O(1) space complexity without using `left_product` and `right_product` arrays. We can directly compute product values on the result array by storing temporary products and iterating the input list multiple times.

By using this approach, we address the problem requirements and constraints effectively including edge cases such as zeros and negative values in the input list. This will execute correctly within LeetCode's environment.

# 245. Shortest Word Distance III

### Problem Description 
Given an array of strings `wordsDict` and two strings that already exist in the array `word1` and `word2`, return the shortest distance between these two words in the list.

Note that `word1` and `word2` may be the same. It is guaranteed that they represent two individual words in the list.


Example 1:
Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "coding"
Output: 1

Example 2:
Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "makes"
Output: 3

Constraints:
`1 <= wordsDict.length <= 3 * 104`
`1 <= wordsDict[i].length <= 10`
`wordsDict[i]` consists of lowercase English letters.

`word1` and `word2` are in `wordsDict`.

### Solution 
 To solve the problem of finding the shortest distance between two words in a list of strings where the two words can be the same, we can use a pointer-like approach. The solution consists of the following steps:

1. Traverse the list `wordsDict` once and keep track of the last positions where `word1` and `word2` were found.
2. For each word in the list, check if it equals `word1` or `word2`.
3. If it matches `word1`, update the last position for `word1`. If `word1` is the same as `word2`, simply update the minimum distance based on the difference between indices.
4. If it matches `word2` and it is not the same as `word1`, update the last position for `word2`.
5. Every time you update a position, check and update the minimum distance between `word1` and `word2` using their last positions.
6. Return the minimum distance found.

This approach ensures that the solution is efficient with a time complexity of O(n), where n is the number of words in the dictionary, since we traverse the list of words exactly once.

Now, let's write the Python code for this solution, structured according to the LeetCode format:



```python
class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
        min_distance = float('inf')
        idx1, idx2 = -1, -1
        
        for i, word in enumerate(wordsDict):
            if word == word1:
                idx1 = i
                if idx1 != -1 and idx2 != -1:
                    min_distance = min(min_distance, abs(idx1 - idx2))
            if word == word2:
                idx2 = i
                if idx1 != -1 and idx2 != -1:
                    min_distance = min(min_distance, abs(idx1 - idx2))

        return min_distance

# Example interface usage:
# sol = Solution()
# print(sol.shortestDistance(["practice", "makes", "perfect", "coding", "makes"], "makes", "coding")) # Output: 1
# print(sol.shortestDistance(["practice", "makes", "perfect", "coding", "makes"], "makes", "makes")) # Output: 3

```

This code defines a `Solution` class and a method `shortestDistance` that receives an array of words and the two words for which we need to find the shortest distance. It updates the positions of `word1` and `word2` as they appear in the array and computes the minimum distance continually through the traversal. Each time both words have been found at least once, it checks if the current distance between their last found indices is smaller than the previously stored minimum distance and updates accordingly.

# 259. 3Sum Smaller

### Problem Description 
Given an array of `n` integers `nums` and an integer `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`.

Follow up: Could you solve it in `O(n2)` runtime?

Example 1:
Input: nums = [-2,0,1,3], target = 2
Output: 2
Explanation: Because there are two triplets which sums are less than 2:
[-2,0,1]
[-2,0,3]

Example 2:
Input: nums = [], target = 0
Output: 0

Example 3:
Input: nums = [0], target = 0
Output: 0

Constraints:
`n == nums.length`
`0 <= n <= 300`
`-100 <= nums[i] <= 100`
`-100 <= target <= 100`

### Solution 
 To solve this problem in `O(n^2)` time complexity, we can apply a combination of sorting, two-pointer techniques, and some logical deductions:

### Algorithm:

1. **Sorting**: First, sort the `nums` array. A sorted array helps us efficiently find the sum combinations through two-pointer technique.

2. **Two-Pointer Technique**: For each element in the array which will act as `nums[i]`, use a two-pointer approach to find pairs `(nums[j], nums[k])` such that `nums[j] + nums[k]` is less than `target - nums[i]`. 

    - Initialize `j` as the next element after `i` (`j = i + 1`), and `k` as the last element (`k = len(nums) - 1`).
    - While `j < k`, check the sum `nums[i] + nums[j] + nums[k]`.
    - If the sum is less than `target`, all elements between `j` and `k` paired with `i` and `j` will also give sum less than `target` because the array is sorted. In this case, add `k - j` to the count and increment `j` to check the next pair.
    - If the sum is equal to or greater than `target`, decrement `k` to try a smaller sum.

3. Keep a counter to count such valid triplets and return this count as the result.

### Code:



```python
class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -> int:
        # Sort the nums list to facilitate efficient sum checks
        nums.sort()
        n = len(nums)
        count = 0
        
        # Navigate through each number as a potential first element of the triplet
        for i in range(n - 2):
            # Use two pointers to find valid pairs
            j, k = i + 1, n - 1
            while j < k:
                current_sum = nums[i] + nums[j] + nums[k]
                if current_sum < target:
                    # If the sum of nums[i], nums[j], and nums[k] is less than the target,
                    # then all combinations with nums[i], nums[j], and any number between nums[j] and nums[k]
                    # will also have a sum less than the target
                    count += k - j
                    j += 1
                else:
                    # If current sum is greater or equal, move k to find a smaller sum
                    k -= 1
                    
        return count

```

### Explanation:
- The outer loop picks every number one by one to be the first number in the triplet.
- Inside the loop, the program uses a two-pointer approach to evaluate pairs of numbers `nums[j]` and `nums[k]`, checking if their sum with `nums[i]` is smaller than `target`.
- If the sum is smaller, it implies all pairs starting from `j` to `k-1` (inclusive) will form valid triplets with `nums[i]` because the array is sorted, hence can quickly add many possible pairs.
- Note the use of horizontal scaling with not just focusing on one comparison but leveraging the sorted property for rapid combinations counting.

This implementation has an average time complexity of \(O(n^2)\) owing to the nested loops (but the inner operation is often less than full `n` due to the two-pointer approach), and it efficiently adheres to the constraints given.

# 268. Missing Number

### Problem Description 
Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.

Follow up: Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?

Example 1:
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.


Example 2:
Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.


Example 3:
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.


Example 4:
Input: nums = [0]
Output: 1
Explanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.


Constraints:
`n == nums.length`
`1 <= n <= 104`
`0 <= nums[i] <= n`
All the numbers of `nums` are unique.

### Solution 
 To address this problem directly on LeetCode, we can leverage the properties of mathematical operations, specifically XOR, to find the missing number in a dense range in an efficient O(n) time complexity with constant space O(1).

The main concept exploited here is:
1. XOR a number with itself results in 0.
2. XOR a number with 0 results in the number itself.

#### The strategy:
- XOR all indices and all values of the array.
- The result is the missing number because it will not have a duplicate to cancel it out.

I'll write the code using this approach. This method naturally adheres to the problem's constraints and optimizes for time and space complexity.



```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        # Initialize xor_result to n, because we have n distinct numbers from 0 to n
        xor_result = len(nums) 
        
        # XOR all indices and values
        for i in range(len(nums)):
            xor_result ^= i ^ nums[i]
        
        return xor_result

# The Solution class can now be instantiated and called as follows:
# sol = Solution()
# res = sol.missingNumber([3,0,1])
# print(res)  # Output is expected to be 2

```

Each operation within the loop is constant time, and we pass through the array exactly once, achieving O(n) time complexity. As no additional significant space is used, the space complexity is O(1).

This should work correctly when run on LeetCode for any test case conforming to the stated constraints.

# 277. Find the Celebrity

### Problem Description 
Suppose you are at a party with `n` people (labeled from `0` to `n - 1`), and among them, there may exist one celebrity. The definition of a celebrity is that all the other `n - 1` people know him/her, but he/she does not know any of them.

Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).

You are given a helper function `bool knows(a, b)` which tells you whether A knows B. Implement a function `int findCelebrity(n)`. There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return `-1`.


Example 1:
Input: graph = [[1,1,0],[0,1,0],[1,1,1]]
Output: 1
Explanation: There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.


Example 2:
Input: graph = [[1,0,1],[1,1,0],[0,1,1]]
Output: -1
Explanation: There is no celebrity.


Constraints:
`n == graph.length`
`n == graph[i].length`
`2 <= n <= 100`
`graph[i][j]` is `0` or `1`.

`graph[i][i] == 1`
Follow up: If the maximum number of allowed calls to the API `knows` is `3 * n`, could you find a solution without exceeding the maximum number of calls?

### Solution 
 To solve the "Find the Celebrity" problem, one efficient approach is to reduce the potential number of candidates for the celebrity by leveraging the properties that define a celebrity: everyone knows them and they donâ€™t know anyone else.

We can design our solution in two main phases:
1. Identify a potential celebrity.
2. Verify if the identified candidate is indeed a celebrity.

**Step-by-Step Solution:**

1. **Candidate Selection:**
    - Start with an assumption that person `0` might be the celebrity.
    - Iterate through people from `1` to `n-1`:
        - If the current candidate knows the `i`-th person, then the candidate cannot be a celebrity, so update the candidate to person `i` because a known person cannot be a celebrity.
        - If the current candidate does not know the `i`-th person, continue checking the next person.
    - At the end of this loop, you will have one candidate.

2. **Candidate Verification:**
    - Verify that everyone knows this candidate.
    - Ensure the candidate knows no one else.

3. **Implementation in Python:**
Given the constraints that the given function `knows(a, b)` is an API and the problem needs to be solved in a LeetCode format, the implementation should stick to the API usage and use no extra data structures for streamlined verification.



```python
# The knows API is assumed to be already defined by LeetCode platform.
# We have to use this API to complete the solution.

def findCelebrity(n):
    candidate = 0
    
    # Find potential candidate which might be the celebrity
    for i in range(1, n):
        if knows(candidate, i):
            candidate = i
    
    # Verify candidate
    for i in range(n):
        if i != candidate:
            # Candidate should not know 'i' and 'i' must know the candidate
            if knows(candidate, i) or not knows(i, candidate):
                return -1
    
    return candidate

# The define `knows(a, b)` and call findCelebrity(n) will be done by the LeetCode platform, it will handle the testing.

```

**Explanation:**
- In the first loop, we find a `candidate` by ensuring he/she doesn't know the next person unless required by the failure of the current candidate (he/she knows someone).
- In the second loop, we check two conditions:
  - The candidate should not know any other person (`knows(candidate, i)` must be False).
  - Every other person must know the candidate (`knows(i, candidate)` must be True).
- If any condition fails, the candidate is not a celebrity.

**Complexity:**
- Time Complexity: O(n) because each of two loops runs up to `n` times.
- Space Complexity: O(1) because no additional space is utilized except for a few variables.

This implementation template would be directly suitable for inserting into a LeetCode coding environment assuming the `knows` API is predefined as suggested by the problem description.

# 280. Wiggle Sort

### Problem Description 
Given an integer array `nums`, reorder it such that `nums[0] <= nums[1] >= nums[2] <= nums[3]...`.

You may assume the input array always has a valid answer.


Example 1:
Input: nums = [3,5,2,1,6,4]
Output: [3,5,1,6,2,4]
Explanation: [1,6,2,5,3,4] is also accepted.


Example 2:
Input: nums = [6,6,5,6,3,8]
Output: [6,6,5,6,3,8]

Constraints:
`1 <= nums.length <= 5 * 104`
`0 <= nums[i] <= 104`
It is guaranteed that there will be an answer for the given input `nums`.

Follow up: Could you do it without sorting the array?

### Solution 
 To solve the problem based on the specified conditions (`nums[0] <= nums[1] >= nums[2] <= nums[3]...`), we need to ensure that the elements at even indices are less than or equal to their next elements, and the elements at odd indices are greater than or equal to their next elements. 

There is an efficient approach to solving this problem without the need to sort the array, which involves a simple linear pass and adjusting the order of elements based on their index (even or odd). 

With the constraints given (up to `5 * 10^4` elements with values up to `10^4`), this in-place algorithm is efficient, operating in `O(n)` time complexity and using `O(1)` additional space. This method is practical and checks each neighbouring pair and swaps them if they don't satisfy the desired condition.

Below is the Python function that follows the described strategy:



```python
from typing import List

class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # We loop over the array, starting from the first element.
        for i in range(len(nums) - 1):
            # If i is even and nums[i] is greater than nums[i + 1], we swap them
            # to ensure nums[i] <= nums[i + 1].
            if i % 2 == 0:
                if nums[i] > nums[i + 1]:
                    nums[i], nums[i + 1] = nums[i + 1], nums[i]
            # If i is odd and nums[i] is less than nums[i + 1], we swap them
            # to ensure nums[i] >= nums[i + 1].
            else:
                if nums[i] < nums[i + 1]:
                    nums[i], nums[i + 1] = nums[i + 1], nums[i]

# Example usage:
if __name__ == '__main__':
    sol = Solution()
    nums1 = [3, 5, 2, 1, 6, 4]
    sol.wiggleSort(nums1)
    print(nums1)  # Output should be a valid wiggle sort

    nums2 = [6, 6, 5, 6, 3, 8]
    sol.wiggleSort(nums2)
    print(nums2)  # Output should be a valid wiggle sort

```

This code should be executed directly on LeetCode by pasting it into the editor. It modifies the input list `nums` in-place, ensuring the output adheres to the problem's requirements without the need for sorting or additional memory.

# 283. Move Zeroes

### Problem Description 
Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.


Example 1:
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]

Example 2:
Input: nums = [0]
Output: [0]

Constraints:
`1 <= nums.length <= 104`
`-231 <= nums[i] <= 231 - 1`
Follow up: Could you minimize the total number of operations done?

### Solution 
 To solve the problem of moving all zeros in an array to the end while maintaining the order of non-zero elements, a two-pointer approach can be particularly effective. This approach ensures optimal performance and meets the requirement of modifying the array in-place without extra memory for a copy of the array.

Hereâ€™s a breakdown of how the two-pointer technique can be applied:
1. Use one pointer (`last_non_zero`) to track the position where the next non-zero element should be placed.
2. Iterate through the array with another pointer. For every non-zero element encountered, place it at the position indicated by `last_non_zero` and increment `last_non_zero`.
3. After the first pass is complete, all non-zero elements are in their correct position but the remaining elements in the array starting from `last_non_zero` to the end might need to be set to zero.

This method is efficient because it:
- Processes the array in a single pass for movement of non-zero numbers.
- Requires a potentially partial second pass from where the non-zero numbers end to set remaining indices to zero.

Here is how you can write this as a LeetCode compatible Python function:



```python
class Solution:
    def moveZeroes(self, nums):
        """
        Do not return anything, modify nums in-place instead.
        """
        last_non_zero_found_at = 0
        # Move all the non-zero elements to the beginning of the array
        for current in range(len(nums)):
            if nums[current] != 0:
                nums[last_non_zero_found_at] = nums[current]
                last_non_zero_found_at += 1
        
        # Fill remaining array with zeros.
        for i in range(last_non_zero_found_at, len(nums)):
            nums[i] = 0

```

### Explanation:
- **`last_non_zero_found_at`** keeps track of where the next non-zero element should go.
- **First loop**: Identifies non-zero elements and places them sequentially from the start of `nums`.
- **Second loop**: Sets all remaining positions in the array to zero starting from where the last non-zero was placed.

### Example:
`nums = [0, 1, 0, 3, 12]` becomes `nums = [1, 3, 12, 0, 0]` after the function call.

### Time Complexity:
The time complexity of this algorithm is O(n), where n is the number of elements in the list. This stems from a single pass looking for non-zero elements and a potential second pass to set the remaining elements to zero.

### Space Complexity:
The space complexity is O(1) since we modify the array in-place and do not use any additional data structures that grow with the input size.

This approach, therefore, meets the requirements of minimal operational overhead and in-place array modification, making it suitable for scenarios with memory usage constraints.

# 287. Find the Duplicate Number

### Problem Description 
Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.

There is only one repeated number in `nums`, return this repeated number.


Example 1:
Input: nums = [1,3,4,2,2]
Output: 2

Example 2:
Input: nums = [3,1,3,4,2]
Output: 3

Example 3:
Input: nums = [1,1]
Output: 1

Example 4:
Input: nums = [1,1,2]
Output: 1

Constraints:
`2 <= n <= 3 * 104`
`nums.length == n + 1`
`1 <= nums[i] <= n`
All the integers in `nums` appear only once except for precisely one integer which appears two or more times.

Follow up:
How can we prove that at least one duplicate number must exist in `nums`?
Can you solve the problem without modifying the array `nums`?
Can you solve the problem using only constant, `O(1)` extra space?
Can you solve the problem with runtime complexity less than `O(n2)`?

### Solution 
 To solve the problem of finding the repeated number in an array `nums` where `nums` contains `n + 1` integers and each integer is between `1` and `n`, we can use multiple approaches. Let's explore the efficient approaches. Given constraints suggest that there might be smarter algorithmic strategies than a simple brute force search, particularly aiming for linear time complexity and constant space complexity.

**Solution 1: Cycle Detection (Floydâ€™s Tortoise and Hare Algorithm)**
This solution leverages the fact that the problem structure is similar to a linked list with a cycle. The repeated number forms this cycle, which is why the cycle detection strategy applies.

**Steps:**
1. Use two pointers, slow and fast (`tortoise` and `hare`).
2. Initialize both at the start. Let `tortoise` move one step at a time (`tortoise = nums[tortoise]`), and `hare` move two steps at a time (`hare = nums[nums[hare]]`).
3. When they meet, it indicates a cycle. However, the meeting point is not necessarily the start of the cycle (duplicate number).
4. Move one pointer to the start, and keep the other at the meeting point, both move one step at a time.
5. The point at which they meet again is the start of the cycle, which represents the duplicate number.

This approach utilizes the mathematics behind cycle detection and ensures that no additional space is used, meeting the constraints effectively.

**Implementation**:



```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # Phase 1: Finding the intersection point of the two runners.
        tortoise = hare = nums[0]
        while True:
            tortoise = nums[tortoise]
            hare = nums[nums[hare]]
            if tortoise == hare:
                break
        
        # Phase 2: Finding the entrance to the cycle.
        tortoise = nums[0]
        while tortoise != hare:
            tortoise = nums[tortoise]
            hare = nums[hare]
        
        return hare

# Example Usage
# sol = Solution()
# print(sol.findDuplicate([1,3,4,2,2])) # Output: 2

```

**Answer to follow-up questions:**
1. *Proving existence of at least one duplicate*: This can be done using the Pigeonhole Principle. If there are `n+1` numbers and each is in the range `[1, n]`, there must be at least one repetition if you try placing `n+1` items in `n` slots.
2. *Solving without modifying array*: The proposed cycle detection doesn't require modification of the array.
3. *Solving with O(1) space*: Cycle detection operates with constant space for the two pointers.
4. *Solving with runtime complexity less than `O(n^2)`*: The cycle detection algorithm runs in linear time, `O(n)`, as each pointer traverses the list at most twice.

# 289. Game of Life

### Problem Description 
According to Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."
The board is made up of an `m x n` grid of cells, where each cell has an initial state: live (represented by a `1`) or dead (represented by a `0`). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
Any live cell with fewer than two live neighbors dies as if caused by under-population.

Any live cell with two or three live neighbors lives on to the next generation.

Any live cell with more than three live neighbors dies, as if by over-population.

Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return the next state.


Example 1:
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]

Example 2:
Input: board = [[1,1],[1,0]]
Output: [[1,1],[1,1]]

Constraints:
`m == board.length`
`n == board[i].length`
`1 <= m, n <= 25`
`board[i][j]` is `0` or `1`.

Follow up:
Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.

In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?

### Solution 
 The problem is a classic example of cellular automata called "The Game of Life". To solve this challenge, we need to follow certain rules to determine the next state of each cell, based on its current state and its neighbors' states.

In order to solve the problem, we must update the board's cells simultaneously. To achieve this in-place without using additional memory proportional to the size of the board, we can temporarily encode the states in the existing board using extra states.

**Approach:**
1. We can use additional states to encode the previous and the next state of each cell:
   - `0` denotes a cell that was dead and stays dead.
   - `1` denotes a cell that was alive and stays alive.
   - `2` denotes a cell that was alive but will die.
   - `3` denotes a cell that was dead but will become alive.

2. Iterate over each cell in the board, count its living neighbors, and decide the future state of the cell according to the rules:
    - If a cell is alive, we check if it should either stay alive or die.
    - If a cell is dead, we check if it should come to life.

3. After determining the future state for all cells, use a second loop to transform the board into its final next-state by decoding the values (`0` and `1` for dead and alive, respectively).

4. Optionally: To handle the infinite board problem, we can increase the size of our board dynamically whenever cells approach the edge, although the constraints given assure that we donâ€™t need to handle this specific scenario.

Below is the Python solution adhering to your request and considering the specific constraints:


```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board:
            return
        
        # Dimensions of the board
        m, n = len(board), len(board[0])
        
        # Directions array for the 8 neighboring cells
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1),
                      (-1, -1), (-1, 1), (1, -1), (1, 1)]
        
        # First pass: apply rules and use extra states to encode new values
        for i in range(m):
            for j in range(n):
                live_neighbors = 0
                # Count live neighbors
                for dx, dy in directions:
                    x, y = i + dx, j + dy
                    if 0 <= x < m and 0 <= y < n and (board[x][y] == 1 or board[x][y] == 2):
                        live_neighbors += 1

                if board[i][j] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    board[i][j] = 2  # Alive -> Dead
                if board[i][j] == 0 and live_neighbors == 3:
                    board[i][j] = 3  # Dead -> Alive
        
        # Second pass: decode the values
        for i in range(m):
            for j in range(n):
                if board[i][j] == 2:
                    board[i][j] = 0 # Decode to dead
                elif board[i][j] == 3:
                    board[i][j] = 1 # Decode to alive

# Usage:
# sol = Solution()
# grid = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
# sol.gameOfLife(grid)
# print(grid)  # Output will be next state of the grid

```
This code should be able to be directly run on the LeetCode platform. It follows the rules to evolve the game state in place without requiring additional board space.

# 370. Range Addition

### Problem Description 
You are given an integer `length` and an array `updates` where `updates[i] = [startIdxi, endIdxi, inci]`.

You have an array `arr` of length `length` with all zeros, and you have some operation to apply on `arr`. In the `ith` operation, you should increment all the elements `arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi]` by `inci`.

Return `arr` after applying all the `updates`.


Example 1:
Input: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
Output: [-2,0,3,5,3]

Example 2:
Input: length = 10, updates = [[2,4,6],[5,6,8],[1,9,-4]]
Output: [0,-4,2,2,2,4,4,-4,-4,-4]

Constraints:
`1 <= length <= 105`
`0 <= updates.length <= 104`
`0 <= startIdxi <= endIdxi < length`
`-1000 <= inci <= 1000`

### Solution 
 The problem statement describes a situation where we have to range update a list initially filled with zeros. A brute force approach involves updating each value from `startIdx` to `endIdx` directly, which can be time-consuming for large ranges. Instead, a more efficient approach can be implemented using the concept of a difference array, enabling range updates in constant time.

### Difference Array Approach:
A difference array `diff` provides a way to perform range update operations efficiently. For an operation on the interval `[startIdx, endIdx]` to increment all elements by `inci`:

1. Increment `diff[startIdx]` by `inci`.
2. Decrement `diff[endIdx+1]` by `inci` (if `endIdx + 1` is within bounds).

After updating the difference array with all updates, the actual array values can be determined by taking the prefix sum of the difference array. This way, updating any range happens in constant time \(O(1)\).

### Python Code:


```python
class Solution:
    def getModifiedArray(self, length: int, updates: list) -> list:
        # Create a difference array initialized with zeros
        diff = [0] * (length + 1)  # One extra to handle bound cases smoothly
        
        # Apply all the updates to the difference array
        for start, end, increment in updates:
            diff[start] += increment
            if end + 1 < length:
                diff[end + 1] -= increment

        # Build the result array from the difference array
        result = [0] * length
        result[0] = diff[0]
        for i in range(1, length):
            result[i] = result[i - 1] + diff[i]

        return result

```

### Explanation:
- **Initialization**: We create a `diff` array of length `length + 1` to handle updates smoothly even near the boundaries.
- **Applying updates**: For each update `[startIdxi, endIdxi, inci]`, modify only `diff[startIdxi]` and `diff[endIdxi + 1]`, ensuring the prefix sum will reproduce the correct values.
- **Building the final array**: We convert the difference array back to the actual array values by computing the prefix sums.

This approach reduces the complexity of applying each update from \(O(n)\) to \(O(1)\), where \(n\) is the potential number of updates to be applied within a range. The prefix sum generation is \(O(length)\). Thus, the overall complexity of the solution is \(O(length + updates.length)\), which is significantly optimal compared to a direct brute force method.

# 380. Insert Delete GetRandom O(1)

### Problem Description 
Implement the `RandomizedSet` class:
`RandomizedSet()` Initializes the `RandomizedSet` object.

`bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise.

`bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.

`int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.


Example 1:
Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]
Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.

randomizedSet.remove(2); // Returns false as 2 does not exist in the set.

randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].

randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.

randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].

randomizedSet.insert(2); // 2 was already in the set, so return false.

randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.


Constraints:
`-231 <= val <= 231 - 1`
At most `105` calls will be made to `insert`, `remove`, and `getRandom`.

There will be at least one element in the data structure when `getRandom` is called.

Follow up: Could you implement the functions of the class with each function works in average `O(1)` time?

### Solution 
 To solve this problem efficiently while supporting operations in average O(1) time, a combination of a list and a hash map (dictionary in Python) can be used. Here's how each component contributes to the operations:

1. **List:** Allows O(1) access to any element when indexed and O(1) append operation. However, direct element deletion is O(N).
2. **Dictionary (Hash Map):** Supports O(1) average time complexity for insertions, deletions, and lookups by value.

The `RandomizedSet` class will utilize:
- A list to store the elements. The order in the list doesn't matter for our set-like operations.
- A dictionary to store the values as keys and their corresponding indices in the list as values. This facilitates O(1) removals and lookups.

Operations are defined as:
- **Insert(val):** 
  Check if the `val` is already in the dictionary. If not, append it to the list and store its index in the dictionary. Return `true`. If it exists, just return `false`.

- **Remove(val):** 
  Check if the `val` exists in the dictionary. If yes, fetch its index, swap the last element of the list with the element at the fetched index (to maintain O(1) deletion from the list), update the dictionary for the swapped element, pop the last element from the list, and delete the entry for `val` from the dictionary. Return `true`. If `val` doesn't exist, return `false`.

- **GetRandom():**
  Generate a random index based on the current size of the list and return the element at that index.

Here is the Python implementation:



```python
import random

class RandomizedSet:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.list = []
        self.dict = {}
    
    def insert(self, val: int) -> bool:
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        """
        if val in self.dict:
            return False
        self.dict[val] = len(self.list)
        self.list.append(val)
        return True

    def remove(self, val: int) -> bool:
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        """
        if val not in self.dict:
            return False
        # Move the last element to the place idx of the element to delete
        last_element = self.list[-1]
        idx = self.dict[val]
        self.list[idx] = last_element
        self.dict[last_element] = idx
        # Remove last element in list
        self.list.pop()
        del self.dict[val]
        return True
    
    def getRandom(self) -> int:
        """
        Get a random element from the set.
        """
        return random.choice(self.list)


# Example usage:
# randomizedSet = RandomizedSet()
# print(randomizedSet.insert(1))  # True, 1 inserted
# print(randomizedSet.remove(2))  # False, 2 not found
# print(randomizedSet.insert(2))  # True, 2 inserted
# print(randomizedSet.getRandom())  # 1 or 2 randomly
# print(randomizedSet.remove(1))  # True, 1 removed
# print(randomizedSet.insert(2))  # False, 2 already present
# print(randomizedSet.getRandom())  # Always 2

```

This implementation handles all the operations with expected O(1) time complexity by efficiently managing indices through the dictionary and handling list operations intelligently.

# 381. Insert Delete GetRandom O(1) - Duplicates allowed

### Problem Description 
Implement the `RandomizedCollection` class:
`RandomizedCollection()` Initializes the `RandomizedCollection` object.

`bool insert(int val)` Inserts an item `val` into the multiset if not present. Returns `true` if the item was not present, `false` otherwise.

`bool remove(int val)` Removes an item `val` from the multiset if present. Returns `true` if the item was present, `false` otherwise. Note that if `val` has multiple occurrences in the multiset, we only remove one of them.

`int getRandom()` Returns a random element from the current multiset of elements (it's guaranteed that at least one element exists when this method is called). The probability of each element being returned is linearly related to the number of same values the multiset contains.


Example 1:
Input
["RandomizedCollection", "insert", "insert", "insert", "getRandom", "remove", "getRandom"]
[[], [1], [1], [2], [], [1], []]
Output
[null, true, false, true, 2, true, 1]
Explanation
RandomizedCollection randomizedCollection = new RandomizedCollection();
randomizedCollection.insert(1);   // return True. Inserts 1 to the collection. Returns true as the collection did not contain 1.

randomizedCollection.insert(1);   // return False. Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].

randomizedCollection.insert(2);   // return True. Inserts 2 to the collection, returns true. Collection now contains [1,1,2].

randomizedCollection.getRandom(); // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.

randomizedCollection.remove(1);   // return True. Removes 1 from the collection, returns true. Collection now contains [1,2].

randomizedCollection.getRandom(); // getRandom should return 1 and 2 both equally likely.


Constraints:
`-231 <= val <= 231 - 1`
At most `105` calls will be made to `insert`, `remove`, and `getRandom`.

There will be at least one element in the data structure when `getRandom` is called.

Follow up: Could you implement the functions of the class with each function works in average `O(1)` time?

### Solution 
 To solve this problem efficiently, the `RandomizedCollection` class needs to support insertions, deletions, and random accessâ€”all in average `O(1)` time. We make use of a combination of a list (`list`) and a dictionary (`dict`) with set values for this purpose:

1. The `list` will enable `O(1)` access time for `getRandom`.
2. The `dict` will map `val` to a set of indices where this value exists in the list, supporting both `O(1)` time complexity for `insert` and `remove`.

Key operations of these data structures:
- **List**: Allows us to randomly access any index within it.
- **Dictionary with sets as values**: Maintains fast lookup, insert, and remove operations.

Here is how we handle each function:

- **Insert**:
  - Check if `val` is already in the dictionary. Add it if not, and set its index in the `list`.
  - Append `val` to the `list`.
  - Store this index in the set associated with `val` in the dictionary.
  - Return whether it was newly added based on the set size.

- **Remove**:
  - If `val` is not in the dictionary or its set is empty, return `false`.
  - Find an index of `val` to remove by accessing the last element of its set.
  - Swap the last element in the `list` with this index (if it's not already the last element), and update the dictionary accordingly.
  - Remove the last element from the `list`.
  - Update the dictionary sets for both `val` and the moved value if necessary.
  - Return `true`.

- **GetRandom**:
  - Get a random index in `list` and return the value at that index.

Here is the implementation:



```python
import random

class RandomizedCollection:
    def __init__(self):
        self.idx = {}
        self.list = []

    def insert(self, val: int) -> bool:
        isNew = val not in self.idx or len(self.idx[val]) == 0
        self.list.append(val)
        if isNew:
            self.idx[val] = set()
        self.idx[val].add(len(self.list) - 1)
        return isNew

    def remove(self, val: int) -> bool:
        if val not in self.idx or not self.idx[val]:
            return False
        remove_idx = self.idx[val].pop()  # Get and remove one index from set
        last_element = self.list[-1]
        if remove_idx < len(self.list) - 1:  # If it is not the last element, swap
            self.list[remove_idx] = last_element
            self.idx[last_element].add(remove_idx)
            self.idx[last_element].remove(len(self.list) - 1)
        self.list.pop()  # Remove last element
        if not self.idx[val]:
            del self.idx[val]  # Clean up dictionary if no more indices are present
        return True

    def getRandom(self) -> int:
        return random.choice(self.list)


# Continuous integration of this code into a LeetCode-style platform would require adding a line or two to test these methods as per the problem statement.

```

Understanding this code requires recognizing the interplay between list index management and value-storage in the set within the dictionary for seamless and efficient add/removal operations.

# 414. Third Maximum Number

### Problem Description 
Given integer array `nums`, return the third maximum number in this array. If the third maximum does not exist, return the maximum number.


Example 1:
Input: nums = [3,2,1]
Output: 1
Explanation: The third maximum is 1.


Example 2:
Input: nums = [1,2]
Output: 2
Explanation: The third maximum does not exist, so the maximum (2) is returned instead.


Example 3:
Input: nums = [2,2,3,1]
Output: 1
Explanation: Note that the third maximum here means the third maximum distinct number.

Both numbers with value 2 are both considered as second maximum.


Constraints:
`1 <= nums.length <= 104`
`-231 <= nums[i] <= 231 - 1`
Follow up: Can you find an `O(n)` solution?

### Solution 
 Below is a Python code using the LeetCode solution format that tackles the problem of finding the third maximum number in an array. The solution ensures that only distinct numbers are considered, and it operates efficiently in O(n) time.

The core idea is to traverse the array while maintaining a set of the top three distinct numbers. By limiting the size of this set to three and always removing the smallest when a new candidate for the top three is found, we efficiently maintain the largest three distinct integers during the traversal.



```python
class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        # A set to keep the top three distinct elements
        top_three = set()
        
        # Traverse each number in nums
        for num in nums:
            # Add the number to the set
            top_three.add(num)
            # If the set grows larger than 3 elements, remove the smallest
            if len(top_three) > 3:
                top_three.remove(min(top_three))
        
        # If we have less than 3 distinct numbers, return the maximum
        if len(top_three) < 3:
            return max(top_three)
        
        # Otherwise, return the third maximum, which is the smallest in the set
        return min(top_three)

# Example usage:
# sol = Solution()
# print(sol.thirdMax([3,2,1]))  # Output: 1
# print(sol.thirdMax([1,2]))    # Output: 2
# print(sol.thirdMax([2,2,3,1]))  # Output: 1

```

### Explanation:
1. **Initialize a Set**: We initialize a set `top_three` to keep track of the top three distinct numbers.
2. **Iterate the Array**: For each number in `nums`, we add the number to `top_three`.
3. **Maintain Set Size**: If the set size exceeds 3, we remove the smallest element. This ensures `top_three` only stores the largest three distinct numbers.
4. **Final Decision**:
     - If by the end of the iteration, we have less than three distinct numbers, we return the maximum of those present using the `max()` function.
     - If we have exactly three or more distinct numbers, the minimum of `top_three` will be our third maximum distinct number as it holds only three largest distinct values.
     
This method ensures that the solution runs in O(n) time because each operation (adding to set, removing the minimum when the set has more than three elements, and finding the min/max) is efficient with respect to the small size of the set even within a loop over `nums`. Further, this meets the constraint efficiently by not using additional data structures that would scale dramatically with input size, such as sorting or maintaining additional lists/maps.

# 442. Find All Duplicates in an Array

### Problem Description 
Given an array of integers, 1 â‰¤ a[i] â‰¤ n (n = size of array), some elements appear twice and others appear once.

Find all the elements that appear twice in this array.

Could you do it without extra space and in O(n) runtime?

Example:
Input:
[4,3,2,7,8,2,3,1]
Output:
[2,3]

### Solution 
 To solve this problem, we can take advantage of the constraints 1 â‰¤ a[i] â‰¤ n, where n is the size of the array. This property allows us to manipulate the indices of the array to keep track of what we have seen without requiring additional space.

A good strategy is to negate the value at the index specified by each element of the array. When we encounter a number, we go to the index corresponding to that number (we need to adjust by subtracting 1 because indices are zero-based) and negate the value at that index. If the value at that index is already negative, it means we have seen this number before, hence the current number is a duplicate.

Here is the Python code using this approach:



```python
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        duplicates = []
        for num in nums:
            index = abs(num) - 1
            if nums[index] < 0:
                duplicates.append(abs(num))
            else:
                nums[index] = -nums[index]
        return duplicates

```

### Detailed explanation:

1. **Loop through all elements in the array**:
    - For each `num` in `nums`, calculate its corresponding `index` as `abs(num) - 1`.
  
2. **Check and mark**:
    - Use the calculated `index` to access the value in `nums`.
    - If the value at `nums[index]` is negative, it indicates that the number at `index + 1` (i.e., `abs(num)`) has been seen before and thus, it's a duplicate. Add it to the duplicates list.
    - If not negative, negate the value at `nums[index]` to mark that the number `abs(num)` has been seen.

3. **Return the result**:
    - After the loop finishes, return the `duplicates` list containing all the duplicated numbers.

### Notes:

- The solution modifies the original array `nums` by negating the values. This is important to consider in case the array needs to be retained post-operation.
- No additional arrays are used, so it follows the requirement for no extra space, i.e., the space complexity is O(1).
- Time complexity is O(n) because the procedure consists of a single loop through the array of length n.

This solution should work when run directly on the LeetCode platform, as it complies with the expected function signature and requirements.

# 448. Find All Numbers Disappeared in an Array

### Problem Description 
Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return an array of all the integers in the range `[1, n]` that do not appear in `nums`.


Example 1:
Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]

Example 2:
Input: nums = [1,1]
Output: [2]

Constraints:
`n == nums.length`
`1 <= n <= 105`
`1 <= nums[i] <= n`
Follow up: Could you do it without extra space and in `O(n)` runtime? You may assume the returned list does not count as extra space.

### Solution 
 To solve this problem efficiently within the constraints provided, we can utilize the properties of the input array, such as its length and the range of its elements. Since all elements of `nums` are in the range `[1, n]`, we can use the input array itself to mark visited numbers. This approach allows us to solve the problem in `O(n)` time complexity without using additional space, except for the output list.

We can mark numbers by negating the value at the index corresponding to each number. By interpreting indices as relating to numbers (e.g., index 0 representing number 1), we will negate the value at each index relevant to the number in `nums`. After marking, the indices corresponding to non-negative numbers represent the missing numbers.

Here's the detailed Python code with comments explaining each step:



```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        # Length of the input array
        n = len(nums)
        
        # Process each number x in the array, where 1 <= x <= n
        for i in range(n):
            # Find the index where this number x should influence
            # The abs is necessary as numbers might have been negated earlier
            index = abs(nums[i]) - 1
            
            # Negate the number at this index to mark it as visited
            # Use negation as a marking strategy to avoid using extra space
            if nums[index] > 0:
                nums[index] = -nums[index]
        
        # Now, determine which indices have non-negated numbers,
        # those indices correspond to missing numbers
        result = []
        for i in range(n):
            if nums[i] > 0:
                # Since index 0 corresponds to number 1, etc.
                result.append(i + 1)
        
        return result


```

# 457. Circular Array Loop

### Problem Description 
You are playing a game involving a circular array of non-zero integers `nums`. Each `nums[i]` denotes the number of indices forward/backward you must move if you are located at index `i`:
If `nums[i]` is positive, move `nums[i]` steps forward, and
If `nums[i]` is negative, move `nums[i]` steps backward.

Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.

A cycle in the array consists of a sequence of indices `seq` of length `k` where:
Following the movement rules above results in the repeating index sequence `seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...`
Every `nums[seq[j]]` is either all positive or all negative.

`k > 1`
Return `true` if there is a cycle in `nums`, or `false` otherwise.


Example 1:
Input: nums = [2,-1,1,2,2]
Output: true
Explanation:
There is a cycle from index 0 -> 2 -> 3 -> 0 -> ...

The cycle's length is 3.


Example 2:
Input: nums = [-1,2]
Output: false
Explanation:
The sequence from index 1 -> 1 -> 1 -> ... is not a cycle because the sequence's length is 1.

By definition the sequence's length must be strictly greater than 1 to be a cycle.


Example 3:
Input: nums = [-2,1,-1,-2,-2]
Output: false
Explanation:
The sequence from index 1 -> 2 -> 1 -> ... is not a cycle because nums[1] is positive, but nums[2] is negative.

Every nums[seq[j]] must be either all positive or all negative.


Constraints:
`1 <= nums.length <= 5000`
`-1000 <= nums[i] <= 1000`
`nums[i] != 0`
Follow up: Could you solve it in `O(n)` time complexity and `O(1)` extra space complexity?

### Solution 
 To address the problem of finding a cycle in a circular array with a defined set of movement rules, we will use an algorithm based on the concept of slow and fast pointers. The solution must handle both forward and backward direction movements, and also edge cases as described in the prompt.

### Quick Recap:
1. Elements in the sequence can push the index either forward (positive values) or backward (negative values).
2. A cycle must include movement to at least two different indices and must strictly follow either positive or negative direction without mixing both.

### Strategy:
We will iterate through each index of the array and use two pointers (slow and fast) to try and detect a cycle starting from that index. For cycle detection traditionally in linked lists or sequences, the fast pointer moves twice as fast as the slow pointer. If they ever meet (and it's not the starting iteration), a cycle is detected.

### Approach:
- Start from each index and simulate the movement according to the rules.
- Use a slow and a fast pointer. The slow moves one step at a time while the fast moves two steps.
- If the slow pointer meets the fast pointer and both have traveled for more than one complete loop, we detected a cycle.
- To ensure correct direction movement, check at each step if the current movement is in the correct direction (all positive or all negative as per initial step).
- An important aspect is skipping over already checked indices efficiently without re-checking them multiple times.

### Implementation:



```python
class Solution:
    def circularNext(self, index, nums):
        """Helper function to compute the next index in the array, circularly."""
        n = len(nums)
        return (index + nums[index]) % n

    def circularArrayLoop(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 2:
            return False
        
        def detect_cycle(start):
            """Detects if there is a valid cycle starting from index 'start'."""
            direction = nums[start] > 0  # True if positive direction
            
            slow = fast = start
            while True:
                # Move slow pointer by 1 step
                slow = self.circularNext(slow, nums)
                if nums[slow] > 0 != direction:
                    return False

                # Move fast pointer by 2 steps
                fast = self.circularNext(fast, nums)
                if nums[fast] > 0 != direction:
                    return False
                fast = self.circularNext(fast, nums)
                if nums[fast] > 0 != direction:
                    return False

                # Check if they meet
                if slow == fast:
                    # To ensure there's more than one element in the cycle
                    if slow == self.circularNext(slow, nums):
                        return False
                    return True
        
        # Checking for a cycle starting from each element
        for i in range(n):
            if detect_cycle(i):
                return True
            nums[i] = 0  # Mark this element as visited
        
        return False

```

### Runtime Complexity:
The provided approach aims towards a near `O(n)` computation since each index is moved forward and ideally we would not re-visit indices if we mark them as processed once detected not to be a part of a cycle.

### Space Complexity:
The space complexity is `O(1)` additional space, since we reuse the input list for marking visited elements and only use a fixed amount of extra variables. The recursive or function stack overhead can be considered constant for this approach.

# 485. Max Consecutive Ones

### Problem Description 
Given a binary array, find the maximum number of consecutive 1s in this array.


Example 1:
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.

    The maximum number of consecutive 1s is 3.

Note:
The input array will only contain `0` and `1`.

The length of input array is a positive integer and will not exceed 10,000

### Solution 
 

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        max_ones = 0
        current_ones = 0
        
        # Loop through every element in the array
        for num in nums:
            if num == 1:
                # If the number is 1, increment the current consecutive ones count
                current_ones += 1
            else:
                # If the number is 0, update the max_ones if the current count is higher
                if current_ones > max_ones:
                    max_ones = current_ones
                # Reset current consecutive ones count
                current_ones = 0
        
        # Final check to cover the case where the array ends with 1s
        if current_ones > max_ones:
            max_ones = current_ones
        
        return max_ones  # Return the maximum of consecutive ones found

# The Solution class can now be used with a 'nums' list like an example below
# sol = Solution()
# print(sol.findMaxConsecutiveOnes([1,1,0,1,1,1]))  # Output: 3

```

### Detailed Explanation

**Approach:** 
This problem can be efficiently solved by iterating through the list and keeping track of the number of consecutive ones encountered so far. Whenever a zero is encountered, or at the end of the list, the current count of consecutive ones is compared with the maximum found so far, updating the maximum if necessary.

**Steps:**
1. Initialize two variables, `max_ones` and `current_ones`, to zero. `max_ones` will store the maximum number of consecutive ones found, and `current_ones` will keep the count of the current sequence of ones.
2. Iterate over each element in the given binary array:
   - If the element is `1`, increment the `current_ones` counter.
   - If the element is `0`, compare `current_ones` to `max_ones`. If `current_ones` is greater, update `max_ones`. Regardless, reset `current_ones` to zero after this because the sequence has been interrupted by a zero.
3. After exiting the loop, there's a final check to see if the last sequence of ones (if any) was the longest sequence. This handles cases where the array might end with a sequence of ones.
4. Return the value of `max_ones` which now contains the maximum number of consecutive ones in the array.

**Complexity Analysis:**
- Time complexity: O(n), where n is the number of elements in the array. This is because we go through the array once.
- Space complexity: O(1), as only a fixed amount of memory space is used regardless of the input size.

This efficient and straightforward approach ensures that the array is scanned only once, making it suitable for solving the problem within the constraints provided.

# 495. Teemo Attacking

### Problem Description 
In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.

You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.


Example 1:
Input: [1,4], 2
Output: 4
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. 
This poisoned status will last 2 seconds until the end of time point 2. 
And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. 
So you finally need to output 4.


Example 2:
Input: [1,2], 2
Output: 3
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. 
This poisoned status will last 2 seconds until the end of time point 2. 
However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. 
Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. 
So you finally need to output 3.

Note:
You may assume the length of given time series array won't exceed 10000.

You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.

### Solution 
 

```python
class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:
        if not timeSeries:
            return 0
        
        total_poison_time = 0
        n = len(timeSeries)
        
        for i in range(n - 1):
            # Calculate time differences between consecutive attacks
            time_diff = timeSeries[i + 1] - timeSeries[i]
            # Add the minimum of (time_diff or duration) to total time
            total_poison_time += min(time_diff, duration)
        
        # Add the duration for the last attack
        total_poison_time += duration
        
        return total_poison_time


```

### Detailed Explanation:

**Initialization**:
- The `findPoisonedDuration` method first checks if `timeSeries` is empty, and returns 0 if true, since no poisoning happens without any attacks.

**Iterate through the time points**:
- The loop `for i in range(n - 1)` runs through the attack times but stops before the last one. This is because it's comparing each attack time with the next one to check how long the poison from the first one will last before the next attack interrupts or not.
    - `time_diff = timeSeries[i + 1] - timeSeries[i]`: This calculates the time difference between two consecutive attack start times.
    - `total_poison_time += min(time_diff, duration)`: The poison duration from the time of attack is either the time until the next attack or the full duration, whichever is lesser. If an attack occurs before the previous poisoning ends, the poisoning duration is shortened to `time_diff`.

**Handle the last attack**:
- After exiting the loop, `total_poison_time += duration` ensures the duration of poison from the last attack is fully counted as there are no subsequent attacks to cut it short.

**Return the result**:
- `return total_poison_time` gives the accumulated poisoned time over the entire series of attacks.

**Complexity**:
- Time Complexity: O(n), where n is the number of elements in `timeSeries`. We pass through the list once.
- Space Complexity: O(1). Only a fixed amount of extra space is used regardless of the input size.

# 509. Fibonacci Number

### Problem Description 
The Fibonacci numbers, commonly denoted `F(n)` form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,
F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.

Given `n`, calculate `F(n)`.


Example 1:
Input: n = 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.


Example 2:
Input: n = 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.


Example 3:
Input: n = 4
Output: 3
Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.


Constraints:
`0 <= n <= 30`

### Solution 
 Here is a Python code to solve the problem using an iterative approach. This solution is efficient, with time complexity O(n) and space complexity O(1).



```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        
        a, b = 0, 1
        for _ in range(2, n+1):
            a, b = b, a + b
        return b

```

### Explanation

In the problem, we have to calculate the nth Fibonacci number using the relationship:
F(n) = F(n - 1) + F(n - 2), where F(0) = 0, and F(1) = 1.

**Approach**:
To solve this efficiently:
1. **Base case handling**: If the input `n` is less than 2, we can directly return `n` since F(0) is 0 and F(1) is 1.
2. **Iterative calculation**:
   - We can avoid the need for a full array by keeping track of only the last two elements at any time (Space optimization).
   - We initialize two variables:
     - `a` to `F(0)` which is `0`
     - `b` to `F(1)` which is `1`
   - Loop from 2 to `n` and, in each iteration, calculate `F(i)` as `a + b`. Assign `b`'s value to `a` and `F(i)` to `b`. This step simulates progressing through the Fibonacci sequence.
   - After the loop ends, `b` will hold the value of `F(n)`.

This solution runs in O(n) time because it calculates each Fibonacci number up to `n` once, using only O(1) space since it keeps only two variables to hold the sequence values, regardless of the input size. This avoids common issues seen in purely recursive implementations like redundant operations and large stack depth.

The iterative approach is particularly well-suited for LeetCode format since it's compact and handles all possible inputs in the defined constraints (0 <= n <= 30) very efficiently.

# 531. Lonely Pixel I

### Problem Description 
Given an `m x n` `picture` consisting of black `'B'` and white `'W'` pixels, return the number of black lonely pixels.

A black lonely pixel is a character `'B'` that located at a specific position where the same row and same column don't have any other black pixels.


Example 1:
Input: picture = [["W","W","B"],["W","B","W"],["B","W","W"]]
Output: 3
Explanation: All the three 'B's are black lonely pixels.


Example 2:
Input: picture = [["B","B","B"],["B","B","B"],["B","B","B"]]
Output: 0

Constraints:
`m == picture.length`
`n == picture[i].length`
`1 <= m, n <= 500`
`picture[i][j]` is `'W'` or `'B'`.

### Solution 
 Here is a Python solution for the specified problem using the LeetCode format. In this solution, we first count the number of black pixels ('B') in each row and each column. Then, we iterate through the matrix again to see if any 'B' is a lonely pixel by checking if it's the only 'B' in its row and column.

This approach ensures we only visit the matrix cells a constant number of times, making the solution efficient.



```python
class Solution:
    def findLonelyPixel(self, picture: List[List[str]]) -> int:
        if not picture:
            return 0
        
        m, n = len(picture), len(picture[0])
        
        row_count = [0] * m
        col_count = [0] * n
        
        # First Pass: Count the number of 'B's in each row and column
        for i in range(m):
            for j in range(n):
                if picture[i][j] == 'B':
                    row_count[i] += 1
                    col_count[j] += 1
        
        # Second Pass: Check if 'B's are lonely
        lonely_pixel_count = 0
        for i in range(m):
            for j in range(n):
                if picture[i][j] == 'B' and row_count[i] == 1 and col_count[j] == 1:
                    lonely_pixel_count += 1
        
        return lonely_pixel_count

```

### Explanation:
1. **Variable Initialization**: Two lists `row_count` and `col_count` are initialized to count the black pixels in each row and each column.
2. **First Pass (Lines 10-15)**: Loop through each cell in `picture`. Whenever 'B' is encountered, increment the corresponding counts in `row_count` and `col_count`.
3. **Second Pass (Lines 18-23)**: Loop through the matrix again. If a pixel is black ('B') and it's the only black pixel in both its row and column (as seen in `row_count` and `col_count`), then it is a lonely pixel.
4. **Return Result**: The total number of lonely pixels is returned.

This solution nicely separates the counting and checking phases and efficiently determines the number of lonely black pixels. Each cell is processed twice, resulting in a time complexity of \( O(m \times n) \), which is suitable given the problem constraints.

# 532. K-diff Pairs in an Array

### Problem Description 
Given an array of integers `nums` and an integer `k`, return the number of unique k-diff pairs in the array.

A k-diff pair is an integer pair `(nums[i], nums[j])`, where the following are true:
`0 <= i, j < nums.length`
`i != j`
`|nums[i] - nums[j]| == k`
Notice that `|val|` denotes the absolute value of `val`.


Example 1:
Input: nums = [3,1,4,1,5], k = 2
Output: 2
Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).

Although we have two 1s in the input, we should only return the number of unique pairs.


Example 2:
Input: nums = [1,2,3,4,5], k = 1
Output: 4
Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).


Example 3:
Input: nums = [1,3,1,5,4], k = 0
Output: 1
Explanation: There is one 0-diff pair in the array, (1, 1).


Example 4:
Input: nums = [1,2,4,4,3,3,0,9,2,3], k = 3
Output: 2

Example 5:
Input: nums = [-1,-2,-3], k = 1
Output: 2

Constraints:
`1 <= nums.length <= 104`
`-107 <= nums[i] <= 107`
`0 <= k <= 107`

### Solution 
 To solve the problem of finding unique k-diff pairs in the array, we can use a two-step approach that involves the use of a hash map (or dictionary in Python). Here's the detailed explanation of the approach:

1. **Construct a Frequency Map**:
   - First, we iterate through the array `nums` to build a frequency map which tells us how many times each number appears in the array. This helps in handling duplicates effectively and is crucial especially for the case when `k = 0`.

2. **Find Unique Pairs**:
   - If `k` is 0, we look for elements in the frequency map that have a count greater than or equal to 2 because a pair `(x, x)` can only count if x appears at least twice.
   - For `k > 0`, for each unique element `x` in `nums`, check if `x + k` exists in the map. This ensures that pairs are counted uniquely as order doesn't matter (i.e., `(x, x+k)` is the same as `(x+k, x)`).

This method ensures we get the O(n) runtime complexity since we traverse the list twice (once for creating the map and once for counting pairs). This is efficient given the constraints.

Below is a Python solution adhering to the specified format for direct execution on the LeetCode platform.



```python
from typing import List

class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:
        if k < 0:  # Since k < 0 makes no sense for absolute difference, we can return 0 immediately.
            return 0
        
        num_count = {}
        for num in nums:
            if num in num_count:
                num_count[num] += 1
            else:
                num_count[num] = 1
        
        result = 0
        if k == 0:
            # Only pairs (num, num) work, and we need at least two of the same number for such a pair
            for num in num_count:
                if num_count[num] > 1:
                    result += 1
        else:
            # Pairs (num, num + k) where num + k exists in the array
            for num in num_count:
                if (num + k) in num_count:
                    result += 1
        return result

# Example usage:
sol = Solution()
print(sol.findPairs([3, 1, 4, 1, 5], 2))  # Output: 2
print(sol.findPairs([1, 2, 3, 4, 5], 1))   # Output: 4
print(sol.findPairs([1, 3, 1, 5, 4], 0))   # Output: 1
print(sol.findPairs([1,2,4,4,3,3,0,9,2,3], 3))  # Output: 2
print(sol.findPairs([-1, -2, -3], 1))      # Output: 2

```

This code defines a class `Solution` with the method `findPairs`, which computes the number of unique k-diff pairs in an array `nums`. The example usages demonstrate testing the function with the provided inputs and outputs.

# 533. Lonely Pixel II

### Problem Description 
Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row R and column C that align with all the following rules:
 Row R and column C both contain exactly N black pixels.

 For all rows that have a black pixel at column C, they should be exactly the same as row R
The picture is represented by a 2D char array consisting of 'B' and 'W', which means black and white pixels respectively. 

Example:
Input:                                            
[['W', 'B', 'W', 'B', 'B', 'W'],    
 ['W', 'B', 'W', 'B', 'B', 'W'],    
 ['W', 'B', 'W', 'B', 'B', 'W'],    
 ['W', 'W', 'B', 'W', 'B', 'W']] 
N = 3
Output: 6
Explanation: All the bold 'B' are the black pixels we need (all 'B's at column 1 and 3).

        0    1    2    3    4    5         column index                                            
0    [['W', 'B', 'W', 'B', 'B', 'W'],    
1     ['W', 'B', 'W', 'B', 'B', 'W'],    
2     ['W', 'B', 'W', 'B', 'B', 'W'],    
3     ['W', 'W', 'B', 'W', 'B', 'W']]    
row index
Take 'B' at row R = 0 and column C = 1 as an example:
Rule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels. 
Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.

Note:
The range of width and height of the input 2D array is [1,200].

### Solution 
 To solve this problem, we can follow the steps outlined below. The code will be designed to efficiently compute the number of black pixels that satisfy the given conditions. 

Steps:
1. Count the number of black pixels 'B' in each row and store in a list.
2. Count the number of black pixels 'B' in each column and store in another list.
3. Create a mapping for each column to the rows which have a black pixel in that column. This is useful to identify which rows correspond to each column having a black pixel.
4. For each pixel that is black ('B'), check if the conditions are met:
   - The number of black pixels in its row is exactly N.
   - The number of black pixels in its column is exactly N.
   - All rows containing a black pixel in that column must be exactly the same as the current row.
5. If all conditions are satisfied, increment the result count by 1.

Here's the Python code following the above steps:



```python
class Solution:
    def findBlackPixel(self, picture: List[List[str]], N: int) -> int:
        if not picture or not picture[0]:
            return 0
        
        rows, cols = len(picture), len(picture[0])
        
        # Frequency count of black pixels per row and column
        row_count = [0] * rows
        col_count = [0] * cols
        for r in range(rows):
            for c in range(cols):
                if picture[r][c] == 'B':
                    row_count[r] += 1
                    col_count[c] += 1

        # A dictionary that will map column index to list of rows containing a black pixel in that column
        column_to_rows = {c: [] for c in range(cols)}
        for r in range(rows):
            for c in range(cols):
                if picture[r][c] == 'B':
                    column_to_rows[c].append(r)
        
        result = 0
        
        # Check each pixel if the conditions are met
        for r in range(rows):
            for c in range(cols):
                if picture[r][c] == 'B':
                    # Check if this row and column have exactly N black pixels
                    if row_count[r] == N and col_count[c] == N:
                        # Now verify that all rows in column_to_rows[c] are the same as row r
                        all_rows_match = True
                        for row_index in column_to_rows[c]:
                            if picture[row_index] != picture[r]:
                                all_rows_match = False
                                break
                        if all_rows_match:
                            result += 1
        
        return result

# This Solution class can now be used to instantiate an object and call the findBlackPixel method on a test case.

```

This approach optimally calculates the required "B" pixels while ensuring that all conditions are checked for each black pixel. Each check ensures that not only does the row/column have exactly N black pixels, but also that rows are identical where required, thus satisfying the given problem constraints.

# 548. Split Array with Equal Sum

### Problem Description 
Given an array with n integers, you need to find if there are triplets  (i, j, k) which satisfies following conditions:
 0 < i, i + 1 < j, j + 1 < k < n - 1 
 Sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and (k + 1, n - 1) should be equal. 
where we define that subarray (L, R) represents a slice of the original array starting from the element indexed L to the element indexed R.


Example:
Input: [1,2,1,2,1,2,1]
Output: True
Explanation:
i = 1, j = 3, k = 5. 
sum(0, i - 1) = sum(0, 0) = 1
sum(i + 1, j - 1) = sum(2, 2) = 1
sum(j + 1, k - 1) = sum(4, 4) = 1
sum(k + 1, n - 1) = sum(6, 6) = 1
Note:
 1 <= n <= 2000. 
 Elements in the given array will be in range [-1,000,000, 1,000,000].

### Solution 
 To solve the problem of finding triplets in an array such that the sum of specific subarrays around those triplets are all equal, we can employ a combination of prefix sums and hash tables. The steps are outlined as below:

1. **Compute Prefix Sums**: 
   Generate a prefix sum array to efficiently calculate the sum of any subarray. Given an array `arr`, the prefix sum array `prefix` is defined such that `prefix[i]` is the sum of elements from `arr[0]` to `arr[i-1]`.
   
2. **Using a Hash Table**:
   Use a hash table to store the sum and corresponding indices, where sums of subarrays are keys and the indices where the sums are achieved are values.

3. **Matching Conditions**: 
   Iterate through the array to determine if there exists indices `i`, `j`, and `k` such that the sums of the subarrays `(0, i-1)`, `(i+1, j-1)`, `(j+1, k-1)`, and `(k+1, n-1)` are equal.

4. **Nested Loops for Traversal**: 
   Use nested loops to check pairs of `j` and `k` while calculating potential index `i` using the hash map.

Based on the conditions given in the problem, the triplet should be carefully selected to ensure separation between indices as required.

Hereâ€™s how this solution can be implemented in Python designed to be run on LeetCode:



```python
class Solution:
    def splitArray(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 7:
            return False
            
        # Compute prefix sums
        prefix_sum = [0] * n
        prefix_sum[0] = nums[0]
        for i in range(1, n):
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]

        # Attempt to find a valid j and then a pair (i, k)
        for j in range(3, n - 3):
            seen_sums = set()
            # Find all i such that 0 < i < j - 1 and sum(0, i-1) == sum(i+1, j-1)
            for i in range(1, j - 1):
                if prefix_sum[i - 1] == (prefix_sum[j - 1] - prefix_sum[i]):
                    seen_sums.add(prefix_sum[i - 1])

            # Find all k such that j + 1 < k < n - 1 and sum(0, i-1) == sum(i+1, j-1) == sum(j+1, k-1) == sum(k+1, n-1)
            for k in range(j + 2, n - 1):
                if (prefix_sum[k - 1] - prefix_sum[j] == prefix_sum[-1] - prefix_sum[k]) and (prefix_sum[k - 1] - prefix_sum[j] in seen_sums):
                    return True

        return False

# Example usage:
# sol = Solution()
# print(sol.splitArray([1, 2, 1, 2, 1, 2, 1]))  # Output: True

```

This code efficiently finds whether there are any valid triplets `(i, j, k)` that satisfy the given conditions. The combination of prefix sums and hashing provides a good balance between time complexity and space complexity, suitable for array sizes as specified in the problem (up to 2000).

# 560. Subarray Sum Equals K

### Problem Description 
Given an array of integers `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals to `k`.


Example 1:
Input: nums = [1,1,1], k = 2
Output: 2

Example 2:
Input: nums = [1,2,3], k = 3
Output: 2

Constraints:
`1 <= nums.length <= 2 * 104`
`-1000 <= nums[i] <= 1000`
`-107 <= k <= 107`

### Solution 
 Here is a Python solution for the specified problem, using a cumulative sum approach improved with a hash map to directly count the occurrences of required sums. This solution meets the LeetCode format criteria, making it directly executable on the website.



```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        # Initialize the count of subarrays meeting the condition and the cumulative sum
        count, cumulative_sum = 0, 0
        
        # Hash Map to save the occurrence of each cumulative sum
        sum_map = {0: 1}  # Initialize with 0:1 to have an easy way to count the subarrays starting from index 0
        
        for num in nums:
            # Update the cumulative sum to current point
            cumulative_sum += num
            
            # Check if there exists a cumulative_sum before such that (current_cumulative_sum - k) is equal to that sum
            if (cumulative_sum - k) in sum_map:
                count += sum_map[cumulative_sum - k]
            
            # If the cumulative sum has been seen before, increment its count, otherwise add to map
            if cumulative_sum in sum_map:
                sum_map[cumulative_sum] += 1
            else:
                sum_map[cumulative_sum] = 1
        
        return count

# When running on LeetCode, the `List` type should be imported:
# from typing import List
# The `Solution` class should be used as:
# solution = Solution()
# print(solution.subarraySum([1,1,1], 2))  # Output: 2
# print(solution.subarraySum([1,2,3], 3))   # Output: 2

```

### Detailed Explanation:
1. **Cumulative Sum Concept**: We will maintain a cumulative sum that moves from the initial to the end of the array. At each step, we add the current number to the cumulative sum.

2. **Hash Map (sum_map)**: It stores occurrences of each of the cumulative sums. This allows us to efficiently check if `current_cumulative_sum - k` has occurred before, indicating a subarray that sums up to `k`.

3. **Initialization**: The hash map is initialized with `{0: 1}` to handle the case when the cumulative sum itself equals `k`, without needing another element to subtract from it.

4. **Iterate through nums**: For every number, we update `cumulative_sum` and check if there exists a past cumulative sum such that the difference between `cumulative_sum` and it is `k`. The count of such occurrences from the hash map is then added to our result count.

5. **Update sum_map**: If the `cumulative_sum` is already in the map, increment its count; otherwise, add it with a count of 1.

This method efficiently checks for the subarray count condition in O(n) time complexity due to the single-pass nature and direct hash map access operations.

# 561. Array Partition I

### Problem Description 
Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ..., (an, bn)` such that the sum of `min(ai, bi)` for all `i` is maximized. Return the maximized sum.


Example 1:
Input: nums = [1,4,3,2]
Output: 4
Explanation: All possible pairings (ignoring the ordering of elements) are:
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
So the maximum possible sum is 4.


Example 2:
Input: nums = [6,2,6,5,1,2]
Output: 9
Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.


Constraints:
`1 <= n <= 104`
`nums.length == 2 * n`
`-104 <= nums[i] <= 104`

### Solution 
 Below is the Python code for the problem description that maximizes the sum of pairs `(ai, bi)` so that the sum of `min(ai, bi)` is maximized for given `nums` with length `2n`.

The strategy to accomplish this is to:
1. Sort the array `nums`.
2. Pair the elements from the sorted array by taking the first and the second elements as one pair, the third and the fourth elements as another, and so on.
3. By doing this, we ensure that we pair the smallest element with the next smallest, which maximizes the sum of minimums for all pairs.

The following Python code follows the typical structure of a LeetCode problem solution, and you can run it directly on LeetCode:



```python
from typing import List

class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        # Step 1: Sort the array
        nums.sort()
        
        # Step 2: Initialize the sum of minimums
        sum_min = 0
        
        # Step 3: Add min of each pair (nums[i], nums[i+1])
        # Only take elements at even index positions (0, 2, 4, ...)
        # because the minimum in each sorted pair (ai, bi = ai+1) is ai,
        # where i is even.
        for i in range(0, len(nums), 2):
            sum_min += nums[i]
        
        return sum_min

# Example use case
sol = Solution()
print(sol.arrayPairSum([1,4,3,2]))  # Output: 4
print(sol.arrayPairSum([6,2,6,5,1,2]))  # Output: 9

```

### Explanation:
- **Sorting**: Sorting places each element in such a manner that, when paired sequentially from the sorted list, the larger values do not overwhelm the smaller ones, hence maximizing the sum of the minimums of these pairs.
- **Summation of Pair Minimums**: Once sorted, the minimum of pairs formed by sequential elements is always the first (or even-indexed) element of the pair when considered two at a time. Therefore, by iterating through the array with a step size of 2 (picking every even-indexed element), the sum can be efficiently calculated.

This solution has a time complexity of O(n log n) primarily due to the sort operation. The space complexity is O(1) or O(n), depending on the sorting implementation in Python.

# 562. Longest Line of Consecutive One in Matrix

### Problem Description 
Given a 01 matrix M, find the longest line of consecutive one in the matrix. The line could be horizontal, vertical, diagonal or anti-diagonal.


Example:
Input:
[[0,1,1,0],
 [0,1,1,0],
 [0,0,0,1]]
Output: 3
Hint:
The number of elements in the given matrix will not exceed 10,000.

### Solution 
 To find the longest line of consecutive ones in the given 2D matrix, we will examine each element and update the maximum length found for lines in four directions: horizontal, vertical, diagonal, and anti-diagonal. For this, we can use dynamic programming. Specifically, we'll maintain four separate matrices or tables to store the length of consecutive ones ending at each position in each of the four directions. Here's a clearer step-by-step plan:

1. **Initialization**: Create four matrices `horizontal`, `vertical`, `diagonal`, and `anti_diagonal` to save the length of consecutive ones upto a particular cell in respective directions.

2. **Matrix Traversal**: Traverse through each cell in the input matrix. At each cell `(i, j)`:
   - If `M[i][j]` is 0, the length of consecutive ones in all four directions is 0.
   - If `M[i][j]` is 1, for each of the direction matrices:
     - **Horizontal:** Look at the previous cell in the same row.
     - **Vertical:** Look at the previous cell in the same column.
     - **Diagonal:** Look at the cell at top-left diagonal `(i-1, j-1)`.
     - **Anti-Diagonal:** Look at the cell at top-right diagonal `(i-1, j+1)`.

3. **Boundary Check**: For each direction, check boundary conditions to avoid index errors (like accessing a negative index).

4. **Update and Record Maximum**: Update the value in the respective direction matrix and track the global maximum length found.

5. **Result**: The global maximum after traversing the matrix will be the longest consecutive line of ones.

Now let's code this in the requested LeetCode solution format:



```python
class Solution:
    def longestLine(self, M):
        if not M or not M[0]:
            return 0

        n, m = len(M), len(M[0])
        max_len = 0
        horizontal = [[0] * m for _ in range(n)]
        vertical = [[0] * m for _ in range(n)]
        diagonal = [[0] * m for _ in range(n)]
        anti_diagonal = [[0] * m for _ in range(n)]

        for i in range(n):
            for j in range(m):
                if M[i][j] == 1:
                    horizontal[i][j] = horizontal[i][j-1] + 1 if j > 0 else 1
                    vertical[i][j] = vertical[i-1][j] + 1 if i > 0 else 1
                    diagonal[i][j] = diagonal[i-1][j-1] + 1 if i > 0 and j > 0 else 1
                    anti_diagonal[i][j] = anti_diagonal[i-1][j+1] + 1 if i > 0 and j < m - 1 else 1

                    max_len = max(max_len, horizontal[i][j], vertical[i][j], diagonal[i][j], anti_diagonal[i][j])

        return max_len

# Example usage
M = [
    [0,1,1,0],
    [0,1,1,0],
    [0,0,0,1]
]
sol = Solution()
print(sol.longestLine(M))  # Output: 3

```

This comprehensive solution effectively uses 2D DP tables to track the length of lines in different directions and updates a global maximum length encountered so far. It iterates through the matrix only once, making it efficient. Each DP matrix keeps track of lengths ensuring that only relevant past information is utilized to compute current values.

# 565. Array Nesting

### Problem Description 
A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.

Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]... By that analogy, we stop adding right before a duplicate element occurs in S.


Example 1:
Input: A = [5,4,0,3,1,6,2]
Output: 4
Explanation: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

One of the longest S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
Note:
N is an integer within the range [1, 20,000].

The elements of A are all distinct.

Each element of A is an integer within the range [0, N-1].

### Solution 
 To tackle this problem in Python and be suitable for testing on the LeetCode platform, we should focus on the requirements and constraints given:
- Every array element points to some index of the same array, resembling a directed graph where an element with index `i` points to index `A[i]`.
- The target is to find the longest cycle in this graph, knowing there can't be any disjoint subpaths because every element uniquely maps to another.

To solve this problem, we'll utilize cycle detection in the graph. Since every node (i.e., array element) points to exactly one other node, the graph is made up of one or more disjoint cycles. The goal is to find the longest of these cycles.

We can use a visited array to track which nodes have been checked, and for each unvisited node, explore the cycle it starts, marking nodes along the way.

Hereâ€™s how the code will look following the explanation above:



```python
class Solution:
    def arrayNesting(self, nums):
        visited = [False] * len(nums)
        max_len = 0

        for i in range(len(nums)):
            if not visited[i]:
                # Start of a new set S[K]
                current_set_len = 0
                current_index = i
                
                # Traverse the cycle starting from the index i
                while not visited[current_index]:
                    visited[current_index] = True
                    current_index = nums[current_index]
                    current_set_len += 1

                # Update maximum length found
                max_len = max(max_len, current_set_len)
        
        return max_len

```

### Explanation:
1. **Initialization**: We create a `visited` list initialized to `False`, indicating that no index has been visited yet. `max_len` is initialized to 0 to track the maximum length of set S found.

2. **Cycle Detection Loop**: For each index `i` in the list, if it hasn't been visited:
    - Initialize `current_set_len` to 0 to start counting the cycle's length.
    - Use `current_index` to traverse through the indexes as defined by `nums[current_index]`. Continue the cycle until a visited index is found (which indicates the cycle's end).
    - Along the way, mark each index as visited.
    - After completing a cycle, update the maximum length if the current cycle's length exceeds the previously found maximum.

3. **Return Result**: After completing the loop for all indexes, return `max_len` as the result, which contains the length of the longest set `S` derived from `nums`.

This algorithm is efficient and runs in `O(N)` time complexity, as each element in the list is part of exactly one complete traversal of a cycle. Space complexity is also `O(N)` due to the `visited` list.

# 566. Reshape the Matrix

### Problem Description 
In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.

You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.

The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.

If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.


Example 1:
Input: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
Output: 
[[1,2,3,4]]
Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.


Example 2:
Input: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
Output: 
[[1,2],
 [3,4]]
Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.

Note:
The height and width of the given matrix is in range [1, 100].

The given r and c are all positive.

### Solution 
 To solve the problem of reshaping a matrix as described, we need to follow a systematic approach:

1. **Validate the Reshape Condition**: First, check if reshaping is possible by ensuring that the total number of elements in the original matrix (`rows * cols`) matches the total number of elements required for the reshaped matrix (`r * c`). If this condition isn't met, return the original matrix.

2. **Flatten and Reshape**: If reshaping is possible:
   - Flatten the matrix by iterating through all elements row-wise.
   - Construct the reshaped matrix by filling it with elements from the flattened matrix in the needed order.

3. **Output the Result**: Depending on the validation in step 1, output either the reshaped matrix or the original matrix.

The following Python code implements this approach suitable for running directly on LeetCode as a solution:



```python
class Solution:
    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:
        original_rows = len(nums)
        original_cols = len(nums[0])
        
        # Check if reshape is possible
        total_elements = original_rows * original_cols
        if total_elements != r * c:
            return nums
        
        # Initialize the reshaped matrix
        reshaped = [[0] * c for _ in range(r)]
        
        # Fill the reshaped matrix
        flat_list = []
        for row in nums:
            flat_list.extend(row)
        
        for i in range(total_elements):
            reshaped[i // c][i % c] = flat_list[i]
        
        return reshaped

# Example usage:
sol = Solution()
print(sol.matrixReshape([[1,2], [3,4]], 1, 4))  # Output: [[1, 2, 3, 4]]
print(sol.matrixReshape([[1,2], [3,4]], 2, 4))  # Output: [[1, 2], [3, 4]]

```

**Explanation**:
- The `matrixReshape` method first extracts the dimensions of the input matrix and calculates the total number of elements.
- It checks if the total elements are the same for the original and the expected reshaped matrix. If not, it immediately returns the input matrix (`nums`).
- Then, a flattened list of matrix elements is created.
- Elements from this flat list are placed into the `reshaped` matrix based on their indices by converting the flattened index to two-dimensional indices (`i // c` for rows and `i % c` for columns).
- This results in the construction of the reshaped matrix, which is returned.

This solution adheres to typical LeetCode constraints and python programming practices and should work within the environment seamlessly.

# 581. Shortest Unsorted Continuous Subarray

### Problem Description 
Given an integer array `nums`, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.

Return the shortest such subarray and output its length.


Example 1:
Input: nums = [2,6,4,8,10,9,15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.


Example 2:
Input: nums = [1,2,3,4]
Output: 0

Example 3:
Input: nums = [1]
Output: 0

Constraints:
`1 <= nums.length <= 104`
`-105 <= nums[i] <= 105`
Follow up: Can you solve it in `O(n)` time complexity?

### Solution 
 To address the problem, we need to pinpoint the exact segment of the array `nums` that disrupts the sorted order when the left and right segments of this segment are correctly ordered. The core idea is to identify the boundaries of the shortest subarray that, when sorted, will sort the whole array.

### Plan:

1. **Identify the Left Boundary**:
   - Traverse from the beginning of the array and find the first element that is greater than the next element (i.e., the beginning of the first descent).

2. **Identify the Right Boundary**:
   - Traverse from the end of the array backwards and find the first element that is smaller than the previous element (i.e., the beginning of the first ascent from the end).

3. **Determine the Minimum and Maximum Values in the Unsorted Segment**:
   - Traverse the array between the initial boundaries discovered in the steps above to find the minimum and maximum values in this segment.

4. **Adjust the Boundaries**:
   - With the minimum and maximum values known, sometimes it's necessary to extend the boundaries if there are elements outside our initial guesses that are less than the maximum of the detected segment or greater than the minimum.

5. **Calculate the Length of this Segment**:
   - Check if there's any need to sort; if not, return 0. Otherwise, compute the length from adjusted boundaries.

### The code:



```python
class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        if not nums or len(nums) == 1:
            return 0
        
        n = len(nums)
        start, end = -1, -1
        
        # finding the initial boundaries of the unsorted subarray
        for i in range(1, n):
            if nums[i] < nums[i - 1]:
                start = i - 1
                break
            
        for i in range(n - 2, -1, -1):
            if nums[i] > nums[i + 1]:
                end = i + 1
                break
        
        if start == -1 or end == -1:  # already sorted
            return 0
        
        # determine the min and max values in this unsorted segment
        subarray_min = min(nums[start:end + 1])
        subarray_max = max(nums[start:end + 1])
        
        # adjust the left boundary if needed
        while start > 0 and nums[start - 1] > subarray_min:
            start -= 1
        
        # adjust the right boundary if needed
        while end < n and nums[end] < subarray_max:
            end += 1
        
        # length of the sub array to be sorted
        length = end - start
        
        return length if length > 0 else 0

```

### Explanation:

- Two passes help find base boundaries where array first breaks from being ordered correctly.
- The middle pass to find min and max helps adjust the boundaries accurately.
- Finally, we correct and measure the length of the subarray that if sorted would make the list ordered. 

### Time Complexity:

- The solution's time complexity is **O(n)** due to several linear passes through the data. This meets the challenge of solving the problem in linear time as proposed in the prompt.

# 605. Can Place Flowers

### Problem Description 
You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.

Given an integer array `flowerbed` containing `0`'s and `1`'s, where `0` means empty and `1` means not empty, and an integer `n`, return if `n` new flowers can be planted in the `flowerbed` without violating the no-adjacent-flowers rule.


Example 1:
Input: flowerbed = [1,0,0,0,1], n = 1
Output: true

Example 2:
Input: flowerbed = [1,0,0,0,1], n = 2
Output: false

Constraints:
`1 <= flowerbed.length <= 2 * 104`
`flowerbed[i]` is `0` or `1`.

There are no two adjacent flowers in `flowerbed`.

`0 <= n <= flowerbed.length`

### Solution 
 To solve this problem, we need to determine if it's possible to plant `n` flowers in the given `flowerbed` array without any two flowers being adjacent. Each element in the `flowerbed` can either be `0` (empty) or `1` (occupied). 

### Key Points:
1. We can only plant a flower in a plot if it's currently empty (`0`), and both the left and right adjacent plots (if they exist) are also empty.
2. We will iterate over the `flowerbed` and try to plant flowers whenever the conditions are met.
3. We should stop and return `True` immediately once we have planted `n` flowers.
4. If we finish iterating through the `flowerbed` without planting all `n` flowers, we return `False`.

### Approach:
1. Iterate through each plot in the `flowerbed`.
2. For each plot, check if it's empty and if its adjacent plots are also empty or non-existent (edge cases).
3. If conditions are met, "plant a flower" (set the current plot to `1`) and decrement `n`.
4. If `n` reaches `0` during this process, return `True` since we have successfully planted all required flowers.
5. If the loop completes and we haven't planted all flowers, return `False`.

### Edge Cases to Consider:
- Flowerbeds of length 1.
- All plots are already occupied.
- Required `n` is `0`.

Below is the python code implementing this logic that can be directly used for a submission on LeetCode:



```python
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        length = len(flowerbed)
        count = 0
        
        for i in range(length):
            if flowerbed[i] == 0:
                # Check adjacent plots (left and right)
                prev = (i == 0 or flowerbed[i - 1] == 0)
                next = (i == length - 1 or flowerbed[i + 1] == 0)
                
                if prev and next:
                    # Plant a flower here
                    flowerbed[i] = 1
                    count += 1
                    
                    # If we've planted enough flowers, return True
                    if count >= n:
                        return True
        
        # After the loop, if we still have not planted enough flowers
        return count >= n

# Example usage:
sol = Solution()
print(sol.canPlaceFlowers([1,0,0,0,1], 1))  # Output: True
print(sol.canPlaceFlowers([1,0,0,0,1], 2))  # Output: False

```

This code checks each index in the `flowerbed` array and tries to plant a flower by obeying the given rules. We increment the `count` each time a flower is planted, and we immediately return `True` if `count` reaches or exceeds `n`. If the loop completes and we haven't planted enough flowers, we return `False`. This solution ensures an O(n) time complexity, which is efficient for the problem's constraints.

# 611. Valid Triangle Number

### Problem Description 
Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.


Example 1:
Input: [2,2,3,4]
Output: 3
Explanation:
Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
Note:
The length of the given array won't exceed 1000.

The integers in the given array are in the range of [0, 1000].

### Solution 
 To solve the problem of counting the number of triplets that can form a triangle from an array of non-negative integers, we can utilize the properties of a triangle. For three sides \(a\), \(b\), and \(c\) to form a triangle, they must satisfy the triangle inequality theorem, which states:
\[ a + b > c, \]
\[ a + c > b, \]
\[ b + c > a. \]

A more efficient way to verify this after sorting the sides in non-decreasing order (let's say \(a \leq b \leq c\)) is to check just:
\[ a + b > c. \]

### Strategy:
1. **Sort the Array**: First, sort the array. This simplifies the checking process, as now you only need to check if the sum of the two smallest numbers is greater than the largest number in any triplet.
2. **Use Three Pointers**: Use three pointers to test all combinations.
   - Fix the largest number with a pointer \( k \).
   - Use two more pointers \( i \) and \( j \), where \( i \) starts from the beginning of the array and \( j \) starts just before \( k \).
   - If \( nums[i] + nums[j] > nums[k] \), then all the combinations from \( i \) to \( j \) with \( k \) are valid triangles (because the condition is already satisfied).
   - If the condition isn't satisfied, increment \( i \).

### Time Complexity:
1. The sorting step takes \( O(n \log n) \).
2. The two-pointer technique inside the \( k \) iteration runs in \( O(n^2) \) in total across all outer loop iterations.
Thus, the complete solution is \( O(n^2) \).

### Python Code:



```python
def triangleNumber(nums):
    nums.sort()
    n = len(nums)
    count = 0
    
    for k in range(2, n):
        i, j = 0, k - 1
        while i < j:
            if nums[i] + nums[j] > nums[k]:
                count += (j - i)
                j -= 1
            else:
                i += 1

    return count

# Example Usage
print(triangleNumber([2,2,3,4]))  # Output: 3

```

### Explanation:
- **Sort**: The input array is sorted to allow the utilization of binary properties.
- **Triple Loop Logic with Two Pointers**:
  - `k` iterates over all possible maximum sides of the triangle from the third element to the end.
  - `i` and `j` are used to find numbers which can form a triangle with `nums[k]`. The algorithm checks if the sum of `nums[i]` and `nums[j]` is greater than `nums[k]`.
  - Adjust `i` or `j` depending on whether the condition is met or not, counting the valid triplets in the process.

This solution efficiently covers all possible combinations in \( O(n^2) \), leveraging sorting and the two-pointer technique.

# 621. Task Scheduler

### Problem Description 
Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.

However, there is a non-negative integer `n` that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least `n` units of time between any two same tasks.

Return the least number of units of times that the CPU will take to finish all the given tasks.


Example 1:
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: 
A -> B -> idle -> A -> B -> idle -> A -> B
There is at least 2 units of time between any two same tasks.


Example 2:
Input: tasks = ["A","A","A","B","B","B"], n = 0
Output: 6
Explanation: On this case any permutation of size 6 would work since n = 0.

["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...

And so on.


Example 3:
Input: tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
Output: 16
Explanation: 
One possible solution is
A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A

Constraints:
`1 <= task.length <= 104`
`tasks[i]` is upper-case English letter.

The integer `n` is in the range `[0, 100]`.

### Solution 
 Below is a Python solution to the described problem following the LeetCode format. It utilizes a priority queue (or max-heap) to manage tasks based on their frequencies, ensuring the task with the highest frequency is scheduled first after the cooldown period.

This solution involves counting the task frequencies, using a heap to simulate the scheduling of tasks based on these frequencies, and using a counter to track the total time or number of intervals required.



```python
from typing import List
import collections
import heapq

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        # Dictionary to count the frequency of each task
        task_counts = collections.Counter(tasks)
        
        # Creating a max-heap based on the negative values of task counts
        max_heap = [-cnt for cnt in task_counts.values()]
        heapq.heapify(max_heap)
        
        # Total intervals that we count as time progresses
        time = 0
        
        # List to store tasks that are in the cooldown period
        cooldown_queue = []
        
        # Process until there are no tasks left in the heap
        while max_heap or cooldown_queue:
            time += 1
            
            if max_heap:
                # Take the most frequent task left (as max-heap is negative, pop smallest)
                current = heapq.heappop(max_heap) + 1   # Increment because we use -cnt
                if current != 0:
                    # If the task is not exhausted, add it to cooldown queue
                    cooldown_queue.append((current, time + n))
                    
            if cooldown_queue and cooldown_queue[0][1] == time:
                # Re-add the task from cooldown queue to heap if the cooldown has expired
                heapq.heappush(max_heap, cooldown_queue.pop(0)[0])
        
        return time

# Example test cases (these can be run in a LeetCode submit to validate the solution):
tasks = ["A","A","A","B","B","B"]
n = 2
sol = Solution()
print(sol.leastInterval(tasks, n))  # Output: 8

tasks = ["A","A","A","B","B","B"]
n = 0
print(sol.leastInterval(tasks, n))  # Output: 6

tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"]
n = 2
print(sol.leastInterval(tasks, n))  # Output: 16

```

### Explanation:
1. **Task Frequency Counting**:
   We first use a `Counter` to get the frequencies of each task.
   
2. **Heap Initialization**:
   Create a max-heap (using negatives because Python's `heapq` provides a min-heap) based on these frequencies. Higher frequency tasks should be processed first to reduce future idle times.
   
3. **Scheduling Simulation**:
   We continuously process tasks from the heap. After executing a task, it needs to be on cooldown for `n` time units.
   
4. **Cooldown Management**:
   We use a separate queue (`cooldown_queue`) to manage tasks that are cooling down. We only re-insert a task from this cooldown queue back into the heap when its cooldown has expired.
   
5. **Count Total Time**:
   For every unit of processing (whether a task is executed or the CPU is idle), we increment a timer (`time`). The loop continues until all tasks are processed, including necessary idle times. The final value of `time` represents the minimum units of time the CPU will take to finish all tasks.

# 624. Maximum Distance in Arrays

### Problem Description 
You are given `m` `arrays`, where each array is sorted in ascending order.

You can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers `a` and `b` to be their absolute difference `|a - b|`.

Return the maximum distance.


Example 1:
Input: arrays = [[1,2,3],[4,5],[1,2,3]]
Output: 4
Explanation: One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.


Example 2:
Input: arrays = [[1],[1]]
Output: 0

Example 3:
Input: arrays = [[1],[2]]
Output: 1

Example 4:
Input: arrays = [[1,4],[0,5]]
Output: 4

Constraints:
`m == arrays.length`
`2 <= m <= 105`
`1 <= arrays[i].length <= 500`
`-104 <= arrays[i][j] <= 104`
`arrays[i]` is sorted in ascending order.

There will be at most `105` integers in all the arrays.

### Solution 
 Here's a Python solution suitable for the specified problem, including detailed comments and explanation that conforms to the expected LeetCode format:



```python
from typing import List

class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        """
        This function computes the maximum distance between two elements from different arrays,
        where the distance is defined as the absolute difference between those elements.
        
        To solve this, keep track of the minimum and maximum values found so far along with their originating index
        because we need to ensure that the minimum and maximum values come from different arrays.
        """
        max_distance = 0
        min_val, min_index = arrays[0][0], 0
        max_val, max_index = arrays[0][-1], 0
        
        # Traverse each array from the second one to the last one
        for i in range(1, len(arrays)):
            current_min = arrays[i][0]
            current_max = arrays[i][-1]
            
            # Calculate distance with previously tracked max and min values
            if i != min_index:
                max_distance = max(max_distance, abs(current_max - min_val))
            if i != max_index:
                max_distance = max(max_distance, abs(current_min - max_val))
            
            # Update global min and max if current array's values are extremum
            if current_min < min_val:
                min_val, min_index = current_min, i
            if current_max > max_val:
                max_val, max_index = current_max, i
        
        return max_distance

# Example usage:
if __name__ == "__main__":
    sol = Solution()
    print(sol.maxDistance([[1,2,3],[4,5],[1,2,3]]))  # Output: 4
    print(sol.maxDistance([[1],[1]]))  # Output: 0
    print(sol.maxDistance([[1],[2]]))  # Output: 1
    print(sol.maxDistance([[1,4],[0,5]]))  # Output: 4

```

### Explanation:

1. **Initialization**: We begin by noting the first array's minimum (`min_val`) and maximum (`max_val`) values, engaging the rest of the arrays from that established starting point.

2. **Iterate Through Arrays**: For every other array:
  - Check the possible distance from current array's min/max to the running max/min recorded.
  - We ensure we calculate distance only with different arrays' values by comparing indices.
  - Update global `max_distance` if new calculated distances exceed the previously recorded max distance.

3. **Maintain Global Min and Max**: Update the global minimum and maximum values if the current array provides a new extreme not previously encountered.

This approach is efficient with a time complexity of \(O(m)\) where \(m\) is the number of arrays, given that we perform a constant time operation for each array (update checks and distance calculations).

# 628. Maximum Product of Three Numbers

### Problem Description 
Given an integer array `nums`, find three numbers whose product is maximum and return the maximum product.


Example 1:
Input: nums = [1,2,3]
Output: 6

Example 2:
Input: nums = [1,2,3,4]
Output: 24

Example 3:
Input: nums = [-1,-2,-3]
Output: -6

Constraints:
`3 <= nums.length <= 104`
`-1000 <= nums[i] <= 1000`

### Solution 
 To solve this problem, you need to find the product of three numbers from the array `nums` that yields the maximum possible result. Given the array can contain both positive and negative numbers, you should consider multiple cases where the product becomes maximum:

1. **The product of the three largest positive numbers.** This is straightforward since multiplying larger numbers results in a higher product.

2. **The product of two smallest negative numbers and the largest positive number.** This case can yield a maximum product when negative numbers are involved because the product of two negative numbers is positive, and multiplying this by the largest positive number can yield a very large product.

To efficiently find the solution, sort the array and then consider these two cases:
- The product of the last three elements (`nums[n-1] * nums[n-2] * nums[n-3]`) which are the three largest numbers.
- The product of the first two elements (the two smallest, which could be negative) and the largest element (`nums[0] * nums[1] * nums[n-1]`).

Once the array is sorted, both these calculations can be accomplished in constant time. Thus, by sorting the array (which takes O(n log n) time due to comparison sorting limits), the solution can be determined efficiently.

Here's the solution in Python following the required LeetCode solution format:



```python
class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        nums.sort()
        # Last three in sorted array
        max1 = nums[-1] * nums[-2] * nums[-3]
        # First two (potentially negative) and the largest one
        max2 = nums[0] * nums[1] * nums[-1]
        # Return the maximum of max1 and max2
        return max(max1, max2)

# Example usage:
sol = Solution()
print(sol.maximumProduct([1, 2, 3]))  # Output: 6
print(sol.maximumProduct([1, 2, 3, 4]))  # Output: 24
print(sol.maximumProduct([-1, -2, -3]))  # Output: -6

```

This code defines a class `Solution` with a method `maximumProduct` which accepts a list of integers and returns the maximum product of any three numbers from that list. The `.sort()` method is applied to sort the array, and then we calculate both potential maximum products (max1 and max2) and return the larger of the two.

# 643. Maximum Average Subarray I

### Problem Description 
Given an array consisting of `n` integers, find the contiguous subarray of given length `k` that has the maximum average value. And you need to output the maximum average value.


Example 1:
Input: [1,12,-5,-6,50,3], k = 4
Output: 12.75
Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75
Note:
1 <= `k` <= `n` <= 30,000.

Elements of the given array will be in the range [-10,000, 10,000].

### Solution 
 To solve this problem, we will use the "sliding window" technique. It is ideal for problems where you need to examine a contiguous block of elements in an array, especially when the size of that block remains constant as in this case with `k`.

The approach will be as follows:
1. First, calculate the sum of the first `k` numbers in the array. This will be the initial value of our sum for the first window of size `k`.
2. Use a loop to slide the window across the array from the start to `n-k`:
   - Subtract the element that is left out of the window.
   - Add the element that is now included in the window.
   - Keep track if the new sum is greater than the previously known maximum sum.
   - Slide the window one element to the right.
3. To find the maximum average, divide the maximum sum by `k`. 

This method ensures we only traverse the array once, providing a time complexity of `O(n)` and a space complexity of `O(1)` since we are using a fixed number of variables.

The following Python code implements this approach:



```python
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        # Calculate the sum of the first 'k' elements
        current_sum = sum(nums[:k])
        max_sum = current_sum
        
        # Slide the window, keeping track of the max sum
        for i in range(k, len(nums)):
            # Update the sum to reflect the sliding window
            current_sum += nums[i] - nums[i - k]
            # Update max_sum if current_sum is larger
            if current_sum > max_sum:
                max_sum = current_sum
        
        # Divide by 'k' to get the maximum average
        return max_sum / k

```

You can test this code directly on LeetCode by submitting it to the relevant problem. It will check if the solution meets the problem requirements under various test cases, ensuring its correctness and efficiency.

# 644. Maximum Average Subarray II

### Problem Description 
You are given an integer array `nums` consisting of `n` elements, and an integer `k`.

Find a contiguous subarray whose length is greater than or equal to `k` that has the maximum average value and return this value. Any answer with a calculation error less than `10-5` will be accepted.


Example 1:
Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation:
- When the length is 4, averages are [0.5, 12.75, 10.5] and the maximum average is 12.75
- When the length is 5, averages are [10.4, 10.8] and the maximum average is 10.8
- When the length is 6, averages are [9.16667] and the maximum average is 9.16667
The maximum average is when we choose a subarray of length 4 (i.e., the sub array [12, -5, -6, 50]) which has the max average 12.75, so we return 12.75
Note that we do not consider the subarrays of length < 4.


Example 2:
Input: nums = [5], k = 1
Output: 5.00000

Constraints:
`n == nums.length`
`1 <= k <= n <= 104`
`-104 <= nums[i] <= 104`

### Solution 
 To tackle the problem described, the main task is to find the contiguous subarray of length at least `k` that has the maximum average value. We use a sliding window technique combined with prefix sums to efficiently compute the sums of subarrays and derive their averages.

Here's the approach summarized:
1. **Initialize Prefix Sum**: First compute a prefix sum array such that the sum of elements from the start up to index `i` can be obtained quickly.
2. **Sliding Window for Averages**: Use a sliding window of variable size that starts from `k` and goes up to `n`. For each size of this window, slide across the list and compute the sum using the prefix sum array. Track the maximum average found.
3. **Edge Cases**: Deal with scenarios where there's a single element or when `k` equals `n` directly using simple computations.

Below is the Python solution that implements the above approach:



```python
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        # First, we create a list that holds the prefix sums
        n = len(nums)
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
        
        # We set an initial maximum average as very small value
        max_average = float('-inf')
        
        # Calculate maximum average for all possible subarrays of length >= k
        for length in range(k, n + 1):
            for i in range(length, n + 1):
                # Calculate the sum of subarray from index (i-length) to (i-1)
                subarray_sum = prefix_sum[i] - prefix_sum[i - length]
                # Calculate average
                subarray_avg = subarray_sum / length
                # Update maximum average found
                if subarray_avg > max_average:
                    max_average = subarray_avg
        
        return max_average

# The given class `Solution` can be directly used to instantiate and call `findMaxAverage` method with test cases as provided in the problem description

```

### Explanation:
- `prefix_sum` helps in retrieving the sum of any subarray in constant time which ensures efficiency.
- The sliding window facilitated by adjusting the start (`i-length`) and end (`i-1`) indices for a given length leads us through all possible subarrays of that particular length.
- We compute the average for every valid subarray of length >= `k` and update the `max_average` whenever a higher average is found.

With the approach set up as above, you can directly paste the provided code in a Python (3.x) interpreter environment inside the LeetCode platform, and it should be able to execute and solve the problem efficiently within given constraints.

# 661. Image Smoother

### Problem Description 
Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can.


Example 1:
Input:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
Output:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
Explanation:
For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
For the point (1,1): floor(8/9) = floor(0.88888889) = 0
Note:
The value in the given matrix is in the range of [0, 255].

The length and width of the given matrix are in the range of [1, 150].

### Solution 
 To tackle this problem, we will traverse each element in the matrix and calculate the average of its surrounding cells including itself. The new value of each cell should be the floor (rounding down) value of the average of the valid surrounding pixel values. 

To implement this:

1. Calculate the total rows and columns in the matrix.
2. Traverse each element of the matrix.
3. For each element, iterate over all possible neighbors (8 in total including top, bottom, right, left, and diagonal cells).
4. Check if each neighbor is within valid bounds of the matrix to avoid indexing errors.
5. Keep a cumulative sum of all valid surrounding cell values and count these valid values.
6. Calculate the floor value of the average.
7. Add the averaged value to a new matrix which will be our result.

Here is the LeetCode formatted code to solve the image smoother problem:



```python
class Solution:
    def imageSmoother(self, M: List[List[int]]) -> List[List[int]]:
        if not M:
            return []
        
        rows, cols = len(M), len(M[0])
        result = [[0] * cols for _ in range(rows)]
        
        directions = [
            (0, 0), # center
            (0, 1), (0, -1), # left, right
            (1, 0), (-1, 0), # top, bottom
            (1, 1), (1, -1), # top-right, top-left
            (-1, 1), (-1, -1) # bottom-right, bottom-left
        ]
        
        for r in range(rows):
            for c in range(cols):
                total_sum = 0
                count = 0
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols:
                        total_sum += M[nr][nc]
                        count += 1
                result[r][c] = total_sum // count
        
        return result

```

### Explanation:

- The `directions` list holds tuples representing relative positions to a cell `(r, c)` used to access all of its neighbors including itself.
- A nested loop traverses the `M` matrix and computes the smooth value for each cell.
- `nr` and `nc` represent the row and column of a neighboring cell.
- Values are added and counted only when they are inside the boundaries of the matrix.
- The result is a new matrix `result` where each cell contains the average of its valid neighbors.

Test this solution with the provided example on the LeetCode platform to ensure its correctness.


