# 665. Non-decreasing Array

### Problem Description 
Given an array `nums` with `n` integers, your task is to check if it could become non-decreasing by modifying at most one element.

We define an array is non-decreasing if `nums[i] <= nums[i + 1]` holds for every `i` (0-based) such that (`0 <= i <= n - 2`).


Example 1:
Input: nums = [4,2,3]
Output: true
Explanation: You could modify the first `4` to `1` to get a non-decreasing array.


Example 2:
Input: nums = [4,2,1]
Output: false
Explanation: You can't get a non-decreasing array by modify at most one element.


Constraints:
`n == nums.length`
`1 <= n <= 104`
`-105 <= nums[i] <= 105`

### Solution 
 The problem we're solving is to determine whether an array can become non-decreasing by modifying at most one element. This is a common type of array manipulation problem that challenges us to weigh modifications against array order behavior.

To solve this problem, the basic approach involves iterating through the array and counting anomalies where a subsequent number is less than the current number (`nums[i] > nums[i + 1]`). If more than one such anomaly exists, we cannot make the array non-decreasing with a single modification. However, simply counting these anomalies isn't sufficient; we also have to check the surrounding elements to determine if adjusting the current or previous element will indeed keep the rest of the array in a non-decreasing order.

Here is a direct LeetCode-compliant solution:



```python
class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        count = 0  # Counter to track the number of modifications needed
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                # If more than one modification is necessary, return False
                if count > 0:
                    return False
                count += 1
                # Check if we can modify nums[i] or nums[i + 1] to fix the order
                if i == 0 or nums[i-1] <= nums[i+1]:
                    nums[i] = nums[i+1]
                else:
                    nums[i+1] = nums[i]
        return True

```

Detailed Explanation:
1. Loop through each element of the array until the second last element (`nums[i]` for `i` in the range of `len(nums)-1`).
2. Each time `nums[i]` is found to be greater than `nums[i + 1]`, increment a count.
3. If `count` becomes greater than 1 at any point, immediately return `False` because more than one modification would be necessary.
4. When an anomaly is found, determine if you can decrease `nums[i]` to `nums[i+1]` or if you should increase `nums[i+1]` to `nums[i]`. The decision is based on whether adjusting `nums[i]` will affect the order of previously processed elements (`nums[i-1]`).
5. If the entire array is parsed with `count` still 0 or 1, return `True`, indicating only 0 or 1 modification was necessary to achieve a non-decreasing order.

This solution is efficient, with a time complexity of O(n) because we only traverse the array once. It handles edge cases inherently, such as arrays with minimal elements or when changes at the boundaries of the array are needed. This approach ensures compliance with the given constraints and encompasses necessary iterations and checks concisely.

# 667. Beautiful Arrangement II

### Problem Description 
Given two integers `n` and `k`, you need to construct a list which contains `n` different positive integers ranging from `1` to `n` and obeys the following requirement: 
Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly `k` distinct integers.

If there are multiple answers, print any of them.


Example 1:
Input: n = 3, k = 1
Output: [1, 2, 3]
Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.


Example 2:
Input: n = 3, k = 2
Output: [1, 3, 2]
Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.

Note:
The `n` and `k` are in the range 1 <= k < n <= 104.

### Solution 
 To solve the problem described, we need to understand the behavior of the differences between consecutive elements in a list. 

### Key Insight:
1. **Maximal Differences:** The `k` distinct differences we aim for require an approach where differences are maximized without repetition up to the maximum value of `k`.
2. **Pattern Strategy:** The simplest way to achieve maximum differences is to place numbers in a zigzag manner. For instance:
   - To achieve `k = 2` distinct differences, considering a pattern `1, 3, 2` generates differences of `2` and `1`.
   - Extending this idea, for a general `k`, arrange numbers in a way similar to constructing two peaks from `1` to `n`: `1, k+1, 2, k, 3, k-1, ...`. This shifts between the lowest available and the highest unused number.

### Algorithm Steps:
1. Initialize the list with the pattern that alternates between incrementing from the start and decrementing from `k+1`.
2. Fill from `1` to `k` implementing the shifting approach: first even indices (incrementing), then odd indices (decrementing).
3. Append remaining numbers in direct sequence after reaching the targeted `k` differences.

### Implementation:


```python
class Solution:
    def constructArray(self, n: int, k: int) -> List[int]:
        result = []
        low, high = 1, k + 1
        for i in range(k + 1):
            if i % 2 == 0:
                result.append(low)
                low += 1
            else:
                result.append(high)
                high -= 1

        # filling up the remainder of the array
        result.extend(range(k + 2, n + 1))

        return result

```

### Explanation:
- Using the loop, we switch between the lowest unused and the highest unused number to create desired differences.
- After the loop for `k+1` elements is complete, we add the remaining numbers which will naturally have a difference of `1` (they do not add new distinct differences, keeping total distinct differences to `k`).
- This solution constructs the required list with exactly `k` distinct differences in an organized manner.

### Examples Walkthrough:
1. For `n = 3, k = 1`: Simple ascending order `[1, 2, 3]` gives single distinct difference of `1`.
2. For `n = 3, k = 2`: The approach generates `[1, 3, 2]`. Differences: `[2, 1]`.

This Python code could indeed be run on LeetCode's platform, respecting their function structure and using the signature provided for such problems. The explanation and examples verify and clarify how it meets the requirements specified.

# 670. Maximum Swap

### Problem Description 
Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.


Example 1:
Input: 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.


Example 2:
Input: 9973
Output: 9973
Explanation: No swap.

Note:
The given number is in the range [0, 108]

### Solution 
 The problem is defined in a way where we need to get the largest possible number by swapping at most two digits of a given non-negative integer. To solve this problem efficiently, I will utilize the idea of analyzing each digit of the number and determining if a swap should be made.

Here's the detailed approach we're going to execute:
1. Convert the integer to a list of its digits.
2. For each digit, determine the largest digit that comes after it.
3. If a larger digit exists to the right of our current digit, perform the swap to get the maximum possible number at this stage. We only need the first such opportunity for the swap since one swap is allowed.
4. Convert the list back to an integer.

The key part of the solution is to efficiently identify where the swap should occur and to ensure the swap results in the maximum possible integer. This means scanning the digits from right to left, keeping track of the greatest digit seen and its position to potentially use for a swap. We should trigger a swap with the leftmost digit that can be increased via a swap.

Here is a Python code following the LeetCode solution format:



```python
class Solution:
    def maximumSwap(self, num: int) -> int:
        # Convert to list to work with digits easily
        digits = list(str(num))
        # Create a map to remember the last position of each digit
        last = {int(x): i for i, x in enumerate(digits)}
        
        # Iterate over the digits
        for i, d in enumerate(digits):
            # Check from 9 to the current digit + 1 to find a larger digit
            for j in range(9, int(d), -1):
                if last.get(j, -1) > i:
                    # Swap the last occurrence of digit `j` with the current digit `d`
                    digits[i], digits[last[j]] = digits[last[j]], d
                    # Early return since only one swap is allowed
                    return int(''.join(digits))
        
        # If no swap was made, return the original number
        return num

```

This code uses a dictionary to store the last index of each digit that appears in the list of digits. By scanning the digits and using the dictionary, we can check if there's a larger digit that appears after the current digit, ensuring that the first detected opportunity for a beneficial swap is utilized immediately. This approach operates efficiently with respect to the number of digits typically expected, given the constraint of numbers up to `10^8`.

# 674. Longest Continuous Increasing Subsequence

### Problem Description 
Given an unsorted array of integers `nums`, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.

A continuous increasing subsequence is defined by two indices `l` and `r` (`l < r`) such that it is `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` and for each `l <= i < r`, `nums[i] < nums[i + 1]`.


Example 1:
Input: nums = [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.

Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element
4.


Example 2:
Input: nums = [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly
increasing.


Constraints:
`0 <= nums.length <= 104`
`-109 <= nums[i] <= 109`

### Solution 
 The problem is about finding the length of the longest strictly increasing contiguous subsequence in an array. To solve this efficientl`y, we can utilize a single pass approach, tracking the length of the current increasing subsequence and updating the maximum length found so far as we iterate through the array.

Here's how the algorithm will work:
1. Initialize two counters, `max_length` to keep track of the longest sequence found and `current_length` to keep track of the current sequence length.
2. Iterate through the list from the second element to the end:
   - If the current element is greater than the previous one, it's part of an increasing sequence. Increase `current_length`.
   - If it's not greater, compare `current_length` with `max_length` and update `max_length` if necessary. Then reset `current_length` to 1 because every single element can be considered as a subsequence with length 1.
3. After the loop, you might have the longest sequence towards the end of the list, so ensure to update `max_length` once more with `current_length`.
4. Return `max_length`.

Here's the Python code following the LeetCode format:



```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        max_length = 1
        current_length = 1
        
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                current_length += 1
            else:
                max_length = max(max_length, current_length)
                current_length = 1
        
        max_length = max(max_length, current_length)
        
        return max_length

```

This function begins by handling the case where the input list is empty, returning 0 since there's no subsequence in an empty list. It then initializes two counters: `max_length` and `current_length`. As it walks through the list, it updates these counters based on the conditions described. Finally, it ensures `max_length` is updated with `current_length` after the loop to include any increasing sequence that might end at the last element, and returns `max_length`.

The solution is efficient with O(n) time complexity, where n is the number of elements in the list, and it requires O(1) additional space beyond the input list's space.

# 689. Maximum Sum of 3 Non-Overlapping Subarrays

### Problem Description 
In a given array `nums` of positive integers, find three non-overlapping subarrays with maximum sum.

Each subarray will be of size `k`, and we want to maximize the sum of all `3*k` entries.

Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.


Example:
Input: [1,2,1,2,6,7,5,1], 2
Output: [0, 3, 5]
Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].

We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.

Note:
`nums.length` will be between 1 and 20000.

`nums[i]` will be between 1 and 65535.

`k` will be between 1 and floor(nums.length / 3).

### Solution 
 To solve this problem efficiently, we can use a dynamic programming approach combined with the understanding of sliding window technique for finding maximum subarray sum.

Our goal is to identify starting indices of three maximum subarrays each of size `k` such that they are non-overlapping.

**Step-by-step explanation**:

1. **Calculate Prefix Sum**: First, calculate sum of every contiguous sub-array of length `k`. These sums can be computed in a linear O(n) scan using a sliding window approach.

2. **Find Maximum Sums from Left and Right**:
   - Create two additional arrays `left` and `right` which respectively store the starting index of the maximum subarray of length `k` when looking from left to right and right to left.
   - `left[i]` will represent the start index of the maximum sum subarray in section `[0, i]`.
   - `right[i]` will represent the start index of the maximum sum subarray in section `[i, n-1]`.

3. **Choose Middle Segment Indices and Try to Maximize Total**:
   - For every possible middle segment starting index `i` that begins from `k` to `len(nums) - 2*k` (ensuring enough room for three segments), determine the optimal left and right segment indices by referring to `left` and `right` arrays created in the previous step.
   - The goal is to maximize the sum of the subarrays starting from indices stored in `left`, the current middle start `i`, and `right` arrays.



```python
def maxSumOfThreeSubarrays(nums, k):
    n = len(nums)
    sums = [0] * (n + 1)
    
    # Step 1: Calculate subarray sums of length k using sliding window
    for i in range(1, n + 1):
        sums[i] = sums[i - 1] + nums[i - 1]
    
    subarr_sums = [sums[i + k] - sums[i] for i in range(n - k + 1)]
    
    # Step 2: Prepare to find maximums from left to right and right to left
    left = [0] * (n - k + 1)
    right = [0] * (n - k + 1)
    best_left = 0
    
    for i in range(n - k + 1):
        if subarr_sums[i] > subarr_sums[best_left]:
            best_left = i
        left[i] = best_left
    
    best_right = n - k
    for i in range(n - k, -1, -1):
        if subarr_sums[i] >= subarr_sums[best_right]:
            best_right = i
        right[i] = best_right
    
    # Step 3: Now find the best combination of 3 non-overlapping subarrays
    max_sum = 0
    result = [-1, -1, -1]
    
    for j in range(k, n - 2 * k + 1):
        i = left[j - k]
        l = right[j + k]
        total = subarr_sums[i] + subarr_sums[j] + subarr_sums[l]
        if total > max_sum:
            max_sum = total
            result = [i, j, l]
    
    return result

# Example usage
nums = [1,2,1,2,6,7,5,1]
k = 2
print(maxSumOfThreeSubarrays(nums, k))  # Output: [0, 3, 5]

```

This approach builds upon creating `sums`, `subarr_sums`, `left`, and `right` arrays for efficient access and comparison, followed by inter-linking the evaluations made in steps 2 and 3 to come up with the solution in O(n) time complexity. By keeping track of the maximum subarrays progressively, we achieve optimal use of previously computed results, adhering to dynamic programming principles.

# 695. Max Area of Island

### Problem Description 
Given a non-empty 2D array `grid` of 0's and 1's, an island is a group of `1`'s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)

Example 1:
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
Given the above grid, return `6`. Note the answer is not 11, because the island must be connected 4-directionally.


Example 2:
[[0,0,0,0,0,0,0,0]]
Given the above grid, return `0`.

Note: The length of each dimension in the given `grid` does not exceed 50.

### Solution 
 To solve this problem, we can use Depth-First Search (DFS) to explore each island in the grid. The maximum area of an island is the maximum number of connected `1`s found by the DFS.

The core idea is to:
1. Iterate over each element of the grid.
2. When a `1` (land) is found, initiate a DFS from that cell to count all connected land cells (i.e., the area of the island) and mark them as visited by turning them into `0`s or another marker to avoid counting them again.
3. Keep track of the maximum area found during these searches.

Here is the Python code following this method and adhering to a format suitable for direct execution in LeetCode:



```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        if not grid:
            return 0
        
        max_area = 0
        rows, cols = len(grid), len(grid[0])
        
        def dfs(r, c):
            # Base case: check if the position is out of the bounds or the cell is water
            if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0:
                return 0
            # Mark the cell as visited by setting it to 0
            grid[r][c] = 0
            # Explore 4-directionally (up, down, left, right)
            return 1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c - 1) + dfs(r, c + 1)
        
        # Loop through every cell in the grid
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 1:
                    # Start a new DFS if the cell contains a "1"
                    current_area = dfs(row, col)
                    max_area = max(max_area, current_area)
        
        return max_area

```

### Explanation:
- The function `maxAreaOfIsland` receives a 2D grid.
- A helper function `dfs` is defined inside to perform Depth-First Search. It checks if the current cell is land and recursively explores all 4 directions.
- We iterate over each cell in the grid, and if it's land (`1`), we compute its area using DFS. After each DFS, we update the maximum area found so far.
- Finally, we return the maximum area.

This approach ensures that each cell is visited only once, providing a linear time complexity relative to the number of cells in the grid, i.e., O(rows * cols).

# 697. Degree of an Array

### Problem Description 
Given a non-empty array of non-negative integers `nums`, the degree of this array is defined as the maximum frequency of any one of its elements.

Your task is to find the smallest possible length of a (contiguous) subarray of `nums`, that has the same degree as `nums`.


Example 1:
Input: nums = [1,2,2,3,1]
Output: 2
Explanation: 
The input array has a degree of 2 because both elements 1 and 2 appear twice.

Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.


Example 2:
Input: nums = [1,2,2,3,1,4,2]
Output: 6
Explanation: 
The degree is 3 because the element 2 is repeated 3 times.

So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.


Constraints:
`nums.length` will be between 1 and 50,000.

`nums[i]` will be an integer between 0 and 49,999.

### Solution 
 Here is a solution for the described problem, which follows the format typically used for submissions on LeetCode:



```python
class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        # Dictionary to count occurrences of each number
        count = {}
        # Dictionary to record the first occurrence index of each number
        first_index = {}
        # Dictionary to record the last occurrence index of each number
        last_index = {}
        
        # Fill the dictionaries with the required data
        for index, num in enumerate(nums):
            count[num] = count.get(num, 0) + 1
            if num not in first_index:
                first_index[num] = index
            last_index[num] = index
        
        # Determine the degree of the array (maximum frequency of any element)
        degree = max(count.values())
        
        # Now find the minimum length of the subarray that has the same degree
        min_length = float('inf')
        for num, cnt in count.items():
            if cnt == degree:
                current_length = last_index[num] - first_index[num] + 1
                min_length = min(min_length, current_length)
        
        return min_length

# Example usage:
# sol = Solution()
# print(sol.findShortestSubArray([1,2,2,3,1])) # Output: 2
# print(sol.findShortestSubArray([1,2,2,3,1,4,2])) # Output: 6

```

### Explanation:

1. **Data Collection**:
    - Three dictionaries are created:
      - `count`: Keeps track of how many times each number appears.
      - `first_index`: Records the first index where each number appears.
      - `last_index`: Records the last index where each number appears.
    - As you iterate through the numbers, update these dictionaries.

2. **Determine the Degree**:
    - After populating the count dictionary, the degree of the array can be identified as the maximum value in `count`.

3. **Find Minimum Subarray Length**:
    - Initialize `min_length` to a very high value.
    - Check each number whose count matches the degree; calculate the length of the subarray starting from its first occurrence to its last occurrence (inclusive).
    - Keep track of the shortest length found.

4. **Return Result**:
    - The result is the minimum subarray length that matches the array's degree.

This solution is efficient and should execute in linear time relative to the size of the input array, making it suitable even for the upper end of constraints.

# 713. Subarray Product Less Than K

### Problem Description 
Your are given an array of positive integers `nums`.

Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than `k`.


Example 1:
Input: nums = [10, 5, 2, 6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].

Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.

Note:
`0 < nums.length <= 50000`.

`0 < nums[i] < 1000`.

`0 <= k < 10^6`.

### Solution 
 The problem above requires counting the number of subarrays (contiguous parts of the array) where the product of the elements is less than `k`. To solve this efficiently, we can use a sliding window or two-pointer approach to avoid iterating over every possible subarray directly, which could result in a solution that's too slow, especially given the constraint `0 < nums.length <= 50000`.

Here's how the two-pointer approach works:

1. Use two pointers (`left` and `right`) to represent the current window of the subarray.
2. Move the `right` pointer to explore new elements, and expand the window.
3. Calculate the product of the elements in the current window.
4. If the product reaches or exceeds `k`, move the `left` pointer to shrink the window until the product is less than `k` again.
5. For each position of the `right` pointer, add the number of new subarrays that can be formed. If `right` has index r and `left` has index l, then new subarrays that end at `right` and have valid products are formed from each start index from `left` to `right` essentially adding `(r - l + 1)` to count.
6. Repeat this process until the `right` pointer reaches the end of the array.

Let's implement this in Python using the LeetCode format.



```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1: 
            return 0
        
        count = 0
        product = 1
        left = 0
        
        for right in range(len(nums)):
            product *= nums[right]
            
            while product >= k:
                product /= nums[left]
                left += 1
            
            count += (right - left + 1)
        
        return count

```     

This code works efficiently with the constraints provided. It efficiently counts the number of subarrays by using a sliding window to keep track of the product of elements between a left and right pointer. The overall complexity is roughly `O(n)`, where `n` is the number of elements in `nums`, because each element is processed by incrementing `right` until the `right` pointer reaches the end of the array, and `left` can only move from the start to the end of the array once.

# 714. Best Time to Buy and Sell Stock with Transaction Fee

### Problem Description 
You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee.

Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).


Example 1:
Input: prices = [1,3,2,8,4,9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
- Buying at prices[0] = 1
- Selling at prices[3] = 8
- Buying at prices[4] = 4
- Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.


Example 2:
Input: prices = [1,3,7,5,10,3], fee = 3
Output: 6

Constraints:
`1 <= prices.length <= 5 * 104`
`1 <= prices[i] < 5 * 104`
`0 <= fee < 5 * 104`

### Solution 
 Here is a Python solution that can be directly run on LeetCode for the given problem statement. The solution uses a dynamic programming approach tailored to handle the transaction fee associated with each sell-buy operation optimally.

### LeetCode Solution Format:



```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        if n <= 0:
            return 0
        
        # cash: The cash in hand if we do not hold any stock currently.
        # hold: The cash in hand if we hold one stock currently.
        cash, hold = 0, -prices[0]
        
        for i in range(1, n):
            # If we sell the stock, cash in hand will be the max of previous cash or
            # the value obtained by selling the stock held (prices[i] + hold - fee)
            cash = max(cash, prices[i] + hold - fee)
            
            # If we buy the stock, hold will be the max of previous hold or
            # the value after buying the stock (cash - prices[i])
            hold = max(hold, cash - prices[i])
        
        return cash

```

### Explanation:

1. **Two States:**
   - `cash`: Represents the maximum profit we can achieve up to day `i` if we do not own a stock.
   - `hold`: Represents the maximum profit we can achieve up to day `i` if we own a stock.

2. **Initialization:**
   - Start with `cash` equals to `0` because initially, you don't have any stock, hence you have no profit.
   - Start with `hold` equals to `-prices[0]` representing buying the first stock.

3. **Transition:**
   - For each price on day `i`:
     - Update `cash` by considering selling the stock you are currently holding. `prices[i] + hold - fee` is the profit from selling a stock on day `i` that was held, minus the fee.
     - Update `hold` by considering buying a stock on day `i`. `cash - prices[i]` is the profit if you decide to take some cash you already have and buy a stock at the current price.
     
   - Use `max()` to ensure we are always opting for the choices that will maximize profit (either continue to stick with previous decisions or to switch the strategy considering the current price).

4. **Result:**
   - Since we might not own stock at the end (selling might be optimal), the answer is found in `cash`.

The solution efficiently considers all possible scenarios by leveraging the maximum potential profit derivable at every decision point, ensuring to capture the optimal path for a sequence of stock prices taking the transaction fee into account. It runs in O(n) time and O(1) space as it iterates once over the list and only uses a few variables.

# 717. 1-bit and 2-bit Characters

### Problem Description 
We have two special characters. The first character can be represented by one bit `0`. The second character can be represented by two bits (`10` or `11`).  
Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.


Example 1:
Input: 
bits = [1, 0, 0]
Output: True
Explanation: 
The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.


Example 2:
Input: 
bits = [1, 1, 1, 0]
Output: False
Explanation: 
The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.

Note:
`1 <= len(bits) <= 1000`.

`bits[i]` is always `0` or `1`.

### Solution 
 Here's a Python function solving the problem described, in a format directly runnable on LeetCode:



```python
from typing import List

class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        # Initialize a pointer that will traverse the bits
        i = 0
        # Length of the bits array
        n = len(bits)
        
        # Traverse the array with the logic designed to determine the nature of the final character
        while i < n - 1:  # Stop before the last bit
            if bits[i] == 1:
                # If current bit is 1, it means that we are currently at a two-bit character
                # Thus, jump over next bit, move to the first bit of the next character.
                i += 2
            else:
                # If current bit is 0, it's a one-bit character, move to the next bit.
                i += 1
        
        # After the end of the loop, check the position of i:
        # If i equals n-1, it means we are exactly at the last bit
        # Since we know from the problem statement that the last element is 0 and this 0 wasn't part of a two-bit pair
        # Hence, last character must be a one-bit character
        return i == n - 1

# Example usage:
sol = Solution()
print(sol.isOneBitCharacter([1, 0, 0]))  # Output: True
print(sol.isOneBitCharacter([1, 1, 1, 0]))  # Output: False

```

### Explanation:
The key to the solution is to simulate the parsing of the given bit sequence according to the rules described:

- Whenever a `1` is encountered, it indicates the start of a two-bit character (`10` or `11`). Hence, the next bit is part of this character, and the pointer should be moved forward by `2`.

- A `0` indicates a one-bit character, so the pointer moves forward by `1`.

If, after parsing all bits except for the final `0`, the current index of the pointer (`i`) exactly matches `n-1` (where `n` is the length of the bits list), it implies that the last bit (which is a `0`) stands alone as a one-bit character, making it indeed a one-bit character in the end. This strategy leverages direct index manipulation to efficiently decide the nature of the last character.

# 718. Maximum Length of Repeated Subarray

### Problem Description 
Given two integer arrays `A` and `B`, return the maximum length of an subarray that appears in both arrays.


Example 1:
Input:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
Output: 3
Explanation: 
The repeated subarray with maximum length is [3, 2, 1].

Note:
1 <= len(A), len(B) <= 1000
0 <= A[i], B[i] < 100

### Solution 
 To solve this problem, an efficient approach is to use dynamic programming. We can maintain a 2D array `dp` where `dp[i][j]` represents the length of the longest common subarray ending with `A[i-1]` and `B[j-1]`.

### Steps to Solve:
1. Initialize a 2D array `dp` with dimensions `(len(A) + 1) x (len(B) + 1)`. Fill it with zeros.
2. Iterate through each element of A and B.
3. If `A[i-1]` is equal to `B[j-1]`, set `dp[i][j] = dp[i-1][j-1] + 1`. This represents the fact that the longest subarray ending at these indices is one longer than the longest subarray ending just before these indices.
4. Maintain a variable `max_len` to store the maximum length found.

This approach has a time complexity of \(O(n \times m)\) and space complexity of \(O(n \times m)\), where `n` is the length of array A and `m` is the length of array B. Given the constraints \(1 \le n, m \le 1000\), this is efficient enough for our needs.

### Python Code:


```python
class Solution:
    def findLength(self, A: List[int], B: List[int]) -> int:
        n, m = len(A), len(B)
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        max_len = 0
        
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if A[i - 1] == B[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    max_len = max(max_len, dp[i][j])
        
        return max_len

# Example usage (uncomment these lines if running this code locally; they should be omitted in LeetCode submissions)
# sol = Solution()
# print(sol.findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # Output: 3

```

This Python class `Solution` and its method `findLength` should work as expected on the LeetCode platform based on the described conventions.

# 719. Find K-th Smallest Pair Distance

### Problem Description 
Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. 

Example 1:
Input:
nums = [1,3,1]
k = 1
Output: 0 
Explanation:
Here are all the pairs:
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
Then the 1st smallest distance pair is (1,1), and its distance is 0.

Note:
`2 <= len(nums) <= 10000`.

`0 <= nums[i] < 1000000`.

`1 <= k <= len(nums) * (len(nums) - 1) / 2`.

### Solution 
 To solve the problem of finding the k-th smallest distance among all the pairs in a list of integers, we can use the following approach:

**Approach: Binary Search with a Sliding Window**

**Detailed Explanation**

Rather than calculating the distance for every pair which would be computationally expensive (O(N^2)), we can approach the problem more efficiently using binary search and a sliding window technique.

1. **Sort the numbers**: Begin by sorting the array. Sorting the numbers ensures that the distance between successive elements is non-negative and non-decreasing.

2. **Define the search space**: The smallest possible distance is `0` (for pairs of the same element) while the largest distance is roughly the distance between the minimum and maximum elements of the sorted array.

3. **Use binary search**: Implement a binary search on the distance:
   - For a given middle point in the search (which represents a possible k-th smallest distance), compute how many pairs have a distance less or equal to this middle point.
   - Use a sliding window (or two-pointer technique) over the sorted array to count how many pairs satisfy this condition efficiently.

4. **Two-pointer technique**: For each element, find how far the second pointer can go such that the distance between the elements at the two pointers does not exceed the current distance guess (middle value in the binary search). 

5. **Adjust binary search bounds**: Depending on whether the count of pairs that have a distance ≤ middle value is less than or greater than `k`, adjust the binary search bounds.

6. **Termination and result**: The search narrows down to the exact value where the number of distances less than or equal to that value corresponds exactly to k.

By following this method, we avoid the O(N^2) complexity of generating all pairs and improve the performance significantly, especially with large lists.

Let's implement this in a Python function:



```python
class Solution:
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        def countPairs(mid):
            count = left = 0
            for right in range(len(nums)):
                while nums[right] - nums[left] > mid:
                    left += 1
                count += right - left
            return count
        
        nums.sort()
        low, high = 0, nums[-1] - nums[0]
        
        while low < high:
            mid = (low + high) // 2
            if countPairs(mid) < k:
                high = mid + 1
            else:
                low = mid
        
        return low

# The class Solution includes the function smallestDistancePair, ready to run directly in LeetCode's Python environment.

```

This solution adheres to the typical format for LeetCode problems. The `smallestDistancePair` function is part of a class `Solution` and takes the number list `nums` and an integer `k` as input, outputting the k-th smallest pair distance.

# 723. Candy Crush

### Problem Description 
This question is about implementing a basic elimination algorithm for Candy Crush.

Given a 2D integer array `board` representing the grid of candy, different positive integers `board[i][j]` represent different types of candies. A value of `board[i][j] = 0` represents that the cell at position `(i, j)` is empty. The given board represents the state of the game following the player's move. Now, you need to restore the board to a stable state by crushing candies according to the following rules:
If three or more candies of the same type are adjacent vertically or horizontally, "crush" them all at the same time - these positions become empty.

After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)
After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.

If there does not exist more candies that can be crushed (ie. the board is stable), then return the current board.

You need to perform the above rules until the board becomes stable, then return the current board.


Example:
Input:
board = 
[[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]
Output:
[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]
Explanation: 
Note:
The length of `board` will be in the range [3, 50].

The length of `board[i]` will be in the range [3, 50].

Each `board[i][j]` will initially start as an integer in the range [1, 2000].

### Solution 
 To solve the Candy Crush problem described, we need to follow a systematic approach as given in the task description. Let's break down the steps we will follow:

1. **Identify Crushable Candies**: We need to detect groups of three or more adjacent candies horizontally or vertically that are of the same type. These candies will be marked as crushable.

2. **Crush the Candies**: Set all crushable candies to a temporary negative value (indicating they should be crushed but differentiating from empty cells initially).

3. **Gravity Effect**: After crushing candies, make the candies fall to the bottom by shifting them downwards to fill the spaces created by the crushed candies.

4. **Repeat if Necessary**: After the candies have settled, check if there are new crushable groups. Repeat the procedure until no more candies can be crushed.

5. **Return the Stable Board**: Once no more candies can be crushed and the board is stable, return the board.

Here's the code implementing this strategy:



```python
class Solution:
    def candyCrush(self, board: List[List[int]]) -> List[List[int]]:
        ROWS, COLS = len(board), len(board[0])
        done = False

        while not done:
            done = True
            # Step 1: Mark all candies to crush
            for r in range(ROWS):
                for c in range(COLS - 2):
                    if abs(board[r][c]) == abs(board[r][c+1]) == abs(board[r][c+2]) != 0:
                        board[r][c] = board[r][c+1] = board[r][c+2] = -abs(board[r][c])
                        done = False

            for c in range(COLS):
                for r in range(ROWS - 2):
                    if abs(board[r][c]) == abs(board[r+1][c]) == abs(board[r+2][c]) != 0:
                        board[r][c] = board[r+1][c] = board[r+2][c] = -abs(board[r][c])
                        done = False

            # Step 2: Let the crush happen and drop candies
            for c in range(COLS):
                idx = ROWS - 1
                for r in range(ROWS - 1, -1, -1):
                    if board[r][c] > 0:
                        board[idx][c] = board[r][c]
                        idx -= 1
                while idx >= 0:
                    board[idx][c] = 0
                    idx -= 1

        return board

```

Explanation:

- **Initialization**: We start by detecting the board's dimensions and initializing a flag `done` used to determine whether further action is needed.
- **Crush Identification**: We use nested loops to scan every row and column. If three or more candies of the same type are found adjacent (either row-wise or column-wise), their values are negated (this way, we can differentiate a 'marked to be crushed' candy from one originally empty).
- **Candy Crushing and Gravity Pull**: Post marking, we perform another pass through each column. Here, move non-crushed candies down (emulating gravity). This makes use of two pointers; one (`idx`) tracks the position where a valid candy should fall, and the other (`r`) scans the column from bottom to top for movable candies.
- **Repeat or Terminate**: The outer `while` loop continues until no additional candies can be crushed (`done` is True).

Upon completion, the board is returned as stable with no adjacent sets of three or more identical candies. This solution assumes contiguous blocks along only horizontal or vertical lines but can be adapted for other configurations as required.

# 724. Find Pivot Index

### Problem Description 
Given an array of integers `nums`, calculate the pivot index of this array.

The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.

If the index is on the left edge of the array, then the left sum is `0` because there are no elements to the left. This also applies to the right edge of the array.

Return the leftmost pivot index. If no such index exists, return -1.


Example 1:
Input: nums = [1,7,3,6,5,6]
Output: 3
Explanation:
The pivot index is 3.

Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
Right sum = nums[4] + nums[5] = 5 + 6 = 11

Example 2:
Input: nums = [1,2,3]
Output: -1
Explanation:
There is no index that satisfies the conditions in the problem statement.


Example 3:
Input: nums = [2,1,-1]
Output: 0
Explanation:
The pivot index is 0.

Left sum = 0 (no elements to the left of index 0)
Right sum = nums[1] + nums[2] = 1 + -1 = 0

Constraints:
`1 <= nums.length <= 104`
`-1000 <= nums[i] <= 1000`

### Solution 
 Here is a Python code solution to find the pivot index in an array as described in the problem. This solution will calculate the sums efficiently in O(n) time complexity and uses O(1) extra space, aligning nicely with the constraints.



```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        total_sum = sum(nums)   # Get the sum of the whole array
        left_sum = 0            # Start with left sum as 0
        
        for i in range(len(nums)):
            # We compute the right sum by deducting left_sum and the current element from total_sum
            right_sum = total_sum - left_sum - nums[i]  
            
            # Check if left sum equals right sum
            if left_sum == right_sum:
                return i   # Return the current index as the pivot index
            
            # Update left_sum for next iteration
            left_sum += nums[i]
        
        # If no pivot index is found, return -1
        return -1

```

### Explanation:

1. **Calculate the Total Sum of the Array:**
   - Initially, using Python’s `sum()` function, we compute the total sum of all the elements in the `nums` array.

2. **Initialize `left_sum`:**
   - A variable `left_sum` is initialized to zero, which helps in keeping track of the sum of elements to the left of the current index during the iteration.

3. **Iterate Through the Array:**
   - As you iterate through the array with index `i`, calculate the `right_sum` by subtracting `left_sum` and the current element `nums[i]` from `total_sum`.
   - Check if `left_sum` equals `right_sum` at that iteration. If they are equal, it indicates that the current index `i` is a pivot index. Thus, return `i`.
   - If they are not equal, update `left_sum` by adding the current element `nums[i]` to `left_sum`, ensuring that for the next iteration, `left_sum` contains the sum of all elements to the left of the next index.

4. **Return -1 if No Pivot is Found:**
   - If the loop completes without finding any pivot index, return -1 indicating no such index exists.

This approach ensures that we efficiently check for pivot indices since we only traverse the list once, thus maintaining a linear runtime complexity and constant space complexity outside the input size.

# 729. My Calendar I

### Problem Description 
Implement a `MyCalendar` class to store your events. A new event can be added if adding the event will not cause a double booking.

Your class will have the method, `book(int start, int end)`. Formally, this represents a booking on the half open interval `[start, end)`, the range of real numbers `x` such that `start <= x < end`.

A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)
For each call to the method `MyCalendar.book`, return `true` if the event can be added to the calendar successfully without causing a double booking. Otherwise, return `false` and do not add the event to the calendar.

Your class will be called like this: `MyCalendar cal = new MyCalendar();` `MyCalendar.book(start, end)`

Example 1:
MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(15, 25); // returns false
MyCalendar.book(20, 30); // returns true
Explanation: 
The first event can be booked.  The second can't because time 15 is already booked by another event.

The third event can be booked, as the first event takes every time less than 20, but not including 20.

Note:
The number of calls to `MyCalendar.book` per test case will be at most `1000`.

In calls to `MyCalendar.book(start, end)`, `start` and `end` are integers in the range `[0, 10^9]`.

### Solution 
 To solve the problem, the Python class `MyCalendar` will utilize a list to keep track of booked events. Each event is stored as a tuple `(start, end)`. When an attempt is made to book a new event, we will check this list to ensure the proposed event does not overlap with already booked events.

Here is a detailed approach:
1. Store booked events in a sorted order based on the start time.
2. For a new booking attempt `(start, end)`, traverse through the list of booked events. Implement a check for overlaps by comparing the proposed event's `start` and `end` with those of the events already in the list.
3. If there is any overlap, the function should return `False`. If after checking all existing bookings there is no overlap, add the new event in chronologically sorted order to maintain the list's order, and return `True`.

Efficiency considerations:
- The insertion sort approach (inserting while maintaining order) could potentially be inefficient if many booking attempts are near the end of the existing intervals, leading to a time complexity of \(O(n^2)\) in the worst case.
- For optimal performance especially on extensive inputs, more sophisticated structures like balanced binary search trees or interval trees could be used to maintain booking intervals. These can offer \(O(\log n)\) complexity for insertion and searching.

However, for simplicity and ease of understanding, we'll stick to a list-based approach for now.

Below is an implementation of the `MyCalendar` class suitable for use on LeetCode:




```python
class MyCalendar:
    def __init__(self):
        self.bookings = []
    
    def book(self, start, end):
        for s, e in self.bookings:
            # Check for overlaps
            if max(s, start) < min(e, end):
                return False
        
        # Book the event since no overlap was found
        self.bookings.append((start, end))
        self.bookings.sort()  # Keep the list sorted by start times
        
        return True

# The following operations simulate examples from the problem prompt
# cal = MyCalendar()
# print(cal.book(10, 20))  # returns True
# print(cal.book(15, 25))  # returns False
# print(cal.book(20, 30))  # returns True

```

This solution defines the `MyCalendar` class and utilizes simple list operations to manage the bookings. It performs a clear cut overlap check, and it sorts the list after each new booking to ensure that the chronological order is maintained. Without additional details to indicate frequent removal operations or a requirement for more complex time-based queries, the overhead of maintaining balance in more complex data structures appears unjustified.


# 746. Min Cost Climbing Stairs

### Problem Description 
You are given an integer array `cost` where `cost[i]` is the cost of `ith` step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index `0`, or the step with index `1`.

Return the minimum cost to reach the top of the floor.


Example 1:
Input: cost = [10,15,20]
Output: 15
Explanation: Cheapest is: start on cost[1], pay that cost, and go to the top.


Example 2:
Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
Explanation: Cheapest is: start on cost[0], and only step on 1s, skipping cost[3].


Constraints:
`2 <= cost.length <= 1000`
`0 <= cost[i] <= 999`

### Solution 
 

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        # Creating a memoization list with the appropriate size
        # Derived from the length of cost, plus one to include the final "step" beyond the last cost
        if n == 2:
            return min(cost)
        
        dp = [0] * (n + 1)
        
        # Filling initial conditions:
        # From step 0, the cost is the same as the cost of the first step, and similar for step 1
        dp[0] = cost[0]
        dp[1] = cost[1]
        
        # To complete the traversal, we compute each step as the minimum cost reaching that step
        for i in range(2, n):
            # The cost to reach current step i can be from i-1 or i-2, 
            # add the current cost to the lesser of reaching either i-1 or i-2
            dp[i] = min(dp[i-1], dp[i-2]) + cost[i]
        
        # The last "step" beyond the topmost actual step could be reached either
        # from the last step or the second last step
        dp[n] = min(dp[n-1], dp[n-2])
        
        return dp[n]

# The function could be tested with:
# sol = Solution()
# print(sol.minCostClimbingStairs([10, 15, 20]))  # Output: 15
# print(sol.minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]))  # Output: 6

```

### Explanation

The main idea in the solution is to use dynamic programming to minimize the total cost to reach each step on the staircase. We employ a memoization array `dp` where `dp[i]` represents the minimum cost to reach step `i`.

**Steps for the solution:**

1. **Initialization:**
    - Given two initial choices, starting at index `0` or `1`, the costs to start are equal to those respective indices.

2. **State Relation:**
    - For any step `i (i ≥ 2)`, to determine the lowest cost to reach that step, you examine the costs coming from either step `i-1` or step `i-2` (since you're allowed to step one or two stairs at a time). Add the cost for step `i` to the minimum of these previous two costs. This is encapsulated in:
      \[
      \text{dp}[i] = \min(\text{dp}[i-1], \text{dp}[i-2]) + \text{cost}[i]
      \]
      
3. **Final Computation:**
    - After processing through the array, the final step is essentially just stepping beyond the last stair (i.e., reaching the ground). The minimum cost to get there would be the minimum cost to reach either of the last two stairs:
      \[
      \text{dp}[n] = \min(\text{dp}[n-1], \text{dp}[n-2])
      \]

The complexity of this solution is \(O(n)\) in time due to a single pass through the cost array, and \(O(n)\) in space because of the DP list used to store computed results.

# 747. Largest Number At Least Twice of Others

### Problem Description 
In a given integer array `nums`, there is always exactly one largest element.

Find whether the largest element in the array is at least twice as much as every other number in the array.

If it is, return the index of the largest element, otherwise return -1.


Example 1:
Input: nums = [3, 6, 1, 0]
Output: 1
Explanation: 6 is the largest integer, and for every other number in the array x,
6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.


Example 2:
Input: nums = [1, 2, 3, 4]
Output: -1
Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.

Note:
`nums` will have a length in the range `[1, 50]`.

Every `nums[i]` will be an integer in the range `[0, 99]`.

### Solution 
 To solve this problem efficiently, the plan is to:

1. Identify the largest number in the array and its index by iterating through `nums` once.
2. Check if this largest number is at least twice as much as every other number in the array.

A straightforward approach consists of two passes through the list:
- In the first pass, find the maximum element and its index.
- In the second pass, verify if this maximum element is at least twice as large as all other elements in the array.

The solution must handle edge cases such as:
- Arrays with only one element, where the result should be the index of that single element.
- Negative numbers (though based on the given constraints, all numbers are non-negative).

Given the constraints `1 <= nums.length <= 50` and numbers ranging `[0, 99]`, this method is computationally efficient.

Here's the Python solution in a format suitable for testing on LeetCode:



```python
class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
            
        max_index = 0
        max_value = nums[0]
        
        # First pass to find the maximum element and its index
        for i in range(1, len(nums)):
            if nums[i] > max_value:
                max_value = nums[i]
                max_index = i
        
        # Second pass to check if the maximum element is at least twice as large
        for i in range(len(nums)):
            if i != max_index and max_value < 2 * nums[i]:
                return -1
        
        return max_index

# Example instantiating the solution
sol = Solution()
print(sol.dominantIndex([3, 6, 1, 0]))  # Output: 1
print(sol.dominantIndex([1, 2, 3, 4]))  # Output: -1

```

This code encapsulates the solution inside a class `Solution` with a method `dominantIndex` that takes the list `nums` and returns the expected output. The example instantiation at the bottom is meant for quick testing or local development and should be removed when submitting on LeetCode.

# 755. Pour Water

### Problem Description 
We are given an elevation map, `heights[i]` representing the height of the terrain at that index.  The width at each index is 1.  After `V` units of water fall at index `K`, how much water is at each index?
Water first drops at index `K` and rests on top of the highest terrain or water at that index.  Then, it flows according to the following rules:
If the droplet would eventually fall by moving left, then move left.

Otherwise, if the droplet would eventually fall by moving right, then move right.

Otherwise, rise at it's current position.

Here, "eventually fall" means that the droplet will eventually be at a lower level if it moves in that direction.

Also, "level" means the height of the terrain plus any water in that column.

We can assume there's infinitely high terrain on the two sides out of bounds of the array.  Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block.


Example 1:
Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3
Output: [2,2,2,3,2,2,2]
Explanation:
#       #
#       #
##  # ###
#########
 0123456    <- index
The first drop of water lands at index K = 3:
#       #
#   w   #
##  # ###
#########
 0123456    
When moving left or right, the water can only move to the same level or a lower level.

(By level, we mean the total height of the terrain plus any water in that column.)
Since moving left will eventually make it fall, it moves left.

(A droplet "made to fall" means go to a lower height than it was at previously.)
#       #
#       #
## w# ###
#########
 0123456    
Since moving left will not make it fall, it stays in place.  The next droplet falls:
#       #
#   w   #
## w# ###
#########
 0123456  
Since the new droplet moving left will eventually make it fall, it moves left.

Notice that the droplet still preferred to move left,
even though it could move right (and moving right makes it fall quicker.)
#       #
#  w    #
## w# ###
#########
 0123456  
#       #
#       #
##ww# ###
#########
 0123456  
After those steps, the third droplet falls.

Since moving left would not eventually make it fall, it tries to move right.

Since moving right would eventually make it fall, it moves right.

#       #
#   w   #
##ww# ###
#########
 0123456  
#       #
#       #
##ww#w###
#########
 0123456  
Finally, the fourth droplet falls.

Since moving left would not eventually make it fall, it tries to move right.

Since moving right would not eventually make it fall, it stays in place:
#       #
#   w   #
##ww#w###
#########
 0123456  
The final answer is [2,2,2,3,2,2,2]:
    #    
 ####### 
 ####### 
 0123456 

Example 2:
Input: heights = [1,2,3,4], V = 2, K = 2
Output: [2,3,3,4]
Explanation:
The last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.


Example 3:
Input: heights = [3,1,3], V = 5, K = 1
Output: [4,4,4]
Note:
`heights` will have length in `[1, 100]` and contain integers in `[0, 99]`.

`V` will be in range `[0, 2000]`.

`K` will be in range `[0, heights.length - 1]`.

### Solution 
 To handle this problem, we will simulate the process of pouring water onto the terrain as specified. The goal is to implement a function that simulates dropping `V` units of water on the `K`th index and computes the final distribution of water across the terrain. We will simulate each droplet's movement according to the provided rules.

### Steps to Solve the Problem:
1. Start from the index `K` with each water droplet.
2. For each droplet:
   - Check if moving left will allow the droplet to go to a lower height. If so, keep moving left until this is no longer true.
   - If moving left is not possible, check if moving right will allow the droplet to go to a lower height. If so, keep moving right until this is not possible.
   - If neither left nor right movement results in a lower height (eventual drop), place the droplet at the current position.
3. When all `V` droplets have been placed, return the height at each index, which is a combination of original terrain height plus any accumulated water.

### Example Python Code:


```python
class Solution:
    def pourWater(self, heights: List[int], V: int, K: int) -> List[int]:
        for _ in range(V):
            index = K
            # Try to move left
            while index > 0 and heights[index - 1] <= heights[index]:
                index -= 1
                if heights[index] < heights[K]:
                    # Continue moving as long as it's a lower "level"
                    K = index
            
            # If no leftward movement is possible, focus on the original or rightward movement
            if index == K:
                while index < len(heights) - 1 and heights[index + 1] <= heights[index]:
                    index += 1
                    if heights[index] < heights[K]:
                        # Continue moving as long as it's a lower "level"
                        K = index
                
                # If rightward movement also fails or does not occur, place at original K
                if index == K:
                    heights[K] += 1
                    continue

            # Place the water at the lowest point located
            heights[K] += 1
        
        return heights


```

### Explanation:
- Starting each droplet at the index `K`, the code initially attempts to move the water left if possible (`heights[index - 1] <= heights[index]` and if it continues to lead to lower heights).
- Failing a productive leftward move, it tries to move right similarly.
- If both directions are blocked (or do not lead to falling), the droplet settles at the found lowest height.

This code should handle the provided scenarios effectively, dealing with terrain resulting in localized or spread placement of water, according to the specifications of the problem. The steps iteratively refine the water's position simulating natural movement influenced by gravity and barriers (higher elevations).

# 766. Toeplitz Matrix

### Problem Description 
Given an `m x n` `matrix`, return `true` if the matrix is Toeplitz. Otherwise, return `false`.

A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.


Example 1:
Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
Output: true
Explanation:
In the above grid, the diagonals are:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".

In each diagonal all elements are the same, so the answer is True.


Example 2:
Input: matrix = [[1,2],[2,2]]
Output: false
Explanation:
The diagonal "[1, 2]" has different elements.


Constraints:
`m == matrix.length`
`n == matrix[i].length`
`1 <= m, n <= 20`
`0 <= matrix[i][j] <= 99`
Follow up:
What if the `matrix` is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?
What if the `matrix` is so large that you can only load up a partial row into the memory at once?

### Solution 
 To solve the problem of determining if a matrix is Toeplitz, we can follow a straightforward approach. We'll check that each element in the matrix (except for those in the first row and the first column) matches the element diagonally up-left from it. Let's break down the key characteristics:

1. **Definition of a Toeplitz Matrix**: A matrix is Toeplitz if every diagonal from the top-left to the bottom-right has the same elements.

2. **Approach**:
   - Iterate over each element in the matrix.
   - For each element, except those in the first row and the first column, check if it's equal to the element that's one position to the upper left (i.e., check if `matrix[i][j]` is equal to `matrix[i-1][j-1]`).
   - If any such comparison fails, return `false`.
   - If all comparisons are valid throughout, return `true`.

3. **Complexity**:
   - The time complexity is O(m*n), where `m` is the number of rows and `n` is the number of columns, since we're visiting almost every element once.
   - The space complexity is O(1) since we're not using extra space related to the size of the matrix.

Now, let's move to the coding section, structuring it in a way that can be directly executed on the LeetCode platform:


```python
class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        # Fetch the dimensions of the matrix
        m, n = len(matrix), len(matrix[0])
        
        # Check each cell except those in the first row and first column
        for i in range(1, m): # Start from row 1 to avoid out-of-bounds error
            for j in range(1, n): # Start from column 1 for the same reason
                # Check the current cell against the cell top-left to it
                if matrix[i][j] != matrix[i-1][j-1]:
                    return False
        
        # If we never found a mismatch, the matrix is Toeplitz
        return True

```

### Follow-up questions:
1. **Matrix Stored on Disk with Limited Memory**:
   - Load one row at a time into memory.
   - Keep a copy of the previous row in memory.
   - Compare each element in the current row (after the first element) to the corresponding element in the previous row.
   - This involves read operations with a spacing similar to the above logic but spread across disk I/O operations.
2. **Extremely Large Matrices**:
   - If only partial rows fit into the memory, adapt the above strategy by ensuring continuity of diagonal checking across partial loads.
   - Implement additional logic to handle the transitions between loaded segments properly, ensuring consistency of diagonal checks.

These additional considerations would likely involve more complex management of memory and storage to handle the matrix in portions while ensuring consistency during Toeplitz verification.

# 768. Max Chunks To Make Sorted II

### Problem Description 
This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length `2000`, and the elements could be up to `10**8`.

Given an array `arr` of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.

What is the most number of chunks we could have made?

Example 1:
Input: arr = [5,4,3,2,1]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.

For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.


Example 2:
Input: arr = [2,1,3,4,4]
Output: 4
Explanation:
We can split into two chunks, such as [2, 1], [3, 4, 4].

However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.

Note:
`arr` will have length in range `[1, 2000]`.

`arr[i]` will be an integer in range `[0, 10**8]`.

### Solution 
 To solve this problem, we need to partition the array into the maximum number of chunks such that when each chunk is sorted individually, their concatenation results in an array that is globally sorted. This requires understanding the relationship between elements and the constraints imposed by their original positions in the array compared to their positions in the sorted version.

The trick here is to keep track of the maximum value seen while scanning from left to right. Each element in the array, given its index, necessitates that all elements up to the minimum required index that it needs to exist (in a sorted version) must be included in the sub-array that forms a single chunk.

If we can assert up to a certain point in the array that there exists no element before it that needs an index larger than the current point for correct positioning in a sorted array, we can form a chunk.

Here's how we can implement the solution:



```python
class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        max_so_far = 0
        chunks = 0
        sorted_arr = sorted(arr)
        
        checked_sum = 0
        required_sum = 0
        
        for i, val in enumerate(arr):
            max_so_far = max(max_so_far, val)
            checked_sum += val
            required_sum += sorted_arr[i]
            
            # If the cumulative sum of elements seen so far matches with the cumulative 
            # sum on the sorted array up to this index, a chunk can be formed.
            if checked_sum == required_sum:
                chunks += 1
                
        return chunks

```

Explanation:
- We use two cumulative sums (`checked_sum` and `required_sum`). `checked_sum`adds up elements as they appear in `arr` while `required_sum` does the same thing but with the elements in the positionally matched sorted version of `arr`.
- Each time these two sums match, we know that we can complete a chunk. Any anomalies or unordered elements before and including this position would have balanced themselves out. Thus, a new chunk can be confirmed.
- At each index, if the cumulative sum up to that index in the unsorted array matches the cumulative sum up to that index in the sorted array, then all elements up to that index can form a valid chunk if sorted.

This approach ensures that we maximize the number of chunks. Each chunk confirmation happens when there is evidence (through matching cumulative sums) that a segment of the array can be independently sorted to match its portion in the fully sorted array.

# 769. Max Chunks To Make Sorted

### Problem Description 
Given an array `arr` that is a permutation of `[0, 1, ..., arr.length - 1]`, we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.

What is the most number of chunks we could have made?

Example 1:
Input: arr = [4,3,2,1,0]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.

For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.


Example 2:
Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].

However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.

Note:
`arr` will have length in range `[1, 10]`.

`arr[i]` will be a permutation of `[0, 1, ..., arr.length - 1]`.

### Solution 
 To solve this problem, one effective approach is to utilize a strategy of tracking the maximum element as we iterate through the array. Given the properties of the permutation, if the maximum value found up to any index `i` is exactly `i`, then it is possible to form a chunk that ends at that index. This is because if the maximum element up to index `i` is `i`, then all numbers from `0` to `i` must be present within that range, and thus, it can be sorted internally to form a correctly ordered subsequence.

The algorithm follows these steps:
1. Initialize a counter for chunks (`chunks_count`) and a variable to keep track of the maximum number (`current_max`).
2. Iterate over the array. For each element:
   - Update `current_max` to be the maximum of the current element and the previous `current_max`.
   - If `current_max` equals the current index `i`, increase the `chunks_count`.
3. By the end of the iteration, `chunks_count` will hold the maximum number of chunks.

The time complexity of this solution is O(n) where n is the length of the array since we make only one pass over the list, and the space complexity is O(1), as we only use a few extra variables, regardless of the input size.

Here's how the Python code implementation looks like following LeetCode solution format:



```python
class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        chunks_count = 0
        current_max = 0
        
        for i, num in enumerate(arr):
            current_max = max(current_max, num)
            if current_max == i:
                chunks_count += 1
                
        return chunks_count

```

This function can be directly copied into the LeetCode editor for running tests. It accurately adheres to the problem constraints and efficiently computes the solution using the explained logic.

# 775. Global and Local Inversions

### Problem Description 
We have some permutation `A` of `[0, 1, ..., N - 1]`, where `N` is the length of `A`.

The number of (global) inversions is the number of `i < j` with `0 <= i < j < N` and `A[i] > A[j]`.

The number of local inversions is the number of `i` with `0 <= i < N` and `A[i] > A[i+1]`.

Return `true` if and only if the number of global inversions is equal to the number of local inversions.


Example 1:
Input: A = [1,0,2]
Output: true
Explanation: There is 1 global inversion, and 1 local inversion.


Example 2:
Input: A = [1,2,0]
Output: false
Explanation: There are 2 global inversions, and 1 local inversion.

Note:
`A` will be a permutation of `[0, 1, ..., A.length - 1]`.

`A` will have length in range `[1, 5000]`.

The time limit for this problem has been reduced.

### Solution 
 The problem is asking us to determine whether the number of global inversions in a permutation array `A` of length `N` is exactly the same as the number of local inversions in that array.

### Key Observations

1. **Local Inversions Are Global Inversions**:
   Every local inversion (`A[i] > A[i+1]` where `i` and `i+1` are adjacent) is a specific type of global inversion (`A[i] > A[j]` for some `j > i`). Thus, every local inversion will naturally also count as a global inversion.

2. **Detecting Non-local Global Inversions**:
   If there are any additional global inversions that are not local (i.e., where `j > i+1`), then the number of global inversions would exceed the number of local inversions.

### Strategy
To determine the relationship between global and local inversions, check if there are any non-local global inversions (i.e., `A[i] > A[j]` for `j > i+1`). If such a non-local inversion exists, immediately return `false`. If the loop completes without finding any non-local inversions, that means all global inversions are also local inversions and return `true`.

### Python Code


```python
class Solution:
    def isIdealPermutation(self, A: List[int]) -> bool:
        # Loop through array and check for non-local inversions
        n = len(A)
        for i in range(n):
            for j in range(i + 2, n):  # Start from i + 2 to skip local inversions
                if A[i] > A[j]:
                    return False
        return True

```

### Complexity Analysis
1. **Time Complexity**: The time complexity of this code is O(N^2) in the worst case, since for each element `i`, we might check up to `N-2` elements for non-local inversions. Although this is the brute-force approach, it works within the given constraints but can be improved.

### Optimized Approach
For better performance, we can solve this in O(N) by realizing that:
- If `max(A[0], A[1], ..., A[i-2]) > A[i]` for any `i >= 2`, then it means there's a non-local inversion.

Here's the optimized code:


```python
class Solution:
    def isIdealPermutation(self, A: List[int]) -> bool:
        max_val = -1
        n = len(A)
        # Loop starts from 2 as we're considering i >= 2
        for i in range(2, n):
            max_val = max(max_val, A[i-2])
            if max_val > A[i]:
                return False
        
        return True

```

### Optimized Complexity Analysis
1. **Time Complexity**: O(N), since we are iterating through the list only once while keeping track of the maximum value seen up to two elements prior.
2. **Space Complexity**: O(1), as we are only using a few extra variables for tracking purposes.

This solution is efficient, clean, and tailored for direct execution on platforms like LeetCode.

# 782. Transform to Chessboard

### Problem Description 
An N x N `board` contains only `0`s and `1`s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.

What is the minimum number of moves to transform the board into a "chessboard" - a board where no `0`s and no `1`s are 4-directionally adjacent? If the task is impossible, return -1.


Examples:
Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
Output: 2
Explanation:
One potential sequence of moves is shown below, from left to right:
0110     1010     1010
0110 --> 1010 --> 0101
1001     0101     1010
1001     0101     0101
The first move swaps the first and second column.

The second move swaps the second and third row.

Input: board = [[0, 1], [1, 0]]
Output: 0
Explanation:
Also note that the board with 0 in the top left corner,
01
10
is also a valid chessboard.

Input: board = [[1, 0], [1, 0]]
Output: -1
Explanation:
No matter what sequence of moves you make, you cannot end with a valid chessboard.

Note:
`board` will have the same number of rows and columns, a number in the range `[2, 30]`.

`board[i][j]` will be only `0`s or `1`s.

### Solution 
 Below, I'll provide a Python code that uses the given details to solve the problem of transforming a given board into a chessboard. The prompt essentially entails judging the feasibility of board transformation by checking the row and column patterns, and calculating the minimum swaps if feasible.



```python
class Solution:
    def movesToChessboard(self, board: List[List[int]]) -> int:
        N = len(board)
        # Step 1: Check if the board conforms to row and column patterns
        # A board can be translatable to a chessboard if all rows and all columns are:
        # - the same as one of two patterns that are inverses of each other
        
        # Determine row and column patterns
        row_pattern = board[0]
        col_pattern = [board[r][0] for r in range(N)]
        
        # Counter for patterns and their inverses
        row_count = {tuple(row_pattern): 1, tuple(1-x for x in row_pattern): 0}
        col_count = {tuple(col_pattern): 1, tuple(1-x for x in col_pattern): 0}
        
        for r in range(N):
            row_tuple = tuple(board[r])
            inv_row_tuple = tuple(1-x for x in board[r])
            if row_tuple not in row_count and inv_row_tuple not in row_count:
                return -1
            if row_tuple in row_count:
                row_count[row_tuple] += 1
            else:
                row_count[inv_row_tuple] += 1
                
        for c in range(N):
            col_tuple = tuple(board[r][c] for r in range(N))
            inv_col_tuple = tuple(1-x for x in col_tuple)
            if col_tuple not in col_count and inv_col_tuple not in col_count:
                return -1
            if col_tuple in col_count:
                col_count[col_tuple] += 1
            else:
                col_count[inv_col_tuple] += 1
                
        if any(x != N//2 for x in row_count.values()) and any(x != (N+1)//2 for x in row_count.values()):
            return -1
        if any(x != N//2 for x in col_count.values()) and any(x != (N+1)//2 for x in col_count.values()):
            return -1
        
        # Step 2: Compute minimum moves to match the pattern
        def min_swaps(arr, pattern):
            count = 0
            for i in range(N):
                if arr[i] != pattern[i % 2]:
                    count += 1
            # Must be even, or swaps cannot be performed
            if count % 2 != 0:
                return float('inf')
            return count // 2
        
        row_moves = min(min_swaps(row_pattern, [0, 1]), min_swaps(row_pattern, [1, 0]))
        col_moves = min(min_swaps(col_pattern, [0, 1]), min_swaps(col_pattern, [1, 0]))
        
        if row_moves == float('inf') or col_moves == float('inf'):
            return -1
        
        return row_moves + col_moves

# Example usage:
# sol = Solution()
# result = sol.movesToChessboard([[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]])
# print(result)  # Output: 2

```

Explanation:
1. **Pattern Validation**: For a board to be transformed into a chessboard, each row and each column must match one of exactly two patterns: A pattern or its inverse (e.g., [0,1,0,1] and [1,0,1,0]). This block checks for this condition.
2. **Row and Column Counts**: These counts determine how many rows and columns fit each pattern. For a valid chessboard transformation, these should be close to half of the total count (with exact frequencies depending on whether N (the dimension) is odd or even).
3. **Minimum Swaps Computation**: Using the `min_swaps` function, we determine the swap counts for rows and columns to align with a correct chessboard pattern, choosing the pattern based on the lowest required swaps. Two scenarios are considered – starting with 0 or with 1.

This solution is structured to be applied directly on the LeetCode platform.

# 792. Number of Matching Subsequences

### Problem Description 
Given a string `s` and an array of strings `words`, return the number of `words[i]` that is a subsequence of `s`.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, `"ace"` is a subsequence of `"abcde"`.


Example 1:
Input: s = "abcde", words = ["a","bb","acd","ace"]
Output: 3
Explanation: There are three strings in words that are a subsequence of s: "a", "acd", "ace".


Example 2:
Input: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"]
Output: 2

Constraints:
`1 <= s.length <= 5 * 104`
`1 <= words.length <= 5000`
`1 <= words[i].length <= 50`
`s` and `words[i]` consist of only lowercase English letters.

### Solution 
 To solve this problem, you will need to determine how many of the strings in the `words` list are subsequences of the string `s`. A subsequence of a string is created by deleting some or none of the characters without disrupting the relative positions of the remaining characters.

Given the constraints, a brute force solution may become slow for larger inputs. We can effectively solve this problem by creating a hashmap which stores indices of each character in the main string `s`. This allows us to efficiently check if a word is a subsequence by looking up these indices.

Here’s the step-by-step approach:

1. Create a hash map (`char_positions`) where each key is a character from `s`, and the value is a sorted list of indices where that character appears.
   
2. For each word in `words`, use this hash map to navigate through `s` and verify if we can recreate the word while maintaining the order seen in `s`.
   
3. To maintain order, for each character in the current word, we find the smallest possible index in `s` that is greater than the last found index (this ensures that the sequence order is preserved). This can be efficiently done using binary search (Python’s `bisect` module can help us with this).

4. Count how many words conform to the above criteria.

Considering this efficient indexing and binary search, this approach becomes significantly faster than checking each word independently in a brute force manner.

Here's an implementation of the outlined solution in Python:



```python
from collections import defaultdict
import bisect

class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        char_positions = defaultdict(list)
        
        # Collecting all positions for each character in s
        for index, char in enumerate(s):
            char_positions[char].append(index)
        
        def isSubsequence(word):
            cur_position = -1  # We start before the first index of s
            for char in word:
                if char not in char_positions:
                    return False  # This char isn't even in s, fail early
                # Find the smallest index in s greater than cur_position
                pos_list = char_positions[char]
                idx = bisect.bisect_left(pos_list, cur_position + 1)
                if idx == len(pos_list):
                    return False  # No valid position found
                cur_position = pos_list[idx]  # Move to this found position
            return True
        
        return sum(isSubsequence(word) for word in words)

# This can be tested in LeetCode environment directly with any appropriate test cases.

```

This Python class called `Solution` with its method `numMatchingSubseq` should work directly on LeetCode for the provided problem. This method considers both the efficiency and clarity required for competitive programming platforms such as LeetCode.

# 795. Number of Subarrays with Bounded Maximum

### Problem Description 
We are given an array `A` of positive integers, and two positive integers `L` and `R` (`L <= R`).

Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least `L` and at most `R`.


Example :
Input: 
A = [2, 1, 4, 3]
L = 2
R = 3
Output: 3
Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].

Note:
L, R  and `A[i]` will be an integer in the range `[0, 10^9]`.

The length of `A` will be in the range of `[1, 50000]`.

### Solution 
 Below is a Python solution to the described problem. The approach involves the concept of two pointers and sliding window technique to efficiently count the valid subarrays.



```python
class Solution:
    def numSubarrayBoundedMax(self, A: List[int], L: int, R: int) -> int:
        def countUnderBound(bound):
            """ Helper function to count subarrays with all elements less than or equal to the bound """
            ans = cnt = 0
            for x in A:
                if x <= bound:
                    cnt += 1  # extend the valid subarray by including this element
                else:
                    cnt = 0  # reset counter if out of bound
                ans += cnt  # add the current count to the ans aggregate
            return ans

        return countUnderBound(R) - countUnderBound(L - 1)

# Example usage:
# sol = Solution()
# print(sol.numSubarrayBoundedMax([2, 1, 4, 3], 2, 3)) # Output: 3

```

### Explanation:

1. **Helper Function (`countUnderBound`)**:
   - This function returns the number of subarrays whose elements are all less than or equal to a given bound `bound`.
   - We iterate through the array, and for each element, we either increase the counter of valid subarrays ending with this element (if the element is `<= bound`), or reset the counter if it exceeds the bound.
   - Summation of these counts throughout the array gives the total number of valid subarrays under this bound.

2. **Main Function (`numSubarrayBoundedMax`)**:
   - By using `countUnderBound(R)` we get count of all subarrays where all elements are `<= R`.
   - Using `countUnderBound(L-1)` we get count of all subarrays where all elements are `<= L-1` (i.e., strictly smaller than `L`).
   - Subtracting these two gives the count of subarrays where the maximum element is between `L` and `R`, inclusive.

### Complexity Analysis:
- **Time Complexity**: The algorithm has a time complexity of `O(n)` since we perform two linear passes over the array.
- **Space Complexity**: The solution uses `O(1)` extra space, maintaining a fixed number of variables.

This approach efficiently narrows down the count of valid subarrays by deriving the required numbers from a broader conditions (subarrays conforming to upper and lower bounds) with two passes for inclusive bounds processing. The solution should work within the constraints specified, handling up to 50000 elements gracefully.

# 825. Friends Of Appropriate Ages

### Problem Description 
Some people will make friend requests. The list of their ages is given and `ages[i]` is the age of the ith person. 
Person A will NOT friend request person B (B != A) if any of the following conditions are true:
`age[B] <= 0.5 * age[A] + 7`
`age[B] > age[A]`
`age[B] > 100 && age[A] < 100`
Otherwise, A will friend request B.

Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.

How many total friend requests are made?

Example 1:
Input: [16,16]
Output: 2
Explanation: 2 people friend request each other.


Example 2:
Input: [16,17,18]
Output: 2
Explanation: Friend requests are made 17 -> 16, 18 -> 17.


Example 3:
Input: [20,30,100,110,120]
Output: 3
Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.

Notes:
`1 <= ages.length <= 20000`.

`1 <= ages[i] <= 120`.

### Solution 
 To solve the friend request problem efficiently, we can use a counting and precomputation approach. Instead of iterating through each pair of potential friends (which leads to a time complexity of \(O(n^2)\)), we can summarize the data and check friend requirements in a more systematic way.

### Steps and Reasoning:
1. **Counting Frequencies:** We first count how many people are there for each age using an array `count` where `count[age]` gives the number of people of a certain age (`age`). This array helps in efficient calculation especially when multiple people of the same age group are involved.

2. **Precompute Valid Ranges:** For each age, determine the valid range of ages that can receive friend requests based on the conditions given. Calculate the lowest age (`low_age`) that a person of a given age can send a friend request to using the formula `0.5 * age + 7`.

3. **Calculate Friend Requests:** Count the number of valid friend requests each person could make by summing up counts of people within the valid age ranges (from `low_age + 1` to the person's own age) and then multiplying it by the count of persons of that age. This takes into account that all individuals of age `A` will have the same valid range. Thus, for each age, the indoor loop is reduced substantially by counting all possible receivers as a group instead of one by one.

4. **Handle Each Age Group:** For each person of age `A`, the number of possible recipients was determined by ages within the valid range; the product of this number with the number of people of age `A` gives us the friend requests originating from all individuals of age `A`.

By following the sequence above, we drastically reduce the number of operations needed for calculating the total number of friend requests.




```python
class Solution:
    def numFriendRequests(self, ages: List[int]) -> int:
        # Step 1: Precompute the count of each age from 1 to 120
        count = [0] * 121
        for age in ages:
            count[age] += 1
        
        # Step 2: Calculate friend requests
        total_requests = 0
        
        for age in range(1, 121):
            if count[age] == 0:
                continue
            min_age = int(age / 2 + 7) + 1
            if min_age <= age:  # Age is a viable sender
                # Count valid request recipients for `age`
                count_valid_recipients = sum(count[min_age:age+1])
                # Possible requests
                total_requests += count_valid_recipients * count[age]
                # Subtract self requests
                total_requests -= count[age]
        
        return total_requests

```

### Example Usage:
With this Solution class defined above, after pasting the completed code into LeetCode and running it, one could perform:


```python
sol = Solution()
print(sol.numFriendRequests([16,16]))  # Output: 2
print(sol.numFriendRequests([16,17,18]))  # Output: 2
print(sol.numFriendRequests([20, 30, 100, 110, 120]))  # Output: 3

```

This code should execute efficiently within allowed limits on the platform.

# 830. Positions of Large Groups

### Problem Description 
In a string `s` of lowercase letters, these letters form consecutive groups of the same character.

For example, a string like `s = "abbxxxxzyy"` has the groups `"a"`, `"bb"`, `"xxxx"`, `"z"`, and `"yy"`.

A group is identified by an interval `[start, end]`, where `start` and `end` denote the start and end indices (inclusive) of the group. In the above example, `"xxxx"` has the interval `[3,6]`.

A group is considered large if it has 3 or more characters.

Return the intervals of every large group sorted in increasing order by start index.


Example 1:
Input: s = "abbxxxxzzy"
Output: [[3,6]]
Explanation: `"xxxx" is the only `large group with start index 3 and end index 6.


Example 2:
Input: s = "abc"
Output: []
Explanation: We have groups "a", "b", and "c", none of which are large groups.


Example 3:
Input: s = "abcdddeeeeaabbbcd"
Output: [[3,5],[6,9],[12,14]]
Explanation: The large groups are "ddd", "eeee", and "bbb".


Example 4:
Input: s = "aba"
Output: []

Constraints:
`1 <= s.length <= 1000`
`s` contains lower-case English letters only.

### Solution 
 Here's a Python code solution that solves the problem of finding large groups in a string of lowercase letters. This solution adheres to the LeetCode format, ensuring it can be directly run and tested on the LeetCode platform.

The approach involves iterating through the string while tracking the start and end of consecutive groups of the same character. If a group has a length of three or more characters, it is recorded as a large group. The boundaries of these large groups are stored as intervals in a list, which is then returned.



```python
class Solution:
    def largeGroupPositions(self, s: str) -> List[List[int]]:
        # Initialize the list to store the result
        result = []
        
        # Initialize the start of the current group
        start = 0
        
        # Loop through the string from the first to the last character
        for i in range(1, len(s)):
            # Check if the current character is different from the previous
            if s[i] != s[start]:
                # If the group size is at least 3, add to the result
                if i - start >= 3:
                    result.append([start, i - 1])
                # Update the start of the new group
                start = i
        
        # Check the last group in case it ends at the end of the string
        if len(s) - start >= 3:
            result.append([start, len(s) - 1])
        
        # Return the list of large group positions
        return result

# Example usage:
# sol = Solution()
# print(sol.largeGroupPositions("abbxxxxzzy"))  # Output: [[3, 6]]
# print(sol.largeGroupPositions("abc"))         # Output: []
# print(sol.largeGroupPositions("abcdddeeeeaabbbcd"))  # Output: [[3, 5], [6, 9], [12, 14]]
# print(sol.largeGroupPositions("aba"))         # Output: []

```

### Explanation:

1. **Initialization**:
    - `result`: List that will store the list of intervals corresponding to large groups.
    - `start`: Marks the start of a consecutive group.

2. **Iteration**:
    - Loop over the string from the first character until the end. Use `start` to note where the current group of identical characters begins.
    - Any time a character differs from the one at `start`, check if the group formed from `start` to `i-1` is at least three characters long. If so, add the interval to `result`.
    - Upon finding a different character or reaching the end of the loop, reset `start` to the current character's index `i`.

3. **Handling the Last Group**:
    - After exiting the loop, ensure to check the last group, since it may also be large but wouldn't be checked within the loop's conditions.

4. **Complexity**:
    - The solution is linear, i.e., `O(n)`, where `n` is the length of the string `s`. This is because we explore each character exactly once and perform constant-time operations per character.

# 832. Flipping an Image

### Problem Description 
Given an `n x n` binary matrix `image`, flip the image horizontally, then invert it, and return the resulting image.

To flip an image horizontally means that each row of the image is reversed.

For example, flipping `[1,1,0]` horizontally results in `[0,1,1]`.

To invert an image means that each `0` is replaced by `1`, and each `1` is replaced by `0`.

For example, inverting `[0,1,1]` results in `[1,0,0]`.


Example 1:
Input: image = [[1,1,0],[1,0,1],[0,0,0]]
Output: [[1,0,0],[0,1,0],[1,1,1]]
Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].

Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]

Example 2:
Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].

Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]

Constraints:
`n == image.length`
`n == image[i].length`
`1 <= n <= 20`
`images[i][j]` is either `0` or `1`.

### Solution 
 Here is a Python solution that illustrates how to solve the described problem of flipping an n x n binary matrix horizontally and then inverting it. The provided code can be run directly on the LeetCode platform:



```python
class Solution:
    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:
        n = len(image)
        
        for row in image:
            # Perform the horizontal flip and invert operation in one line using slicing and list comprehension
            row[:] = [1 - x for x in row[::-1]]  # reversing each row and inverting
        
        return image

```

### Explanation:

1. **Understanding the Input and Output**: 
   The input is an `n x n` binary matrix, where each element is either 0 or 1. Our goal is to flip each row of this matrix horizontally (reverse the order of elements in each row) and then invert each value (change all 0s to 1s and vice versa).

2. **Traversing the Matrix**:
   We loop through each row of the matrix. The length of the matrix is denoted as `n`.

3. **Flipping and Inverting**:
   - **Flipping**: To flip the row horizontally, we simply reverse the row. In Python, this can be accomplished by using slicing: `row[::-1]`.
   - **Inverting**: To invert the binary values, we use a list comprehension: `1 - x` for each element `x` in the reversed row.

   By combining these two operations into a single line via a list comprehension inside the slice assignment `row[:] =`, we effectively transform the row in-place without needing extra space for another matrix.

4. **Returning the Result**:
   After processing all rows, the transformed `image` is returned as the output.

### Performance:
- **Time Complexity**: O(n^2) - As we need to process each element in the `n x n` matrix.
- **Space Complexity**: O(1) - The solution modifies the matrix in place, using constant extra space.

This solution efficiently handles the constraints provided and meets the typical standards expected on coding platforms like LeetCode.

# 835. Image Overlap

### Problem Description 
You are given two images `img1` and `img2` both of size `n x n`, represented as binary, square matrices of the same size. (A binary matrix has only 0s and 1s as values.)
We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images.

(Note also that a translation does not include any kind of rotation.)
What is the largest possible overlap?

Example 1:
Input: img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]
Output: 3
Explanation: We slide img1 to right by 1 unit and down by 1 unit.

The number of positions that have a 1 in both images is 3. (Shown in red)

Example 2:
Input: img1 = [[1]], img2 = [[1]]
Output: 1

Example 3:
Input: img1 = [[0]], img2 = [[0]]
Output: 0

Constraints:
`n == img1.length`
`n == img1[i].length`
`n == img2.length `
`n == img2[i].length`
`1 <= n <= 30`
`img1[i][j]` is `0` or `1`.

`img2[i][j]` is `0` or `1`.

### Solution 
 To solve the problem of finding the largest possible overlap of two `n x n` binary matrices when one is translated over the other, we need an efficient way of calculating the overlap based on different translations.

**Approach:**
- Iterate over all potential translations `(x_shift, y_shift)`, where `x_shift` ranges from `-n+1` to `n-1` (left to right) and `y_shift` ranges from `-n+1` to `n-1` (up to down).
- For each translation:
  - Calculate the overlap, i.e., count how many times a `1` in `img1` matches a `1` in `img2` when `img1` is shifted by `(x_shift, y_shift)`.
  - To calculate the overlap efficiently:
    - For each `1` in `img1`, calculate its new coordinates after the shift.
    - If its new coordinates are still within the bounds of `img2` and `img2` has a `1` at that position, it contributes to the overlap.
  
- Return the maximum overlap found among all translations.

**Python Code Implementation:**



```python
class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        n = len(img1)
        max_overlap = 0

        def overlap(x_shift, y_shift):
            total_overlap = 0
            for x in range(n):
                for y in range(n):
                    if img1[x][y] == 1:
                        new_x, new_y = x + x_shift, y + y_shift
                        if 0 <= new_x < n and 0 <= new_y < n and img2[new_x][new_y] == 1:
                            total_overlap += 1
            return total_overlap

        for x_shift in range(-n + 1, n):
            for y_shift in range(-n + 1, n):
                max_overlap = max(max_overlap, overlap(x_shift, y_shift))
        
        return max_overlap

# Example usage:
# sol = Solution()
# print(sol.largestOverlap([[1,1,0],[0,1,0],[0,1,0]], [[0,0,0],[0,1,1],[0,0,1]]))  # Output: 3

```

**Explanation:**
The solution uses a nested loop to consider all possible translations in x and y directions. For each translation, the `overlap` function calculates how many `1`s in `img1` align with `1`s in `img2` after the shift. We keep track of the maximum overlap using `max_overlap`.

**Performance:**
Since every possible translation (bounded by `(n-1) * 2 + 1` for x and y each) is considered, and each overlap calculation involves iterating over possibly every element in `img1` or `img2`, the worst-case runtime formula can be expressed as `O(n^3)`, which is acceptable given the constraint `n <= 30`.

Note that additional optimizations can be applied based on further constraints or observations, but for a matrix size up to 30x30, this solution will perform well within typical time constraints.

# 840. Magic Squares In Grid

### Problem Description 
A `3 x 3` magic square is a `3 x 3` grid filled with distinct numbers from `1` to `9` such that each row, column, and both diagonals all have the same sum.

Given a `row x col` `grid` of integers, how many `3 x 3` "magic square" subgrids are there?  (Each subgrid is contiguous).


Example 1:
Input: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]
Output: 1
Explanation: 
The following subgrid is a 3 x 3 magic square:
while this one is not:
In total, there is only one magic square inside the given grid.


Example 2:
Input: grid = [[8]]
Output: 0

Example 3:
Input: grid = [[4,4],[3,3]]
Output: 0

Example 4:
Input: grid = [[4,7,8],[9,5,1],[2,3,6]]
Output: 0

Constraints:
`row == grid.length`
`col == grid[i].length`
`1 <= row, col <= 10`
`0 <= grid[i][j] <= 15`

### Solution 
 Understanding the problem, the required task is to count the number of 3x3 subgrids that are magic squares within a provided matrix. For a subgrid to qualify as a magic square, it should consist of distinct integers from 1 to 9, and the sum of numbers in each row, column, and both diagonals should be the same.

Here is a Python solution for this problem:



```python
class Solution:
    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
        def is_magic(x, y):
            # Check if the 3x3 subgrid starting at (x,y) in the grid forms a magic square.
            s = set()  # to capture unique elements
            for i in range(x, x + 3):
                for j in range(y, y + 3):
                    num = grid[i][j]
                    if num < 1 or num > 9:  # check for number range
                        return False
                    if num in s:  # check for distinct elements
                        return False
                    s.add(num)  # add element to set
                    
            # Magic constant check:
            # Sum of the first row to initialize the magic constant
            magic_sum = grid[x][y] + grid[x][y+1] + grid[x][y+2]
            
            # Check the rows sums
            for i in range(x, x+3):
                if sum(grid[i][j] for j in range(y, y+3)) != magic_sum:
                    return False
                
            # Check the columns sums
            for j in range(y, y+3):
                if sum(grid[i][j] for i in range(x, x+3)) != magic_sum:
                    return False
                
            # Check the diagonals sums
            if (grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2] != magic_sum or
                grid[x][y+2] + grid[x+1][y+1] + grid[x+2][y] != magic_sum):
                return False

            return True
        
        # Overall grid dimensions
        row, col = len(grid), len(grid[0])
        
        # Count how many magic squares exist
        count = 0
        # Only attempt the check if there's space for at least one 3x3 square
        for i in range(row - 2):
            for j in range(col - 2):
                if is_magic(i, j):
                    count += 1
        
        return count

```

Explanation:
1. We define an inner function `is_magic(x, y)` that checks if a 3x3 subgrid starting at the top-left corner `(x, y)` is a magic square.
2. This function first checks if all elements in this 3x3 subgrid are unique and between 1 and 9.
3. Then, it verifies the condition that all rows, columns, and diagonals sum up to the same "magic sum", which is initiated using the sum of the upper left 3x3 subgrid's first row.
4. The main function then iterates through the parent grid, checking each possible 3x3 subgrid for the magic square properties using the helper function.
5. We only iterate through indices that allow for a full 3x3 square to exist within the boundary of the main grid (`row - 2` and `col - 2` limits).

This approach ensures that the solution is efficient and straightforward, providing a direct way to count the number of 3x3 magic squares subgrids in the provided matrix.

# 849. Maximize Distance to Closest Person

### Problem Description 
You are given an array representing a row of `seats` where `seats[i] = 1` represents a person sitting in the `ith` seat, and `seats[i] = 0` represents that the `ith` seat is empty (0-indexed).

There is at least one empty seat, and at least one person sitting.

Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. 
Return that maximum distance to the closest person.


Example 1:
Input: seats = [1,0,0,0,1,0,1]
Output: 2
Explanation: 
If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.

If Alex sits in any other open seat, the closest person has distance 1.

Thus, the maximum distance to the closest person is 2.


Example 2:
Input: seats = [1,0,0,0]
Output: 3
Explanation: 
If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.

This is the maximum distance possible, so the answer is 3.


Example 3:
Input: seats = [0,1]
Output: 1

Constraints:
`2 <= seats.length <= 2 * 104`
`seats[i]` is `0` or `1`.

At least one seat is empty.

At least one seat is occupied.

### Solution 
 The problem boils down to finding the maximum minimum distance from a certain seat (`0` meaning empty) to the closest occupied seat (`1`). To solve this problem effectively, we'll consider three scenarios:

1. Distance from the first occupied seat for any leading zeros (e.g., spots before the first `1`).
2. Distance between occupied seats (i.e., the gaps of zeros between sections of ones).
3. Distance from the last occupied seat for any trailing zeros (e.g., spots after the last `1`).

For these scenarios:
- Scenario 1 and 3: We directly count the zeros since any zero could be as far as the count itself from the nearest `1`.
- Scenario 2 (gaps in between): The optimal seat is roughly in the middle of the gap, so the maximum distance to the closest `1` within those gaps is the floor value of half the gap size (`gap // 2`).

By comparing the maximum values from these scenarios, we arrive at an optimal seat location for Alex.

Here is the Python solution implementing the above approach:



```python
class Solution:
    def maxDistToClosest(self, seats: List[int]) -> int:
        max_distance = 0
        last_person = -1
        
        for i, seat in enumerate(seats):
            if seat == 1:
                if last_person == -1:
                    # Scenario 1: calculate distance from beginning to first person
                    max_distance = i
                else:
                    # Scenario 2: calculate the max distance between two people
                    max_distance = max(max_distance, (i - last_person) // 2)
                last_person = i
        
        # Scenario 3: calculate distance from the last person to the end
        max_distance = max(max_distance, len(seats) - 1 - last_person)
        
        return max_distance

```

This code clearly calculates the maximum distance from Alex to the nearest person under the specified constraints. The condition `last_person == -1` handles the cases where no person has been seen so far, checking the initial range of zeros before the first `1`. Then we update the maximum distance to the closest person by comparing it with previous values after every observed person (`1`). Post loop, we consider the trailing zeros after the last person. The space complexity is O(1) and the time complexity is O(n) where `n` is the number of seats because each seat is checked once.

# 867. Transpose Matrix

### Problem Description 
Given a 2D integer array `matrix`, return the transpose of `matrix`.

The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.


Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[1,4,7],[2,5,8],[3,6,9]]

Example 2:
Input: matrix = [[1,2,3],[4,5,6]]
Output: [[1,4],[2,5],[3,6]]

Constraints:
`m == matrix.length`
`n == matrix[i].length`
`1 <= m, n <= 1000`
`1 <= m * n <= 105`
`-109 <= matrix[i][j] <= 109`

### Solution 
 To solve the problem of transposing a matrix in Python, you can leverage looping through the rows and columns of the original matrix and reconstructing a new matrix where the rows become columns and vice versa.

Here's a simple step-by-step method:
- Understand that the transpose of a matrix involves swapping rows and columns. For a cell in the original matrix at position `matrix[i][j]`, its value will be placed at position `transpose[j][i]` in the transposed matrix.
- The original matrix dimensions are m x n, and thus the dimensions of the transposed matrix will be n x m.
- Prepare to utilize Python list comprehensions for a more concise and readable solution.

Below is the Python function to perform the matrix transpose, formatted for easy copying into the LeetCode platform:



```python
class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        # Get number of rows (m) and columns (n) from the original matrix
        m, n = len(matrix), len(matrix[0])
        
        # Create the transposed matrix with dimensions n x m
        # Here, we initialize this directly using a nested list comprehension
        # We fill each position (i, j) in the transposed matrix with matrix[j][i]
        transposed = [[matrix[j][i] for j in range(m)] for i in range(n)]
        
        return transposed

# Example usage:
# sol = Solution()
# result = sol.transpose([[1,2,3],[4,5,6]])
# print(result)  # Output: [[1,4],[2,5],[3,6]]

```

### Explanation:
1. **Initialization**: We first determine the dimensions of the input matrix `m` (number of rows) and `n` (number of columns).
2. **Matrix Creation**: Using a list comprehension, we produce the transposed matrix `transposed`. The outer loop `for i in range(n)` creates a new row for each of the `n` columns of the original matrix. The inner loop `for j in range(m)` grabs the `i-th` element from each row `j` of the original matrix to form a new column in the transposed matrix.
3. **Return**: The function then returns the `transposed` matrix.

### LeetCode Details:
The function follows the expected signature and format for direct submission on LeetCode, using the data types and method signature (`transpose(self, matrix: List[List[int]])`) as required by the platform. This will allow you to paste it into LeetCode's editor and run tests immediately.

# 870. Advantage Shuffle

### Problem Description 
Given two arrays `A` and `B` of equal size, the advantage of `A` with respect to `B` is the number of indices `i` for which `A[i] > B[i]`.

Return any permutation of `A` that maximizes its advantage with respect to `B`.


Example 1:
Input: A = [2,7,11,15], B = [1,10,4,11]
Output: [2,11,7,15]

Example 2:
Input: A = [12,24,8,32], B = [13,25,32,11]
Output: [24,32,8,12]
Note:
`1 <= A.length = B.length <= 10000`
`0 <= A[i] <= 10^9`
`0 <= B[i] <= 10^9`

### Solution 
 To solve the problem, we'll follow a strategy called "greedy matching." The main idea is to take each element in `B`, look for the smallest element in `A` that is greater than the current element in `B`, and use this to construct the resultant array. This will ensure that for each element in `B`, we use the smallest possible "winning" element from `A`. If no such element exists for a particular `B[i]`, we will use the smallest available element from `A` which has not been used yet, as it will not contribute to the maximize advantage count. 

This approach requires efficient searching and deleting operations for which a balanced tree or a sorted array (with binary search) can be useful. In Python, we can use `bisect` and a list to manage the "sorted array" representation, or a `SortedList` from `sortedcontainers` module for potentially cleaner usage but with similar complexity.

The detailed steps are:
1. Sort the array `A`.
2. Sort the array `B` but remember the original indices to reconstruct the output array correctly.
3. Traverse through sorted B, for each `B[i]`, use binary search to find the smallest element in the current sorted list of `A` that is greater than `B[i]`.
4. If such an element exists, that's our desired element for maximizing the advantage; otherwise, use the smallest available element left in A.
5. Reconstruct the output array based on the original index of each element in `B`.

Here's the implementation in Python following the described approach, formatted to be directly run on LeetCode:



```python
from typing import List
from bisect import bisect_right
from sortedcontainers import SortedList

class Solution:
    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:
        sorted_A = sorted(A)
        sorted_B = sorted((value, idx) for idx, value in enumerate(B))
        
        result = [0] * len(A)
        remaining = SortedList()  # This maintains elements of A that haven't been used yet
        
        j = 0  # Pointer to traverse through sorted_A
        for b_value, b_idx in sorted_B:
            # Finding the smallest element in sorted_A that is greater than b_value
            if sorted_A[j] > b_value:
                result[b_idx] = sorted_A[j]
                j += 1
            else:
                # If no such element is left, we will populate remaining list in sorted_A
                remaining.add(sorted_A[j])
                j += 1
        
        # All elements in remaining are not suitable to beat any b_value
        # Use them in the order of position in B
        remaining_idx = 0
        for i in range(len(result)):
            if result[i] == 0:  # If no value was assigned
                result[i] = remaining[remaining_idx]
                remaining_idx += 1
        
        return result

# Example usage
if __name__ == "__main__":
    sol = Solution()
    print(sol.advantageCount([2,7,11,15], [1,10,4,11]))  # Output: [2,11,7,15]
    print(sol.advantageCount([12,24,8,32], [13,25,32,11]))  # Output: [24,32,8,12]

```
Each step of the above code is accordingly designed to solve the problem while keeping the edge cases and constraints in mind. The use of `SortedList` assists in managing insertions and access in sorted order. This solution theoretically gives an efficient way to solve within a O(n log n) complexity due to sorting and the operations with `SortedList`/binary search.

# 873. Length of Longest Fibonacci Subsequence

### Problem Description 
A sequence `X1, X2, ..., Xn` is Fibonacci-like if:
`n >= 3`
`Xi + Xi+1 = Xi+2` for all `i + 2 <= n`
Given a strictly increasing array `arr` of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of `arr`. If one does not exist, return `0`.

A subsequence is derived from another sequence `arr` by deleting any number of elements (including none) from `arr`, without changing the order of the remaining elements. For example, `[3, 5, 8]` is a subsequence of `[3, 4, 5, 6, 7, 8]`.


Example 1:
Input: arr = [1,2,3,4,5,6,7,8]
Output: 5
Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].


Example 2:
Input: arr = [1,3,7,11,12,14,18]
Output: 3
Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].


Constraints:
`3 <= arr.length <= 1000`
`1 <= arr[i] < arr[i + 1] <= 109`

### Solution 
 We need a solution that efficiently finds the longest Fibonacci-like subsequence within the given strictly increasing array `arr`. The approach to efficiently address this involves using a hash table and dynamic programming.

Here's how we can tackle this problem:
1. Use a hash table, `index_map`, to store the index of each element for O(1) access.
2. Use another hash table, `dp`, which will store the maximum Fibonacci-like subsequence length ending with a pair (arr[i], arr[j]), where `j > i`.
3. For each element `arr[i]`, look for two previous elements `arr[j]` and `arr[k]` such that `arr[j] + arr[k] == arr[i]`.
4. If such a pair exists and can be extended to include `arr[i]`, then `dp[(j, i)]` will be equal to `dp[(k, j)] + 1` (or at least 3 if it's the first triplet found).

By the end of iterating through the array, the length of the longest subsequence can be found by checking the maximum value in `dp`.



```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        index_map = {x: i for i, x in enumerate(arr)}
        n = len(arr)
        dp = {}
        longest = 0
        
        for i in range(n):
            for j in range(i):
                ak = arr[i] - arr[j]  # This could potentially be a[k]
                # Check if ak exists in arr and ak < arr[j] for the sequence order ak, arr[j], arr[i]
                if ak in index_map and index_map[ak] < j:
                    k = index_map[ak]
                    if (k, j) in dp:
                        dp[(j, i)] = dp[(k, j)] + 1
                    else:
                        dp[(j, i)] = 3  # first time find for this [ak, arr[j], arr[i]], length is 3
                    longest = max(longest, dp[(j, i)])

        return longest


```

Detailed explanation of the main points:
- Construct `index_map` to refer indices by value for fast access, helping identify if some `arr[k]` exists.
- Use `dp` to store the length of sequences ending with pairs `(j, i)`.
- Traverse each pair `(j, i)` while checking if a valid `arr[k]` exists such that `arr[k] + arr[j] == arr[i]`.
- Update the lengths in `dp` according to whether the sequence can be started or extended `(dp[(k, j)] + 1)`.
- Determine `longest` to be the length of the longest subsequence found.

This solution fits within the constraints and should efficiently compute the result for the input bounds given.

# 888. Fair Candy Swap

### Problem Description 
Alice and Bob have candy bars of different sizes: `A[i]` is the size of the `i`-th bar of candy that Alice has, and `B[j]` is the size of the `j`-th bar of candy that Bob has.

Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.)
Return an integer array `ans` where `ans[0]` is the size of the candy bar that Alice must exchange, and `ans[1]` is the size of the candy bar that Bob must exchange.

If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.


Example 1:
Input: A = [1,1], B = [2,2]
Output: [1,2]

Example 2:
Input: A = [1,2], B = [2,3]
Output: [1,2]

Example 3:
Input: A = [2], B = [1,3]
Output: [2,3]

Example 4:
Input: A = [1,2,5], B = [2,4]
Output: [5,4]
Note:
`1 <= A.length <= 10000`
`1 <= B.length <= 10000`
`1 <= A[i] <= 100000`
`1 <= B[i] <= 100000`
It is guaranteed that Alice and Bob have different total amounts of candy.

It is guaranteed there exists an answer.

### Solution 
 Here is a Python code solution for the described problem, suitable for direct execution on LeetCode.



```python
class Solution:
    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:
        sumA = sum(A)  # Sum of all candies Alice has
        sumB = sum(B)  # Sum of all candies Bob has
        diff = (sumA - sumB) // 2  # The target difference Alice needs to lose to equalize with Bob
        
        setB = set(B)  # A set for quick lookup of Bob's candies
        
        for candy in A:
            # Find the target candy in B that will balance the two sums
            if candy - diff in setB:
                return [candy, candy - diff]

# Below is for an example and testing
# sol = Solution()
# print(sol.fairCandySwap([1,2,5], [2,4]))  # Expected output: [5,4]

```

### Explanation

The problem boils down to finding a pair of values, one from array `A` and another from array `B`, such that the exchange of these values results in both `A` and `B` having the same total sum of candies. This condition can be expressed mathematically as:

1. Let `sumA` be the total sum of candies in `A`.
2. Let `sumB` be the total sum of candies in `B`.
3. The necessary condition after swapping candy size `x` from `A` with `y` from `B` is: 
   \[
   \text{sumA} - x + y = \text{sumB} - y + x
   \]
   Simplifying that:
   \[
   2y = 2x + \text{sumB} - \text{sumA}
   \]
   Reducing further, we find:
   \[
   y = x + (\text{sumB} - \text{sumA}) / 2 = x - \text{diff}
   \]
   where `diff = (sumA - sumB) / 2`.

Given this relationship, we can solve the problem efficiently:

1. Calculate `sumA`, `sumB`, and `diff`.
2. Create a `set` from array `B` for O(1) average time complexity look-up.
3. Iterate over each candy size `x` in `A`, and check if there's a candy size `y = x - diff` in `B` using the set.
4. If found, return `[x, y]`.
  
The solution is efficient with a time complexity of O(n + m), where `n` and `m` are the lengths of arrays `A` and `B`, respectively. Constructing the set `setB` is O(m), and scanning through `A` is O(n). This makes the approach well-suited for the input size constraints.

# 891. Sum of Subsequence Widths

### Problem Description 
Given an array of integers `A`, consider all non-empty subsequences of `A`.

For any sequence S, let the width of S be the difference between the maximum and minimum element of S.

Return the sum of the widths of all subsequences of A. 
As the answer may be very large, return the answer modulo 10^9 + 7.


Example 1:
Input: [2,1,3]
Output: 6
Explanation:
Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].

The corresponding widths are 0, 0, 0, 1, 1, 2, 2.

The sum of these widths is 6.

Note:
`1 <= A.length <= 20000`
`1 <= A[i] <= 20000`

### Solution 
 To solve this problem, an efficient approach would be to first sort the array `A`. After sorting, for each element at index `i`, you can determine how many times it will be the maximum and how many times it will be the minimum in all its possible subsequences.

#### Detailed Explanation:
1. **Sorting the Array**:
   - Each element in the sorted array contributes to the width in two ways:
     - As a **maximum** in any subsequence it appears in.
     - As a **minimum** in any subsequence it appears in.

2. **Power of Two Concept**:
   - Any element at position `i` will appear as maximum in all subarrays that start from index up to `i` and end beyond `i`. The number of such combinations is `2^(n-i-1)`, where `n` is the length of the array.
   - Similarly, this element will appear as minimum in all subarrays that start from or before `i` and extend beyond `i`. The number of such combinations is `2^i`.

3. **Effective Width Contribution**:
   - Thus, the effective contribution of `A[i]` to the sum of all sequence widths, considering all subsequences, can be computed as:
     - `A[i] * 2^i` as minimum.
     - `-A[i] * 2^(n-i-1)` as maximum when appearing in all possible subsequences.

4. **Efficiency via Handling Powers of 2**:
   - Directly calculating `2^i` for all `i` can be slow and lead to large numbers, hence they can be handled by continuously using modulo arithmetic to keep the numbers manageable.

5. **Aggregate and Compute Final Result**:
   - Compute the final sum in a loop while applying the modulo \(10^9 + 7\) to keep the results within the limits.

#### Python Code Implementation:



```python
MOD = 10**9 + 7

class Solution:
    def sumSubseqWidths(self, A: List[int]) -> int:
        n = len(A)
        A.sort()  # Sort the array
        
        pow2 = [1] * n
        for i in range(1, n):
            pow2[i] = pow2[i-1] * 2 % MOD
        
        total_sum = 0
        for i, value in enumerate(A):
            # contribution as minimum in subsequences starting from here to end
            total_sum += value * pow2[i]
            total_sum %= MOD
            
            # contribution as maximum in subsequences starting from before here to here
            total_sum -= value * pow2[n-i-1]
            total_sum %= MOD
        
        return total_sum

# This solution can be directly run on LeetCode for the respective problem (assuming the problem ID supports this format).

```

### Notes:
- The solution wisely utilizes modular arithmetic not just for the final answer but also to manage the computation of powers of two.
- The approach is based on defining the role of each item in the sorted array as both a minimizer and maximizer for every subsequence they partake in, leading to a more efficient algorithm than attempting to generate each subsequence explicitly.

# 896. Monotonic Array

### Problem Description 
An array is monotonic if it is either monotone increasing or monotone decreasing.

An array `A` is monotone increasing if for all `i <= j`, `A[i] <= A[j]`.  An array `A` is monotone decreasing if for all `i <= j`, `A[i] >= A[j]`.

Return `true` if and only if the given array `A` is monotonic.


Example 1:
Input: [1,2,2,3]
Output: true

Example 2:
Input: [6,5,4,4]
Output: true

Example 3:
Input: [1,3,2]
Output: false

Example 4:
Input: [1,2,4,5]
Output: true

Example 5:
Input: [1,1,1]
Output: true
Note:
`1 <= A.length <= 50000`
`-100000 <= A[i] <= 100000`

### Solution 
 Here's a Python code that checks if an array is monotonic:



```python
class Solution:
    def isMonotonic(self, A: List[int]) -> bool:
        increasing = decreasing = True
        
        for i in range(1, len(A)):
            if A[i] > A[i - 1]:
                decreasing = False
            if A[i] < A[i - 1]:
                increasing = False
        
        return increasing or decreasing

```

Explanation:

1. The function takes a list `A` as input.
2. Two boolean flags, `increasing` and `decreasing`, are initialized as `True` to track whether the array is monotonic increasing or decreasing.
3. We then loop through the array starting from the second element. For each element, we compare it with the previous one:
   - If the current element is greater than the previous (`A[i] > A[i - 1]`), then we can't be in a decreasing sequence, so `decreasing` is set to `False`.
   - Similarly, if the current element is lesser than the previous (`A[i] < A[i - 1]`), then we can't be in an increasing sequence, so `increasing` is set to `False`.
4. After finishing the loop, if either `increasing` or `decreasing` is still `True`, the array is monotonic. Otherwise, it's not.
5. We finally return `increasing or decreasing`.

The runtime complexity of this solution is O(n), where n is the length of the array `A`. This is because we need to check each element in the array once to determine the nature of its monotonicity. The space complexity is O(1), as we only use a constant amount of extra space for the boolean flags. This solution is efficient and should work within the given constraints.

# 900. RLE Iterator

### Problem Description 
Write an iterator that iterates through a run-length encoded sequence.

The iterator is initialized by `RLEIterator(int[] A)`, where `A` is a run-length encoding of some sequence.  More specifically, for all even `i`, `A[i]` tells us the number of times that the non-negative integer value `A[i+1]` is repeated in the sequence.

The iterator supports one function: `next(int n)`, which exhausts the next `n` elements (`n >= 1`) and returns the last element exhausted in this way.  If there is no element left to exhaust, `next` returns `-1` instead.

For example, we start with `A = [3,8,0,9,2,5]`, which is a run-length encoding of the sequence `[8,8,8,5,5]`.  This is because the sequence can be read as "three eights, zero nines, two fives".


Example 1:
Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]
Output: [null,8,8,5,-1]
Explanation: 
RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).

This maps to the sequence [8,8,8,5,5].

RLEIterator.next is then called 4 times:
.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].

.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].

.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].

.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,
but the second term did not exist.  Since the last term exhausted does not exist, we return -1.

Note:
`0 <= A.length <= 1000`
`A.length` is an even integer.

`0 <= A[i] <= 10^9`
There are at most `1000` calls to `RLEIterator.next(int n)` per test case.

Each call to `RLEIterator.next(int n)` will have `1 <= n <= 10^9`.

### Solution 
 To solve the problem, we'll create a class `RLEIterator` that will simulate the behavior of iterating over a run-length encoded sequence based on the provided encoding rules. Here are the detailed steps of the solution:

1. **Initialization (`__init__` Method)**: Here, we simply store the list and initialize necessary pointers. The list will be iterated in pairs (count and value), so we'll use an index pointer (`self.index`) to track our current position in the list, and a count pointer (`self.count`) to keep track of how many items of the current value we have left.

2. **Next (`next` Method)**: This function will receive a parameter `n` which indicates the number of elements to be exhausted. The method will loop through the list consuming `n` elements by decrementing from the count of the current position's item till `n` becomes zero or the list ends:
   - If the current count at the iterator's position is greater than or equal to `n`, that means all requested items can be supplied by the current number. We would then decrement the count and point `n` to zero.
   - If the current count is less than `n`, that means the current number can only fulfill part of `n`. We subtract the current count from `n`, set `count` to zero, and move `index` to the next pair in the list.
   - Continue the above steps until `n` is zero or the entire list is exhausted.
   - If we're able to serve all elements, return the last element served. Otherwise, return `-1`.

By handling the iteration in such a manner, we avoid the need to explicitly expand the run-length encoded list, which could be memory-intensive for large lengths. This approach should work efficiently within the constraints.

Let's implement this logic in Python according to the description:



```python
class RLEIterator:

    def __init__(self, A):
        self.A = A
        self.index = 0  # index for the count of elements
        self.count = 0  # remaining count of current element
    
    def next(self, n):
        while self.index < len(self.A) and n > 0:
            if self.count == 0:  # if count has exhausted, move to next element
                self.count = self.A[self.index]
                self.element = self.A[self.index + 1]
                self.index += 2
            if self.count > n:  # remaining count is enough to fulfill the request
                self.count -= n
                last_element = self.element
                n = 0
            else:  # count is not enough
                n -= self.count
                last_element = self.element
                self.count = 0

        if n > 0:  # if there is still some n left, it's not fulfilled
            return -1
        return last_element
        
# Your RLEIterator object will be instantiated and called as such:
# obj = RLEIterator(A)
# param_1 = obj.next(n)

```

This solution adheres to the problem requirements specified, using an index and count mechanism to iterate over the encoded array efficiently, serving `.next()` calls as required.

# 905. Sort Array By Parity

### Problem Description 
Given an array `A` of non-negative integers, return an array consisting of all the even elements of `A`, followed by all the odd elements of `A`.

You may return any answer array that satisfies this condition.


Example 1:
Input: [3,1,2,4]
Output: [2,4,3,1]
The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.

Note:
`1 <= A.length <= 5000`
`0 <= A[i] <= 5000`

### Solution 
 You can solve this problem by following these steps:

1. Initialize two lists: one for even numbers and another for odd numbers.
2. Iterate through each element in the given array `A`.
3. Check if an element is even or odd by leveraging the modulo operation.
4. Append even numbers to the even list and odd numbers to the odd list.
5. Finally, combine the even numbers list with the odd numbers list to get the desired result.

To implement this in a LeetCode-compatible format, you should write a class and method as outlined in the template they provide. Below is a Python solution following this approach:



```python
class Solution:
    def sortArrayByParity(self, A: List[int]) -> List[int]:
        even_nums = []  # List to hold even numbers
        odd_nums = []   # List to hold odd numbers
        
        # Iterate over each element in A
        for num in A:
            if num % 2 == 0:
                even_nums.append(num)  # Collect even numbers
            else:
                odd_nums.append(num)    # Collect odd numbers
                
        # Concatenate the even and odd lists
        return even_nums + odd_nums

# Here's how you can use the class to invoke the method
# sol = Solution()
# print(sol.sortArrayByParity([3, 1, 2, 4]))

```

In this code:
- `even_nums`: stores the even elements from `A`.
- `odd_nums`: stores the odd elements from `A`.
These two intermediate lists are used to clearly separate the elements based on their parity. Then, by concatenating `even_nums` with `odd_nums`, we obtain the desired result where all evens precede all odds.

This solution efficiently satisfies the problem's constraints and requirements, using O(n) time complexity for traversing the list and O(n) space complexity for storing the result.

# 907. Sum of Subarray Minimums

### Problem Description 
Given an array of integers arr, find the sum of `min(b)`, where `b` ranges over every (contiguous) subarray of `arr`. Since the answer may be large, return the answer modulo `109 + 7`.


Example 1:
Input: arr = [3,1,2,4]
Output: 17
Explanation: 
Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. 
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.

Sum is 17.


Example 2:
Input: arr = [11,81,94,43,3]
Output: 444

Constraints:
`1 <= arr.length <= 3 * 104`
`1 <= arr[i] <= 3 * 104`

### Solution 
 The objective is to efficiently calculate the sum of the minimum values of all contiguous subarrays formed from the input array, while ensuring the calculated result doesn't overflow with the use of modulo \(10^9 + 7\). 

The naive approach, which involves generating all subarrays and finding their minimums, is computationally expensive with a time complexity of \(O(n^3)\) and not suitable for the input constraints given (up to \(30000\) elements). Instead, we can opt for a more advanced approach using a stack, reducing the problem to \(O(n)\) time complexity.

**Approach:**

1. **Concept of Previous-less and Next-less elements**:
   - **Previous-less Element (PLE)** of an element is the nearest element on the left which is smaller than the current element.
   - **Next-less Element (NLE)** of an element is the nearest element on the right which is smaller than the current element.

2. For each element in the array, calculate:
    - How many subarrays it could be the minimum: This can be determined by:
        - The distance to the PLE multiplied by the distance to the NLE.
        - This counts the possible subarrays formed by considering this element as the minimum.
    - Thus, the contribution of each element `arr[i]` to the sum is `arr[i] * (distance to PLE) * (distance to NLE)`.

3. Use two passes with a stack:
    - **First Pass**: Determine the distance to the next previous-less element for each element.
    - **Second Pass**: Determine the distance to the next-less element for each element.
  
4. Sum the contributions for each element:
    - Using the derived formula sum up `arr[i]` contributions from step 2 multiplied by modulo \(10^9 + 7\).

The following Python code implements this approach:



```python
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(arr)
        left = [0] * n
        right = [0] * n
        
        # Maintain a stack for the purpose of finding PLE and NLE for each element
        stack = []
        # For distance to the Previous less element
        for i in range(n):
            # keep the stack holding the indices strictly increasing w.r.t. arr values
            while stack and arr[stack[-1]] > arr[i]:
                stack.pop()
            left[i] = i + 1 if not stack else i - stack[-1]
            stack.append(i)
        
        stack = []
        # For distance to the Next less element
        for i in range(n - 1, -1, -1):
            # strictly non-decreasing
            while stack and arr[stack[-1]] >= arr[i]:
                stack.pop()
            right[i] = n - i if not stack else stack[-1] - i
            stack.append(i)
        
        # Compute the result
        res = 0
        for i in range(n):
            res = (res + arr[i] * left[i] * right[i]) % MOD
        
        return res

```

**Explanation**:
- This code focuses on calculating for each element, the number of subarrays where it serves as the minimum.
- `left[i]` is calculated as the number of contiguous elements to the left (including itself) till a lesser element is found.
- `right[i]` finds the number of contiguous elements to the right till a lesser element.
- For each element in the array, its contribution to the sum is `arr[i] * left[i] * right[i]`, and this sum is taken modulo \(10^9 + 7\).
- By breaking the problem into finding ranges in which an element is the minimum and using stack techniques to efficiently calculate these, the solution is very efficient compared to the simple but impractical brute force method.

# 914. X of a Kind in a Deck of Cards

### Problem Description 
In a deck of cards, each card has an integer written on it.

Return `true` if and only if you can choose `X >= 2` such that it is possible to split the entire deck into 1 or more groups of cards, where:
Each group has exactly `X` cards.

All the cards in each group have the same integer.


Example 1:
Input: deck = [1,2,3,4,4,3,2,1]
Output: true
Explanation: Possible partition [1,1],[2,2],[3,3],[4,4].


Example 2:
Input: deck = [1,1,1,2,2,2,3,3]
Output: false
Explanation: No possible partition.


Example 3:
Input: deck = [1]
Output: false
Explanation: No possible partition.


Example 4:
Input: deck = [1,1]
Output: true
Explanation: Possible partition [1,1].


Example 5:
Input: deck = [1,1,2,2,2,2]
Output: true
Explanation: Possible partition [1,1],[2,2],[2,2].


Constraints:
`1 <= deck.length <= 104`
`0 <= deck[i] < 104`

### Solution 
 To solve the problem of checking whether we can split a deck of cards into groups where each group has the same number of cards with the same integer, we can follow these steps:

1. Count the frequency of each card in the deck using a dictionary or a `collections.Counter`.
2. Find the greatest common divisor (GCD) of the counts of each card. Python's `math.gcd` can simplify this step, especially when combined with `functools.reduce` to apply the GCD function across all values.
3. If the GCD of all the counts is 2 or greater, it means we can split the deck into groups of that size. Otherwise, if the GCD is 1, it's not possible.

This strategy is efficient as it leverages counting and calculating the GCD, both of which are computationally manageable even for the upper deck size limits.

Now, let's implement the solution:



```python
from collections import Counter
import math
from functools import reduce

class Solution:
    def hasGroupsSizeX(self, deck):
        # Step 1: Count the frequency of each number in the deck
        count = Counter(deck)
        
        # Step 2: Find the GCD of the counts of the cards
        # Using reduce to apply math.gcd across all values in counts
        # Use a list of counts to get the values of each count from the counter
        GCD = reduce(math.gcd, count.values())
        
        # Step 3: Check if the GCD is at least 2
        return GCD >= 2

# Example Usage and Testing
sol = Solution()
# Example 1
print(sol.hasGroupsSizeX([1,2,3,4,4,3,2,1]))  # Output: true
# Example 2
print(sol.hasGroupsSizeX([1,1,1,2,2,2,3,3]))  # Output: false
# Example 3
print(sol.hasGroupsSizeX([1]))                # Output: false
# Example 4
print(sol.hasGroupsSizeX([1,1]))              # Output: true
# Example 5
print(sol.hasGroupsSizeX([1,1,2,2,2,2]))      # Output: true

```

This code efficiently solves the problem and adheres to LeetCode's format requirements. The `hasGroupsSizeX` method counts the frequencies using a `Counter`, then calculates the GCD across these frequencies, and finally checks if this GCD is at least 2.

# 915. Partition Array into Disjoint Intervals

### Problem Description 
Given an array `A`, partition it into two (contiguous) subarrays `left` and `right` so that:
Every element in `left` is less than or equal to every element in `right`.

`left` and `right` are non-empty.

`left` has the smallest possible size.

Return the length of `left` after such a partitioning.  It is guaranteed that such a partitioning exists.


Example 1:
Input: [5,0,3,8,6]
Output: 3
Explanation: left = [5,0,3], right = [8,6]

Example 2:
Input: [1,1,1,0,6,12]
Output: 4
Explanation: left = [1,1,1,0], right = [6,12]
Note:
`2 <= A.length <= 30000`
`0 <= A[i] <= 10^6`
It is guaranteed there is at least one way to partition `A` as described.

### Solution 
 To approach this problem, the key is to ensure that every element in the left subarray `left` is less than or equal to every element in the right subarray `right`. Our goal is to find the smallest size of the left partition that meets this condition.

The strategy can be outlined as follows:
1. Compute the maximum element from the start up to each position in the array (`max_left[]`).
2. Compute the minimum element from each position to the end of the array (`min_right[]`).
3. Traverse the array and find the earliest position where the last element in `max_left[]` array is less than or equal to the first element in the `min_right[]` array. This determines the boundary of the left partition.

By using additional arrays `max_left` and `min_right` to store maximums and minimums at each step, we avoid nested loops, keeping the algorithm efficient. The details involve taking care of boundary conditions and ensuring that the smallest possible left partition is found.

Here's a Python code implementation to solve the problem:



```python
class Solution:
    def partitionDisjoint(self, A: List[int]) -> int:
        n = len(A)
        max_left = [0] * n
        min_right = [0] * n
        
        max_left[0] = A[0]
        for i in range(1, n):
            max_left[i] = max(max_left[i-1], A[i])
        
        min_right[n-1] = A[n-1]
        for i in range(n-2, -1, -1):
            min_right[i] = min(min_right[i+1], A[i])
        
        for i in range(1, n):
            if max_left[i-1] <= min_right[i]:
                return i
                
        return 1  # this would never be reached as the problem guarantees a solution exists

```

**Explanation of the Code:**
1. We start by initializing arrays `max_left` and `min_right`. `max_left[i]` will contain the maximum value from the start of the array up to the index `i`. `min_right[i]` will store the minimum value from the index `i` to the end of the array.
2. We fill out the `max_left` array by taking the maximum of the current element and the maximum up to the previous index.
3. We populate the `min_right` array starting from the end and moving backwards, taking the minimum of the current element and the minimum of following elements.
4. We then iterate through the array to find the smallest subarray `left` for which the maximum is less than or equal to the minimum of the subarray `right`, starting right next to `left`.
5. Although the function has a safeguard to return an index, the problem guarantees a solution exists, so the function will find a `left` size before it iterates through the entire array.

This solution effectively partitions the array as required and runs in linear time O(n), making it efficient for the input size constraints.

# 918. Maximum Sum Circular Subarray

### Problem Description 
Given a circular array C of integers represented by `A`, find the maximum possible sum of a non-empty subarray of C.

Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, `C[i] = A[i]` when `0 <= i < A.length`, and `C[i+A.length] = C[i]` when `i >= 0`.)
Also, a subarray may only include each element of the fixed buffer `A` at most once.  (Formally, for a subarray `C[i], C[i+1], ..., C[j]`, there does not exist `i <= k1, k2 <= j` with `k1 % A.length = k2 % A.length`.)

Example 1:
Input: [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3

Example 2:
Input: [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10

Example 3:
Input: [3,-1,2,-1]
Output: 4
Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4

Example 4:
Input: [3,-2,2,-3]
Output: 3
Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3

Example 5:
Input: [-2,-3,-1]
Output: -1
Explanation: Subarray [-1] has maximum sum -1
Note: 
`-30000 <= A[i] <= 30000`
`1 <= A.length <= 30000`

### Solution 
 To solve this problem, we need to consider two scenarios:

1. **Maximum Subarray Sum without Wrapping:**
   This can be solved using Kadane's algorithm, which efficiently finds the maximum sum of a subarray in O(n) time.

2. **Maximum Subarray Sum with Wrapping:**
   If the subarray wraps around, the problem can be converted into finding the subarray with the minimum sum (i.e., which when subtracted from the total sum of the array, gives the maximum circular subarray sum). For example, if the minimum sum subarray is found to be among elements that are not at either end of the array, then selecting the rest of the array outside these elements can potentially give a circular max sum.

Steps to solve the problem:
1. Apply Kadane’s algorithm to find the maximum sum of a subarray (non-circular).
2. Calculate the total sum of the array.
3. Apply Kadane’s algorithm again but to find the minimum sum subarray by inverting the signs of the elements (effectively flipping the operation). Then the maximum circular sum will be `total_sum - min_subarray_sum`.
4. Combine information: the final result will be the greater value between the sum from step 1 and step 3.
5. A special case needs to be addressed: if all numbers are negative, the max subarray sum without wrap should be returned since the result of `total_sum - min_subarray_sum` would zero out the entire array.

Here's the implementation using Python, structured in the classic coding challenge format:



```python
class Solution:
    def maxSubarraySumCircular(self, A: List[int]) -> int:
        def kadane(gen):
            max_ending_here = max_so_far = next(gen)
            for x in gen:
                max_ending_here = max(x, max_ending_here + x)
                max_so_far = max(max_so_far, max_ending_here)
            return max_so_far
        
        # Case 1: Non-circular maximum subarray sum
        max_normal = kadane(iter(A))
        
        # Case 2: Circular case
        max_circular = sum(A) - kadane(-A[i] for i in range(1, len(A))) # Max inverted subarray sum in A[1:] to A[:-1]
        max_circular_2 = sum(A) - kadane(-A[i] for i in range(len(A) - 1)) # Max inverted subarray sum in A[:-1] to A[1:]
        
        # Corner case when all numbers are negative, kadane on inverted returns 0 which is invalid
        if max_circular == 0 or max_circular_2 == 0:
            return max_normal
        
        # Return the maximum of the non-circular sum and the two circular sums
        return max(max_normal, max_circular, max_circular_2)

# Example usage:
sol = Solution()
print(sol.maxSubarraySumCircular([1, -2, 3, -2]))   # Output: 3
print(sol.maxSubarraySumCircular([5, -3, 5]))       # Output: 10
print(sol.maxSubarraySumCircular([3, -1, 2, -1]))   # Output: 4
print(sol.maxSubarraySumCircular([3, -2, 2, -3]))   # Output: 3
print(sol.maxSubarraySumCircular([-2, -3, -1]))     # Output: -1

```

This code represents a solution that leverages principles of dynamic programming to efficiently derive the maximum sum of a subarray in a potentially circular array configuration.

# 922. Sort Array By Parity II

### Problem Description 
Given an array of integers `nums`, half of the integers in `nums` are odd, and the other half are even.

Sort the array so that whenever `nums[i]` is odd, `i` is odd, and whenever `nums[i]` is even, `i` is even.

Return any answer array that satisfies this condition.


Example 1:
Input: nums = [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.


Example 2:
Input: nums = [2,3]
Output: [2,3]

Constraints:
`2 <= nums.length <= 2 * 104`
`nums.length` is even.

Half of the integers in `nums` are even.

`0 <= nums[i] <= 1000`

### Solution 
 To address the problem described, the strategy will be to separate the even and odd numbers and then stitch them back together while ensuring the even and odd indices in the resultant array conform to the given conditions. Here's a step-by-step plan:

1. Iterate through the input list `nums` and separate the numbers into two lists: one for evens and one for odds.
2. Initialize two pointers, `even_index` and `odd_index`, starting from 0 for even indices and 1 for odd indices respectively.
3. Create a new list (of the same length as `nums`) to store the result.
4. Use a loop to fill in the new list: Place an even number from the evens list at `even_index` and increment `even_index` by 2; place an odd number from the odds list at `odd_index` and increment `odd_index` by 2.
5. Repeat this until you've placed all numbers from both even and odd lists into the result list.
6. Return the result list.

This approach ensures that the result list is filled correctly according to the conditions specified. Given the constraints (including that the list has as many even numbers as odd numbers), this method will work efficiently.

Here's how the complete solution would look like in Python, ready to run on LeetCode:



```python
class Solution:
    def sortArrayByParityII(self, nums: List[int]) -> List[int]:
        even_nums = []
        odd_nums = []
        
        # Separate numbers into evens and odds
        for num in nums:
            if num % 2 == 0:
                even_nums.append(num)
            else:
                odd_nums.append(num)
        
        # Result list with the same length as input list
        result = [0] * len(nums)
        
        # Fill even indices with even numbers
        even_index = 0
        for even in even_nums:
            result[even_index] = even
            even_index += 2
        
        # Fill odd indices with odd numbers
        odd_index = 1
        for odd in odd_nums:
            result[odd_index] = odd
            odd_index += 2
            
        return result

```

When you paste this solution into LeetCode, it should run correctly based on the problem's constraints and should produce a valid output for any input that meets the problem's specified conditions. This solution is efficient and adheres to the O(n) space and time complexity, where n is the number of elements in `nums`, as we need to iterate over the list and use additional lists to store evens and odds separately.

# 926. Flip String to Monotone Increasing

### Problem Description 
A string of `'0'`s and `'1'`s is monotone increasing if it consists of some number of `'0'`s (possibly 0), followed by some number of `'1'`s (also possibly 0.)
We are given a string `S` of `'0'`s and `'1'`s, and we may flip any `'0'` to a `'1'` or a `'1'` to a `'0'`.

Return the minimum number of flips to make `S` monotone increasing.


Example 1:
Input: "00110"
Output: 1
Explanation: We flip the last digit to get 00111.


Example 2:
Input: "010110"
Output: 2
Explanation: We flip to get 011111, or alternatively 000111.


Example 3:
Input: "00011000"
Output: 2
Explanation: We flip to get 00000000.

Note:
`1 <= S.length <= 20000`
`S` only consists of `'0'` and `'1'` characters.

### Solution 
 To solve this problem, we need to evaluate breakpoints in the string `S` where before this point everything should be `0` and after (and including this point) everything should be `1`. We must determine the minimum cost (number of flips) to transform the string into this form for each possible breakpoint.

An effective method to find the minimum number of flips involves preprocessing the input string to compute:
1. **prefix counts of ones (leftOnes)**: This array records the number of ones before and at each index.
2. **suffix counts of zeros (rightZeros)**: This array records the number of zeros from each index up to the end of the string.

For a given breakpoint si:
- **leftOnes[i]** gives the count of '1's that need to be turned into '0's (flipped to '0') if everything before index i is to be '0'.
- **rightZeros[i]** gives the count of '0's that need to be turned into '1's (flipped to '1') starting from index i up to the end.

The final answer will be `min(leftOnes[i] + rightZeros[i])` over all indices `i`. 

Let’s translate this logic into a Python solution that can be run on LeetCode:



```python
class Solution:
    def minFlipsMonoIncr(self, S: str) -> int:
        n = len(S)
        if n <= 1:
            return 0
        
        # Arrays to store counts of 1's and 0's as described above
        leftOnes = [0] * (n + 1)  # Number of 1's to the left of each position
        rightZeros = [0] * (n + 1)  # Number of 0's to the right of each position

        # Fill the leftOnes array
        for i in range(1, n + 1):
            leftOnes[i] = leftOnes[i - 1] + (1 if S[i - 1] == '1' else 0)

        # Fill the rightZeros array
        for i in range(n - 1, -1, -1):
            rightZeros[i] = rightZeros[i + 1] + (1 if S[i] == '0' else 0)

        # Calculate the minimum number of flips required
        min_flips = float('inf')
        for i in range(n + 1):
            min_flips = min(min_flips, leftOnes[i] + rightZeros[i])
        
        return min_flips

# Example use case:
sol = Solution()
print(sol.minFlipsMonoIncr("010110"))  # Should output 2

```
This code defines a `Solution` class with the method `minFlipsMonoIncr` that implements the aforementioned logic. It uses prefix and suffix arrays to count the '1's and '0's needed to be flipped and calculates the minimum number of flips required for all possible breakpoints (from before the first character to after the last character). This approach ensures an efficient and comprehensive solution to the problem.

# 945. Minimum Increment to Make Array Unique

### Problem Description 
Given an array of integers A, a move consists of choosing any `A[i]`, and incrementing it by `1`.

Return the least number of moves to make every value in `A` unique.


Example 1:
Input: [1,2,2]
Output: 1
Explanation:  After 1 move, the array could be [1, 2, 3].


Example 2:
Input: [3,2,1,2,1,7]
Output: 6
Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].

It can be shown with 5 or less moves that it is impossible for the array to have all unique values.

Note:
`0 <= A.length <= 40000`
`0 <= A[i] < 40000`

### Solution 
 To solve this problem efficiently, we can leverage sorting and a greedy approach. Here's the breakdown of the solution:

1. **Sorting for Order**: Start by sorting the array. The sorted order will allow us to handle duplicates systematically, processing them from the smallest to the largest.

2. **Detect and Resolve Duplicates**: As we traverse the sorted array, if we find that the current number is the same or less than the previous number, it's not unique. We need to increment it just enough so that it is greater than the previous number. Each increment counts as a move.

3. **Count Moves**: Maintain a counter to track the total number of moves made during the process of resolving duplicates.

This approach ensures that we achieve uniqueness with the least number of moves by locally optimizing at each step (i.e., by making the smallest necessary increment to resolve each conflict).

Here’s the Python code using this strategy:



```python
class Solution:
    def minIncrementForUnique(self, A: List[int]) -> int:
        if not A:
            return 0
        
        A.sort()
        moves = 0
        for i in range(1, len(A)):
            if A[i] <= A[i - 1]:
                prev = A[i]
                A[i] = A[i - 1] + 1
                moves += A[i] - prev
        
        return moves

# You can test the solution with:
# sol = Solution()
# print(sol.minIncrementForUnique([1, 2, 2]))  # Output: 1
# print(sol.minIncrementForUnique([3, 2, 1, 2, 1, 7]))  # Output: 6

```

### Explanation:

- **Edge Case**: The code first handles the case where the array is empty. If it is, no moves are necessary.
- **Sorting the array** reduces the problem complexity by organizing elements in order. We then only need to ensure that each element is greater than its preceding element to guarantee all are unique.
- **The loop** begins from the second element (`i = 1`) since the first element is trivially unique. If an element isn't greater than the previous one (`A[i] <= A[i - 1]`), it's incremented to be one more than the previous element (`A[i - 1] + 1`). Each incrementation's cost (the number of moves) is added to the `moves` counter.

This solution runs in O(n log n) time due to the sorting, and requires O(1) extra space if we disregard the input modifications (as input can be modified in-place).

This solution works within the constraints given (0 <= A.length <= 40000 and 0 <= A[i] < 40000) and ensures an efficient and clear path to making all elements unique with the minimum number of moves.

# 950. Reveal Cards In Increasing Order

### Problem Description 
In a deck of cards, every card has a unique integer.  You can order the deck in any order you want.

Initially, all the cards start face down (unrevealed) in one deck.

Now, you do the following steps repeatedly, until all cards are revealed:
Take the top card of the deck, reveal it, and take it out of the deck.

If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.

If there are still unrevealed cards, go back to step 1.  Otherwise, stop.

Return an ordering of the deck that would reveal the cards in increasing order.

The first entry in the answer is considered to be the top of the deck.


Example 1:
Input: [17,13,11,2,3,5,7]
Output: [2,13,3,11,5,17,7]
Explanation: 
We get the deck in the order [17,13,11,2,3,5,7] (this order doesn't matter), and reorder it.

After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.

We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].

We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].

We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].

We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].

We reveal 11, and move 17 to the bottom.  The deck is now [13,17].

We reveal 13, and move 17 to the bottom.  The deck is now [17].

We reveal 17.

Since all the cards revealed are in increasing order, the answer is correct.

Note:
`1 <= A.length <= 1000`
`1 <= A[i] <= 10^6`
`A[i] != A[j]` for all `i != j`

### Solution 
 To solve the problem stated, we can approach it by simulating the process of revealing the cards by first analyzing the behavior. The problem description provides a specific sequence by which cards must appear, given an initial order. Instead of trying to simulate these steps in forward motion, we can work backwards with these observations:

1. The card values need to be revealed in increasing order.
2. Each card that should appear in this order gets placed on top or beneath others based on the described operations of taking the top card and moving the second top card to the bottom.

Understanding this, one effective way is:
- Sort the deck of cards in increasing order.
- Simulate the process backwards by creating a "position placing" sequence using indices.

For this, we leverage the data structure 'deque' from the collections library in Python. A 'deque' enables addition and removal of elements from both ends efficiently, making it perfect for our scenario where we manipulate both the top and next to top cards continually.

The algorithm can be summarized as:
1. Sort the input list of card values.
2. Use a deque to simulate the index positions.
3. Insert positions in the deque in the manner the problem describes the card positioning:
     - Starting from the last card to the first in the sorted list.
     - Place each index in the front of the deque, and then take the last of the deque and re-position it to the front (mimicking the reverse of the moving the next top card to the bottom operation).
4. Once indices are placed, map them to the sorted values.

Now, let's implement this solution in Python using the specified format for LeetCode:



```python
from collections import deque

class Solution:
    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:
        n = len(deck)
        # Index deque
        idx_deque = deque()
        
        # Populate the deque with indices
        for i in range(n):
            idx_deque.append(i)
        
        # Sort the deck
        sorted_deck = sorted(deck)
        result = [0] * n
        
        # Assign sorted values to the right positions based on our index deque manipulation
        for card in sorted_deck:
            result[idx_deque.popleft()] = card
            if idx_deque:
                # Simulate the process of putting the next card to the bottom
                idx_deque.append(idx_deque.popleft())
        
        return result

```

This solution should be executed directly within the LeetCode platform. It adheres to the required interface and can be tested against provided test cases. The solution maintains an overall time complexity of \(O(n \log n)\) due to the sorting step, which is optimal given the necessity to sort for correct card ordering.

# 954. Array of Doubled Pairs

### Problem Description 
Given an array of integers `arr` of even length, return `true` if and only if it is possible to reorder it such that `arr[2 * i + 1] = 2 * arr[2 * i]` for every `0 <= i < len(arr) / 2`.


Example 1:
Input: arr = [3,1,3,6]
Output: false

Example 2:
Input: arr = [2,1,2,6]
Output: false

Example 3:
Input: arr = [4,-2,2,-4]
Output: true
Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].


Example 4:
Input: arr = [1,2,4,16,8,4]
Output: false

Constraints:
`0 <= arr.length <= 3 * 104`
`arr.length` is even.

`-105 <= arr[i] <= 105`

### Solution 
 To solve the problem, the key observation is that for every `x` in `arr`, there should exist a `2x` in the arrangement. This lets us verify the possibility of rearranging the array into the `[x, 2x, y, 2y, ...]` pattern.

The solution involves:
1. Counting occurrences of each number using a dictionary (`count`).
2. Sorting the numbers, taking care to handle negatives properly since they can complicate direct x, 2x pairings.
3. Trying to form the desired pairs from the smallest value to the largest, taking into account their counts.

### Solution Details:

- **Step 1:** Create a dictionary to count the occurrences of each element in the array.
- **Step 2:** Sort the values (absolute values for taking care of negatives properly).
- **Step 3:** Iterate through the sorted values. For each value `x`:
  - Check if the count of `x` is not zero.
  - For each `x`, look for `2 * x` and reduce the count in `count` dictionary accordingly. If `x` is negative and not divisible by 2 when looking for `x/2`, that also needs to be handled.
- **Step 4:** If at any point, the pair for an element cannot be found, immediately return `False`.
- **Step 5:** If all elements correctly form pairs, return `True`.

### Python Code:



```python
from collections import Counter

class Solution:
    def canReorderDoubled(self, arr: List[int]) -> bool:
        count = Counter(arr)
        for x in sorted(arr, key=abs):  # sorting by absolute value, makes negatives handle naturally
            if count[x] == 0:
                continue
            if count[2 * x] == 0:
                return False
            count[x] -= 1
            count[2 * x] -= 1
            
        return True

# Example of usage
if __name__ == "__main__":
    sol = Solution()
    print(sol.canReorderDoubled([4, -2, 2, -4]))  # Output: True
    print(sol.canReorderDoubled([1, 2, 4, 16, 8, 4]))  # Output: False

```

This solution uses a sorting mechanism (`sorted(arr, key=abs)`) which ensures that we handle both positive and negative numbers effectively. The handling of counts ensures that we match pairs `x` and `2x` (or `x` and `x/2` for negatives suitably) correctly, provided they exist. The overall time complexity is `O(n log n)` due to sorting, and the space complexity is `O(n)` for the counter. This makes the solution efficient given the problem constraints.

# 962. Maximum Width Ramp

### Problem Description 
Given an array `A` of integers, a ramp is a tuple `(i, j)` for which `i < j` and `A[i] <= A[j]`.  The width of such a ramp is `j - i`.

Find the maximum width of a ramp in `A`.  If one doesn't exist, return 0.


Example 1:
Input: [6,0,8,2,1,5]
Output: 4
Explanation: 
The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.


Example 2:
Input: [9,8,1,0,1,9,4,0,4,1]
Output: 7
Explanation: 
The maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1.

Note:
`2 <= A.length <= 50000`
`0 <= A[i] <= 50000`

### Solution 
 The problem is to find the maximum width of a ramp in an array, where a ramp is defined as a pair of indices `(i, j)` such that `i < j` and `A[i] <= A[j]`. The width of a ramp is the difference `j - i`.

**Solution Strategy:**
To efficiently tackle this problem, we can use a stack to keep track of potential "left" indices (`i`) for ramps. We'll work backward through the array, examining each element to determine if it is less than or equal to any of the indices already in the stack (thus potentially forming ramps).

**Steps:**
1. Traverse the array from right to left.
2. Use a stack to store indices, ensuring the elements corresponding to the indices are in a non-increasing order from the top to the bottom of the stack.
3. For each element in the traversal, while it's greater than the element indexed at the top of the stack, remove the top of the stack. This indicates that the current element can be a "right" index (`j`) to the "left" indices in the stack.
4. Attempt to form ramps by pairing the current index with the appropriate indices from the stack. Update the maximum width of the ramps accordingly.
5. Finally, output the maximum width found.

This approach guarantees that we efficiently assess when a ramp can form without having to use a brute-force double loop, offering significant savings, especially on larger inputs.

**Python Code:**



```python
class Solution:
    def maxWidthRamp(self, A: List[int]) -> int:
        # Stack to hold indices of array elements
        stack = []
        n = len(A)
        max_width = 0
        
        # Fill stack with indices such that elements of A are non-increasing
        for i in range(n):
            if not stack or A[stack[-1]] >= A[i]:
                stack.append(i)
        
        # Now traverse from right-to-left to calculate maximum width ramp
        for j in range(n-1, -1, -1):
            while stack and A[stack[-1]] <= A[j]:
                max_width = max(max_width, j - stack.pop())
        
        return max_width

```

**Explanation:**
- The first loop builds the stack such that it contains indices where each index in the stack represents an element that is greater than or equal to all elements represented by indexes above it in the stack.
- The second loop works backward, trying to find the furthest "left" index for each "right" index it considers, making sure the conditions `i < j` and `A[i] <= A[j]` are satisfied.
- The comparison `A[stack[-1]] <= A[j]` allows us to identify valid ramp endpoints.
- Using `stack.pop()` both checks the top of the stack and then removes its index, which is efficient and ensures that once an index is used as the left endpoint, it's not considered again.

This approach ensures an efficient resolution of the problem in O(n) time complexity due to the linear passes and stack operations, all of which are amortized O(1).

# 969. Pancake Sorting

### Problem Description 
Given an array of integers `arr`, sort the array by performing a series of pancake flips.

In one pancake flip we do the following steps:
Choose an integer `k` where `1 <= k <= arr.length`.

Reverse the sub-array `arr[0...k-1]` (0-indexed).

For example, if `arr = [3,2,1,4]` and we performed a pancake flip choosing `k = 3`, we reverse the sub-array `[3,2,1]`, so `arr = [1,2,3,4]` after the pancake flip at `k = 3`.

Return an array of the `k`-values corresponding to a sequence of pancake flips that sort `arr`. Any valid answer that sorts the array within `10 * arr.length` flips will be judged as correct.


Example 1:
Input: arr = [3,2,4,1]
Output: [4,2,4,3]
Explanation: 
We perform 4 pancake flips, with k values 4, 2, 4, and 3.

Starting state: arr = [3, 2, 4, 1]
After 1st flip (k = 4): arr = [1, 4, 2, 3]
After 2nd flip (k = 2): arr = [4, 1, 2, 3]
After 3rd flip (k = 4): arr = [3, 2, 1, 4]
After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.


Example 2:
Input: arr = [1,2,3]
Output: []
Explanation: The input is already sorted, so there is no need to flip anything.

Note that other answers, such as [3, 3], would also be accepted.


Constraints:
`1 <= arr.length <= 100`
`1 <= arr[i] <= arr.length`
All integers in `arr` are unique (i.e. `arr` is a permutation of the integers from `1` to `arr.length`).

### Solution 
 Below is a Python solution for the described problem following the constraints and logic based on pancake sorting. The code uses a greedy approach to bring the largest unsorted element to its correct place iteratively.



```python
class Solution:
    def pancakeSort(self, arr: List[int]) -> List[int]:
        def flip(k):
            i, j = 0, k - 1
            while i < j:
                arr[i], arr[j] = arr[j], arr[i]
                i += 1
                j -= 1

        def find_max_index(n):
            max_index = 0
            for i in range(n):
                if arr[i] > arr[max_index]:
                    max_index = i
            return max_index

        result = []
        n = len(arr)
        for size in range(n, 1, -1):
            max_index = find_max_index(size)
            if max_index + 1 != size:
                if max_index != 0:
                    result.append(max_index + 1)  # Flip the max element to the front
                    flip(max_index + 1)
                result.append(size)  # Flip it into its final position
                flip(size)
        return result

```

### Explanation:
1. **Function Definitions**:
    - `flip(k)`: This function reverses the first `k` elements of the array.
    - `find_max_index(n)`: Finds the index of the largest element in the first `n` elements of the array.

2. **Pancake Sorting Process**:
   - Iterate through the array from the last element down to the second element (`for size in range(n, 1, -1)`).
   - For each `size`, find the index of the maximum element in the first `size` elements using `find_max_index(size)`.
   - If this index is not already at its correct position (`size-1`),
     - If the maximum element is not at the beginning, perform a flip to bring this max element to the front (`flip(max_index + 1)`).
     - Perform another flip to move this max element from the front to its correct position (`flip(size)`).
   - Append each performed flip `k` value to the `result` list.

3. **Return Result**:
   - After the loop completes, the array should be sorted and `result` will contain the sequence of k-values of flips performed to sort the array.

### Complexity and Execution:
- **Time Complexity**: O(n^2), due to the nested operations (finding max and flipping) in a loop from `n` down to `1`.
- **Space Complexity**: O(1) additional space, since the flips are done in-place. The output list doesn't count towards extra space usage by problem statement conventions. 

This code should work directly when copied into LeetCode's online judge by replacing `List[int]` with the appropriate Python 3 type hint `from typing import List` if needed.

