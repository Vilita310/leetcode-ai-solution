# 1081. Smallest Subsequence of Distinct Characters

### Problem Description 
Return the lexicographically smallest subsequence of `s` that contains all the distinct characters of `s` exactly once.

Note: This question is the same as 316: https://leetcode.com/problems/remove-duplicate-letters/

Example 1:
Input: s = "bcabc"
Output: "abc"

Example 2:
Input: s = "cbacdcbc"
Output: "acdb"

Constraints:
`1 <= s.length <= 1000`
`s` consists of lowercase English letters.

### Solution 
 To solve the problem of finding the lexicographically smallest subsequence of a given string `s` that contains all the distinct characters exactly once, we can use a greedy algorithm with a stack. Hereâ€™s a detailed explanation followed by the implementation in the required LeetCode solution format.

### Detailed Explanation:

1. **Understanding the Problem**:
   - We need to traverse the string `s` and build a subsequence (result) such that:
     - All distinct characters are present.
     - The characters are in the lexicographically smallest order.

2. **Using a Stack**:
   - We'll utilize a stack to facilitate the construction of the result string. The stack helps us effectively maintain the order of characters.
   - As we traverse the string, we can decide whether to add a character to the stack or remove characters from the stack to ensure the subsequence remains lexicographically smallest.

3. **Tracking Characters**:
   - A count dictionary (or array since we have lowercase English letters) keeps track of the count of each character remaining in the string while we traverse it.
   - A boolean array keeps track of whether a character is already in the result (stack).

4. **Greedy Choice**:
   - For each character in the string:
     - If the character is already in the result (found in the stack), we skip it.
     - If the current character is smaller than the character on the top of the stack, and if we can still encounter the character at the top later in the string (checked using the count), we pop the stack.
     - Finally, we push the current character onto the stack and mark it as present in the result.

5. **Building the Result**:
   - Once we finish processing all characters, the stack will contain the desired subsequence. We then convert the stack to a string.

### Implementation:
Here's the code following the LeetCode solution format:



```python
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        # A count to track the occurrences of each character
        char_count = [0] * 26
        for char in s:
            char_count[ord(char) - ord('a')] += 1
        
        # A boolean array to track if a character is already added to the stack
        in_result = [False] * 26
        
        # Stack to build the result
        stack = []
        
        for char in s:
            # Decrease the count of the current character since we are processing it
            char_count[ord(char) - ord('a')] -= 1
            
            # If this character is already in the result, skip it
            if in_result[ord(char) - ord('a')]:
                continue
            
            # While stack is not empty and the current character is smaller than
            # the last character in stack and the last character will appear later
            while stack and stack[-1] > char and char_count[ord(stack[-1]) - ord('a')] > 0:
                removed_char = stack.pop()
                in_result[ord(removed_char) - ord('a')] = False
            
            # Add the current character to the result
            stack.append(char)
            in_result[ord(char) - ord('a')] = True
        
        # Join the characters in stack to form the result
        return ''.join(stack)

```

### Summary:
- The solution employs a greedy algorithm using a stack, ensuring both uniqueness and lexicographical order of characters.
- The runtime complexity is O(n) since each character in the string is processed a limited number of times, making it efficient for the input constraints.

# 1124. Longest Well-Performing Interval

### Problem Description 
We are given `hours`, a list of the number of hours worked per day for a given employee.

A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than `8`.

A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.

Return the length of the longest well-performing interval.


Example 1:
Input: hours = [9,9,6,0,6,6,9]
Output: 3
Explanation: The longest well-performing interval is [9,9,6].


Constraints:
`1 <= hours.length <= 10000`
`0 <= hours[i] <= 16`

### Solution 
 To solve the problem of finding the longest well-performing interval based on the working hours, we'll create a Python solution that efficiently tracks tiring and non-tiring days. The core idea is to use a balance array that helps us track the relative number of tiring days compared to non-tiring days.

### Explanation

1. **Define a Tiring Day**: A day is considered tiring if the hours worked are greater than 8. Therefore, our first step is to convert the list of hours into a balance format, where we treat tiring days as `+1` and non-tiring days as `-1`. 

2. **Use a Balance Dictionary**: As we iterate through the days, we maintain a running balance that reflects the number of tiring days minus non-tiring days. We can use a dictionary to store the first occurrence of each balance value. This will allow us to find the longest interval (where the balance at the end minus balance at the start reflects more tiring days).

3. **Finding the Longest Interval**: For each day, we'll check if the current balance indicates that there are more tiring days than non-tiring days. If yes, we calculate the length of the interval from the first occurrence of that particular balance value.

4. **Complexity**: Since we are traversing through the hours array only once and using a dictionary to store balance indices, the overall time complexity is O(n), where n is the length of the hours list.

### Implementation

Here is the Python code that implements the above approach:



```python
class Solution:
    def longestWPI(self, hours):
        # Initialize the balance to 0 and a dictionary to map balance to first index
        balance = 0
        first_occurrence = {0: -1}  # Handle case where the entire interval is well-performing
        max_length = 0
        
        for i, hour in enumerate(hours):
            # Increase balance for tiring days, decrease for non-tiring days
            if hour > 8:
                balance += 1  # Tiring day
            else:
                balance -= 1  # Non-tiring day
            
            # Check if this balance has been seen before
            if balance > 0:
                # If the current balance is positive, the interval from the start to now is well-performing
                max_length = i + 1
            else:
                # Only record the first occurrence of each balance
                if balance not in first_occurrence:
                    first_occurrence[balance] = i
            
            # If we have seen a smaller balance before, compute the length
            if (balance - 1) in first_occurrence:
                # Calculate the length of the well-performing interval
                max_length = max(max_length, i - first_occurrence[balance - 1])
        
        return max_length

```

### Steps to Run on LeetCode
1. Copy the code above.
2. Navigate to the LeetCode page for the problem statement.
3. Paste the code into the code editor provided on the page.
4. Run the code using the 'Run' button to test against the sample inputs, or use the 'Submit' button to submit for validation against all test cases.

#### Example Usage
Given the input `hours = [9,9,6,0,6,6,9]`, the function will return `3`, which is the length of the longest well-performing interval `[9, 9, 6]`. This is computed during the iteration where we keep track of the balance and find the maximum length of the qualified intervals.

# 1130. Minimum Cost Tree From Leaf Values

### Problem Description 
Given an array `arr` of positive integers, consider all binary trees such that:
Each node has either 0 or 2 children;
The values of `arr` correspond to the values of each leaf in an in-order traversal of the tree.  (Recall that a node is a leaf if and only if it has 0 children.)
The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.

Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit integer.


Example 1:
Input: arr = [6,2,4]
Output: 32
Explanation:
There are two possible trees.  The first has non-leaf node sum 36, and the second has non-leaf node sum 32.

    24            24
   /  \          /  \
  12   4        6    8
 /  \               / \
6    2             2   4

Constraints:
`2 <= arr.length <= 40`
`1 <= arr[i] <= 15`
It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than `2^31`).

### Solution 
 To solve this problem, we need to construct all possible binary trees from the given `arr` such that the value of each non-leaf node is the product of the maximum leaf values from its left and right subtrees, and then return the smallest possible sum of the values of all non-leaf nodes.

### Approach

1. **Dynamic Programming**: We'll utilize dynamic programming (DP) to store the results of subproblems. The DP table will be set up in such a way that:
   - `dp[i][j]` represents the minimum sum of non-leaf nodes for the subtree formed by the elements between indices `i` and `j` in the array.
  
2. **Base Case**: If there are only two elements (leaf nodes), there are no non-leaf nodes, so `dp[i][i+1]` will be `0`.

3. **Recursion through partitions**: For every subarray defined by indices `[i, j]`, we try every possible partition `k` between `i` and `j`. The left subtree is defined by `i` to `k`, and the right subtree is defined by `k+1` to `j`. The resulting non-leaf node value for the node at this partition would be the product of the maximum leaf value in the left subtree and the right subtree:

   - The maximum leaf value in the left subtree can be obtained from `max(arr[i...k])`.
   - The maximum leaf value in the right subtree can be obtained from `max(arr[k+1...j])`.
   - Thus, the non-leaf node value is `max(arr[i...k]) * max(arr[k+1...j])`.
   - We then sum this value with the results of the subtrees.

4. **Iterate and Compute**: We'll use nested loops to iterate through all possible starting and ending indices of the array and calculate the possible minimum sums.

5. **Return Result**: Finally, the answer will be in `dp[0][n-1]`, where `n` is the length of the array.

Here's the Python code that implements the above logic:



```python
class Solution:
    def mctFromLeaves(self, arr: List[int]) -> int:
        n = len(arr)
        
        # Initialize the DP array
        dp = [[0] * n for _ in range(n)]
        
        # Fill the dp array
        for length in range(2, n + 1):  # length of subarray
            for i in range(n - length + 1):
                j = i + length - 1
                # Start with a large value
                dp[i][j] = float('inf')
                # Find the minimum sum using the partitions
                for k in range(i, j):
                    # Calculate non-leaf node value using max
                    non_leaf_value = max(arr[i:j+1]) * max(arr[k+1:j+1])
                    # Update dp[i][j] with the minimum found
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + non_leaf_value)
        
        # The result will be the minimum sum for the entire array
        return dp[0][n-1]

# Example usage:
# sol = Solution()
# print(sol.mctFromLeaves([6, 2, 4]))  # Output: 32

```

### Explanation of the Code
1. **Initialization**: We create a DP table `dp` where `dp[i][j]` will hold the minimum sum for the leaves from index `i` to `j`.
2. **Filling DP Table**: We iterate through all possible lengths of subarrays and for every possible partition, calculate the non-leaf node value and check if it's less than the current known minimum.
3. **Return Statement**: After filling the DP table, we return `dp[0][n-1]`, which holds the minimum sum for the entire array.

### Complexity Analysis
- **Time Complexity**: O(n^3). There are three nested loops: two for defining the range in the DP table and one for finding the partitions.
- **Space Complexity**: O(n^2) due to the DP table. 

This approach efficiently computes the desired result with respect to the problem constraints.

# 1190. Reverse Substrings Between Each Pair of Parentheses

### Problem Description 
You are given a string `s` that consists of lower case English letters and brackets. 
Reverse the strings in each pair of matching parentheses, starting from the innermost one.

Your result should not contain any brackets.


Example 1:
Input: s = "(abcd)"
Output: "dcba"

Example 2:
Input: s = "(u(love)i)"
Output: "iloveu"
Explanation: The substring "love" is reversed first, then the whole string is reversed.


Example 3:
Input: s = "(ed(et(oc))el)"
Output: "leetcode"
Explanation: First, we reverse the substring "oc", then "etco", and finally, the whole string.


Example 4:
Input: s = "a(bcdefghijkl(mno)p)q"
Output: "apmnolkjihgfedcbq"

Constraints:
`0 <= s.length <= 2000`
`s` only contains lower case English characters and parentheses.

It's guaranteed that all parentheses are balanced.

### Solution 
 To solve the problem of reversing strings in matching parentheses, we can utilize a stack data structure. The stack allows us to handle the nested structure of parentheses effectively. Here's a step-by-step explanation of our approach:

### Approach:

1. **Initialize a Stack**: We'll use a stack to keep track of the characters we encounter in the string. This will help us handle the nested structures of the parentheses.

2. **Iterate Through the String**: We'll go through each character in the string:
   - If the character is an opening parenthesis `(`, we'll push a marker (like `None`) onto the stack. This marker signifies that we're starting a new substring to be reversed.
   - If the character is a closing parenthesis `)`, we'll start popping characters from the stack until we hit the marker. We'll then reverse the popped string and push it back onto the stack.
   - If the character is a regular character, we simply push it onto the stack.

3. **Build the Result**: Once we've processed all characters, the stack will contain all our strings (some of them reversed) without any parentheses. We'll join these characters to get the final result.

### Implementation:



```python
class Solution:
    def reverseParentheses(self, s: str) -> str:
        stack = []  # Create a stack to hold characters
        for char in s:
            if char == ')':
                # Start popping from the stack until we hit the marker
                current = []
                while stack and stack[-1] != None:
                    current.append(stack.pop())
                # Remove the marker
                if stack and stack[-1] == None:
                    stack.pop()
                # Reverse the current substring and push it back to the stack
                stack.append(''.join(current))
            else:
                if char == '(':
                    stack.append(None)  # Use None as a marker for '('
                else:
                    stack.append(char)  # Regular character, push to stack
        
        # Join the characters in the stack to get the result
        return ''.join(stack)

```

### Explanation of Code:

1. **Class Declaration**: We define a class `Solution` which contains the method `reverseParentheses`.

2. **Iterate Through String**: We loop through each character in the string.
   - If we encounter `)`, we create an empty list `current` to hold the characters that are inside the parentheses. We then pop characters from the stack until we find our marker `None`.
   - If we encounter `(`, we push a `None` marker onto the stack.
   - For all other characters, we simply push them onto the stack.

3. **Final Result**: After processing all characters, we concatenate all the strings left in the stack to form our final result, which we return.

### Complexity Analysis:

- **Time Complexity**: O(n), where n is the length of the input string. Each character is pushed and popped from the stack at most once.
- **Space Complexity**: O(n) in the worst case, for storing characters in the stack.

This method efficiently handles the problem of nested parentheses, ensuring that the innermost strings are reversed first, and the final output is composed correctly without any parentheses.

# 1209. Remove All Adjacent Duplicates in String II

### Problem Description 
Given a string `s`, a k duplicate removal consists of choosing `k` adjacent and equal letters from `s` and removing them causing the left and the right side of the deleted substring to concatenate together.

We repeatedly make `k` duplicate removals on `s` until we no longer can.

Return the final string after all such duplicate removals have been made.

It is guaranteed that the answer is unique.


Example 1:
Input: s = "abcd", k = 2
Output: "abcd"
Explanation: There's nothing to delete.


Example 2:
Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation: 
First delete "eee" and "ccc", get "ddbbbdaa"
Then delete "bbb", get "dddaa"
Finally delete "ddd", get "aa"

Example 3:
Input: s = "pbbcggttciiippooaais", k = 2
Output: "ps"

Constraints:
`1 <= s.length <= 10^5`
`2 <= k <= 10^4`
`s` only contains lower case English letters.

### Solution 
 To solve the problem of removing `k` adjacent duplicates from a string `s`, we can use a stack-based approach. This is efficient and works well within the constraints provided.

The basic idea is to iterate through the string and manage a stack that keeps track of characters and their counts. When we encounter a character, we check if it matches the last one in the stack:
- If it does, we increase the count.
- If it doesnâ€™t, we add the new character to the stack with a count of 1.

Every time the count of a character reaches `k`, we remove that character from the stack, effectively removing it from our result since those `k` characters are adjacent and equal. Finally, we'll construct our result string based on the remaining characters in the stack.

Here is the implementation of the solution:



```python
class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:
        # Stack to keep track of characters and their counts
        stack = []
        
        for char in s:
            if stack and stack[-1][0] == char:
                # Increment the count of the last character if it matches
                stack[-1][1] += 1
                # If count reaches k, pop it out
                if stack[-1][1] == k:
                    stack.pop()
            else:
                # If different character, push to the stack with count 1
                stack.append([char, 1])
        
        # Reconstruct the final string from the stack
        result = []
        for char, count in stack:
            result.append(char * count)  # Repeat character according to the count
        
        return ''.join(result)

```

### Explanation of the Code:

1. **Initialization of the Stack**: We use a list `stack` to keep track of characters and their counts. Each element in the stack is a list where the first element is the character and the second element is the count of that character.

2. **Iterating through the String**: For each character in the string `s`:
    - Check if the stack is non-empty and the character on the top of the stack matches the current character.
        - If it does, increment the count of that character in the stack.
        - Check if the count has reached `k`. If so, pop it from the stack (thus effectively removing those characters).
    - If it doesnâ€™t match, push the new character onto the stack with a count of 1.

3. **Reconstructing the Result String**: After processing all characters in `s`, reconstruct the resultant string by:
    - Creating an empty list `result`.
    - For each character and count pair in the stack, append the character multiplied by its count to `result`.
    - Finally, join the list to form the final string that will be returned.

### Complexity Analysis:
- **Time Complexity**: O(n), where n is the length of the input string `s`. Each character is processed at most twice (once when added to the stack and possibly once when removed).
- **Space Complexity**: O(n), in the worst case when no removals occur, the stack could grow to the size of the input string.

This algorithm effectively handles the problem requirements and constraints while being efficient.

# 1249. Minimum Remove to Make Valid Parentheses

### Problem Description 
Given a string s of `'('` , `')'` and lowercase English characters. 
Your task is to remove the minimum number of parentheses ( `'('` or `')'`, in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:
It is the empty string, contains only lowercase characters, or
It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid strings, or
It can be written as `(A)`, where `A` is a valid string.


Example 1:
Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.


Example 2:
Input: s = "a)b(c)d"
Output: "ab(c)d"

Example 3:
Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.


Example 4:
Input: s = "(a(b(c)d)"
Output: "a(b(c)d)"

Constraints:
`1 <= s.length <= 10^5`
`s[i]` is one of  `'('` , `')'` and lowercase English letters`.`

### Solution 
 To solve the problem of removing the minimum number of parentheses to make the string valid, we can use a two-pass approach. This method will help us determine how many opening and closing parentheses are not balanced, and then we can construct a valid string accordingly. 

### Detailed Explanation:

1. **First Pass (Count Unbalanced Parentheses):**
    - We will iterate through the string while maintaining a count of unbalanced parentheses.
    - For every open parenthesis `'('`, we increment a counter `open_count`.
    - For every closing parenthesis `')'`, we check if there's an unbalanced open parenthesis:
        - If `open_count` is greater than zero, it means we can match this closing parenthesis with an open one, so we decrement `open_count`.
        - If `open_count` is zero, it means this closing parenthesis is unbalanced, so we simply skip this character.

2. **Second Pass (Build the Resultant String):**
    - We will construct the result string in this pass.
    - We again iterate through the string, but this time we will only include characters that should be part of the valid string:
        - We include lowercase letters directly.
        - For opening parentheses `'('`, we only include them if we still have unmatched ones (tracked by the `open_count`).
        - For closing parentheses `')'`, we only include them if there is an opening parenthesis that hasn't been matched yet.

3. **Return the Result:**
    - After constructing our valid string in the second pass, we return it.

Hereâ€™s the Python code implementing the above logic:



```python
class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        open_count = 0
        
        # First pass: count unbalanced parentheses
        for char in s:
            if char == '(':
                open_count += 1
            elif char == ')':
                if open_count > 0:
                    open_count -= 1
        
        # Second pass: build the result
        result = []
        
        for char in s:
            if char == '(':
                if open_count > 0:
                    result.append(char)
                    open_count -= 1
            elif char == ')':
                if result.count('(') > result.count(')'):
                    result.append(char)
            else:
                result.append(char)
        
        return ''.join(result)


```

### Explanation of the Code:
- The code defines a class `Solution` with a method `minRemoveToMakeValid`. This method takes one string argument `s`.
- We initialize `open_count` to track the number of unmatched open parentheses.
- The first loop counts how many `')'` we cannot match with `'('`.
- The second loop constructs the valid string by selectively appending characters to a list named `result`.
- Finally, we join the characters in the `result` list into a string and return it.

### Complexity Analysis:
- **Time Complexity:** O(n), where n is the length of the string, as we traverse the string twice.
- **Space Complexity:** O(n) for the result list in the worst case where all characters are included.

This solution efficiently constructs a valid parentheses string by only making the necessary removals and operates within the constraints provided in the problem statement.

# 1381. Design a Stack With Increment Operation

### Problem Description 
Design a stack which supports the following operations.

Implement the `CustomStack` class:
`CustomStack(int maxSize)` Initializes the object with `maxSize` which is the maximum number of elements in the stack or do nothing if the stack reached the `maxSize`.

`void push(int x)` Adds `x` to the top of the stack if the stack hasn't reached the `maxSize`.

`int pop()` Pops and returns the top of stack or -1 if the stack is empty.

`void inc(int k, int val)` Increments the bottom `k` elements of the stack by `val`. If there are less than `k` elements in the stack, just increment all the elements in the stack.


Example 1:
Input
["CustomStack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
Output
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
Explanation
CustomStack customStack = new CustomStack(3); // Stack is Empty []
customStack.push(1);                          // stack becomes [1]
customStack.push(2);                          // stack becomes [1, 2]
customStack.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]
customStack.push(2);                          // stack becomes [1, 2]
customStack.push(3);                          // stack becomes [1, 2, 3]
customStack.push(4);                          // stack still [1, 2, 3], Don't add another elements as size is 4
customStack.increment(5, 100);                // stack becomes [101, 102, 103]
customStack.increment(2, 100);                // stack becomes [201, 202, 103]
customStack.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]
customStack.pop();                            // return 202 --> Return top of the stack 102, stack becomes [201]
customStack.pop();                            // return 201 --> Return top of the stack 101, stack becomes []
customStack.pop();                            // return -1 --> Stack is empty return -1.


Constraints:
`1 <= maxSize <= 1000`
`1 <= x <= 1000`
`1 <= k <= 1000`
`0 <= val <= 100`
At most `1000` calls will be made to each method of `increment`, `push` and `pop` each separately.

### Solution 
 To implement the `CustomStack` class as described in the problem statement, we'll need to handle the various operations that manipulate the stack and maintain the required properties. Below is the implementation in Python and a detailed explanation.

### Implementation:



```python
class CustomStack:

    def __init__(self, maxSize: int):
        self.maxSize = maxSize  # Set the maximum size of the stack
        self.stack = []         # Initialize an empty list to serve as the stack
        self.increment = [0] * maxSize  # A list to handle increments for the bottom elements

    def push(self, x: int) -> None:
        if len(self.stack) < self.maxSize:  # Check if the stack has room for more elements
            self.stack.append(x)  # Add the element to the top of the stack
            # No need to do anything with increment since we're just adding a new item
            
    def pop(self) -> int:
        if not self.stack:  # If the stack is empty
            return -1  # Return -1 as specified
        index = len(self.stack) - 1  # Get the index of the top element
        value = self.stack.pop() + self.increment[index]  # Pop the top value and add any increment
        if index > 0:  # If there are elements below, propagate the increment to the element below
            self.increment[index - 1] += self.increment[index]
        self.increment[index] = 0  # Reset the increment at the popped index
        return value  # Return the actual popped value

    def increment(self, k: int, val: int) -> None:
        # Increment the bottom k elements
        # We need to consider if k exceeds the current stack size
        limit = min(k, len(self.stack))  # we can only increment up to the current stack size
        if limit > 0:  # Only increment if there's something to increment
            self.increment[limit - 1] += val  # Just update the respective increment for the last of the bottom k


```

### Explanation:

1. **Initialization (`__init__` method)**:
   - The class is initialized with a `maxSize` which defines the maximum number of elements that can be held in the stack.
   - We maintain a list called `stack` to hold the actual elements of the stack and another list called `increment` to keep track of the increments we need to apply to the bottom elements.

2. **Push (`push` method)**:
   - This method checks if the stack is full (i.e., if its length is less than `maxSize`). 
   - If there is space, it adds the new element `x` to the top of the stack.

3. **Pop (`pop` method)**:
   - First, it checks if the stack is empty. If it is, it returns -1.
   - If the stack has elements, it pops the top element, applies any increment from the `increment` list, and checks if thereâ€™s a previous element to propagate the increment to.
   - It resets the increment for the element that was just popped.

4. **Increment (`increment` method)**:
   - This method allows us to increment the bottom `k` elements of the stack by a value `val`.
   - It calculates the limit for the increment based on the minimum of `k` and the current size of the stack to avoid accessing out-of-bounds elements.
   - The increment is recorded in the `increment` array, where we only update the increment at the index corresponding to the last of the bottom `k`.

### Complexity:
- Each operation (`push`, `pop`, `increment`) operates in O(1) time, making the approach efficient within the constraints provided. 

### Usage:
You can run the `CustomStack` class on platforms like LeetCode by copying the entire class code and using method calls to test its functionality as demonstrated in the example above.

# 1410. HTML Entity Parser

### Problem Description 
HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself.

The special characters and their entities for HTML are:
Quotation Mark: the entity is `&quot;` and symbol character is `"`.

Single Quote Mark: the entity is `&apos;` and symbol character is `'`.

Ampersand: the entity is `&amp;` and symbol character is `&`.

Greater Than Sign: the entity is `&gt;` and symbol character is `>`.

Less Than Sign: the entity is `&lt;` and symbol character is `<`.

Slash: the entity is `&frasl;` and symbol character is `/`.

Given the input `text` string to the HTML parser, you have to implement the entity parser.

Return the text after replacing the entities by the special characters.


Example 1:
Input: text = "&amp; is an HTML entity but &ambassador; is not."
Output: "& is an HTML entity but &ambassador; is not."
Explanation: The parser will replace the &amp; entity by &

Example 2:
Input: text = "and I quote: &quot;...&quot;"
Output: "and I quote: \"...\""

Example 3:
Input: text = "Stay home! Practice on Leetcode :)"
Output: "Stay home! Practice on Leetcode :)"

Example 4:
Input: text = "x &gt; y &amp;&amp; x &lt; y is always false"
Output: "x > y && x < y is always false"

Example 5:
Input: text = "leetcode.com&frasl;problemset&frasl;all"
Output: "leetcode.com/problemset/all"

Constraints:
`1 <= text.length <= 10^5`
The string may contain any possible characters out of all the 256 ASCII characters.

### Solution 
 To solve the problem of parsing HTML entities in a text string, we will create a function that replaces specified entity strings with their corresponding characters. We will leverage a simple string replacement approach to accomplish this efficiently given the constraints.

Here's how we can implement the solution:

### Step-by-step Explanation

1. **Define the Mappings**: We create a dictionary mapping each HTML entity to its corresponding character. The entities to replace include:
   - `&quot;` -> `"`
   - `&apos;` -> `'`
   - `&amp;` -> `&`
   - `&gt;` -> `>`
   - `&lt;` -> `<`
   - `&frasl;` -> `/`

2. **Replacement Logic**: We use the `str.replace()` method to substitute each entity with its character. This approach is both straightforward and efficient for the problem size.

3. **Iterate Over Entities**: We take each entity from the dictionary and sequentially apply the `str.replace()` method to the input string, ensuring that all occurrences of each entity are replaced.

4. **Return the Result**: Finally, we return the modified string as the output.

Hereâ€™s the implementation in Python, formatted according to LeetCode's solution style:



```python
class Solution:
    def entityParser(self, text: str) -> str:
        # Define a mapping of HTML entities to their corresponding characters
        entity_mapping = {
            "&quot;": '"',
            "&apos;": "'",
            "&amp;": '&',
            "&gt;": '>',
            "&lt;": '<',
            "&frasl;": '/'
        }
        
        # Replace each entity in the text with the corresponding character
        for entity, char in entity_mapping.items():
            text = text.replace(entity, char)
        
        return text

```

### Explanation of the Code

- **Class Definition**: The solution is encapsulated within a class named `Solution`, which is a standard practice in LeetCode problems.
  
- **Method Definition**: The function `entityParser` takes a single string parameter `text`, which contains the HTML text to be parsed.

- **Mapping Creation**: A dictionary called `entity_mapping` holds the mapping from HTML entities to their corresponding characters.

- **Replacement Loop**: A `for` loop iterates over each (`entity`, `char`) pair in the mapping, updating the `text` string by replacing the HTML entities with the respective characters.

- **Return Statement**: The modified text, now free of encoded HTML entities, is returned as the result.

### Complexity Analysis

- **Time Complexity**: O(n * m), where `n` is the length of the `text` and `m` is the number of entities to replace. Since there are a fixed number of replacements (6 in this case), this essentially simplifies to O(n) for practical purposes.

- **Space Complexity**: O(n) for storing the resulting string in memory.

### Testing the implementation

You can test the provided implementation with various input cases from the problem statement to ensure correctness and efficiency. The implementation handles edge cases and adheres to the constraints detailed above.

# 1441. Build an Array With Stack Operations

### Problem Description 
Given an array `target` and an integer `n`. In each iteration, you will read a number from  `list = {1,2,3..., n}`.

Build the `target` array using the following operations:
Push: Read a new element from the beginning `list`, and push it in the array.

Pop: delete the last element of the array.

If the target array is already built, stop reading more elements.

Return the operations to build the target array. You are guaranteed that the answer is unique.


Example 1:
Input: target = [1,3], n = 3
Output: ["Push","Push","Pop","Push"]
Explanation: 
Read number 1 and automatically push in the array -> [1]
Read number 2 and automatically push in the array then Pop it -> [1]
Read number 3 and automatically push in the array -> [1,3]

Example 2:
Input: target = [1,2,3], n = 3
Output: ["Push","Push","Push"]

Example 3:
Input: target = [1,2], n = 4
Output: ["Push","Push"]
Explanation: You only need to read the first 2 numbers and stop.


Example 4:
Input: target = [2,3,4], n = 4
Output: ["Push","Pop","Push","Push","Push"]

Constraints:
`1 <= target.length <= 100`
`1 <= target[i] <= n`
`1 <= n <= 100`
`target` is strictly increasing.

### Solution 
 To solve the problem of building the target array using a sequence of operations (Push and Pop), we can follow a structured approach. Hereâ€™s the detailed explanation of our solution:

### Problem Breakdown:
1. We need to simulate reading numbers from the list `{1, 2, ..., n}` one by one and apply the operations to build the `target` array.
2. The operations we can perform are:
   - **Push**: Adding the current number (from the 1 to n list) to our result array.
   - **Pop**: Removing the last number from our result array.
3. Our goal is to return the sequence of operations that results in the `target` array.

### Solution Approach:
1. Initialize an empty result list that will hold the operation sequence.
2. Use a variable to keep track of the last number we pushed into the `target` array.
3. Iterate through the numbers from `1` to `n`.
   - If the current number is in the `target`, we push it into the result and increment our position in the target.
   - If itâ€™s not in the `target`, we still perform a Push operation, followed by a Pop operation to remove the last element.
   - Stop once we have finished processing all elements in the `target`.
4. Return the result of operations.

### Code Implementation:
Here's the Python code that implements this logic, formatted according to LeetCode submission requirements:



```python
class Solution:
    def buildArray(self, target: List[int], n: int) -> List[str]:
        result = []
        target_index = 0
        target_length = len(target)
        
        for num in range(1, n + 1):
            if target_index < target_length and target[target_index] == num:
                result.append("Push")
                target_index += 1
            else:
                result.append("Push")
                result.append("Pop")
            
            # If we have reached the length of the target array, we can break early
            if target_index == target_length:
                break
        
        return result

```

### Explanation of the Code:
1. **Initialization**: Start with an empty `result` list to store the operations.
2. **Iteration**: Loop through numbers from `1` to `n`.
   - Check if the current number matches the expected number in the target array:
     - If it does, we perform a "Push" operation and move to the next expected number in `target`.
     - If it doesn't match, we perform "Push" and immediately follow it with "Pop".
3. **Early Termination**: If we have completed building the `target` by reaching its length, we break out of the loop since no additional numbers are needed.
4. **Return Result**: Finally, return the list of operations.

### Complexity Analysis:
- **Time Complexity**: O(n), where n is the maximum value from the list since we iterate through it sequentially once.
- **Space Complexity**: O(n) in the worst case for the result list, depending on how many operations we build.

This solution efficiently constructs the target array while keeping track of the operations needed, and it adheres to the constraints provided in the problem statement.

# 1541. Minimum Insertions to Balance a Parentheses String

### Problem Description 
Given a parentheses string `s` containing only the characters `'('` and `')'`. A parentheses string is balanced if:
Any left parenthesis `'('` must have a corresponding two consecutive right parenthesis `'))'`.

Left parenthesis `'('` must go before the corresponding two consecutive right parenthesis `'))'`.

In other words, we treat `'('` as openning parenthesis and `'))'` as closing parenthesis.

For example, `"())"`, `"())(())))"` and `"(())())))"` are balanced, `")()"`, `"()))"` and `"(()))"` are not balanced.

You can insert the characters `'('` and `')'` at any position of the string to balance it if needed.

Return the minimum number of insertions needed to make `s` balanced.


Example 1:
Input: s = "(()))"
Output: 1
Explanation: The second '(' has two matching '))', but the first '(' has only ')' matching. We need to to add one more ')' at the end of the string to be "(())))" which is balanced.


Example 2:
Input: s = "())"
Output: 0
Explanation: The string is already balanced.


Example 3:
Input: s = "))())("
Output: 3
Explanation: Add '(' to match the first '))', Add '))' to match the last '('.


Example 4:
Input: s = "(((((("
Output: 12
Explanation: Add 12 ')' to balance the string.


Example 5:
Input: s = ")))))))"
Output: 5
Explanation: Add 4 '(' at the beginning of the string and one ')' at the end. The string becomes "(((())))))))".


Constraints:
`1 <= s.length <= 10^5`
`s` consists of `'('` and `')'` only.

### Solution 
 To solve the problem of balancing the parentheses string under the given conditions, we can employ a simple algorithm that utilizes a counter to track unmatched parentheses. Below is a step-by-step explanation followed by the Python code that adheres to the LeetCode solution format.

### Steps to Approach the Problem:

1. **Understand Requirements**: We need to ensure that each opening parenthesis `'('` is matched by exactly two closing parentheses `'))'`. This means that for every `'('` we encounter, we expect to find two `')'`.

2. **Counting Approach**:
    - We will loop through the string and maintain a counter for unmatched opening parentheses.
    - Whenever we encounter a `'('`, we will increase our unmatched counter by 1.
    - If we encounter a `')'`, we will check:
        - If there's an unmatched `'('`, we can "consume" one `)`, reducing our unmatched opening counter.
        - If there's no unmatched `'('`, this closing parenthesis is unmatched. In this case, we can decide how to handle it:
            - Since `'))'` needs to be matched, every unmatched `')'` can be thought of needing an additional `')'` to form a complete pair `'))'`. Thus, we would need 2 insertions for each unmatched `')'`.

3. **Final Adjustments**:
    - At the end of our iteration, if we still have any unmatched opening parentheses, each will require 2 closing parentheses to balance them.
  
4. **Counting Insertions Needed**:
    - Maintain a counter for insertions required based on unmatched parentheses.

### Implementation in Python:



```python
class Solution:
    def minAddToMakeValid(self, s: str) -> int:
        # Initialize counters
        unmatched_open = 0  # Count of unmatched '('
        insertions_needed = 0  # Number of insertions needed to balance the string

        for char in s:
            if char == '(':
                # Every '(' increases the unmatched count
                unmatched_open += 1
            elif char == ')':
                # When we find a ')', check if we can match it with '('
                if unmatched_open > 0:
                    unmatched_open -= 1  # Matching this ')' with a previous '('
                else:
                    # We need an additional `')'` to balance this unmatched ')'
                    insertions_needed += 1

        # After processing all characters, unmatched_open holds unmatched '('
        insertions_needed += unmatched_open * 2  # Each unmatched '(' requires 2 ')'

        return insertions_needed

```

### Explanation of the Code:
- **Initialization**: We start with counters `unmatched_open` to track unmatched `'('` and `insertions_needed` for counting how many insertions are necessary.
- **Loop through String**: We check each character:
    - On encountering `'('`, we increment the unmatched count.
    - On encountering `')'`, we attempt to match it with an unmatched `'('`.
        - If we have an unmatched opening, we reduce our count. 
        - If not, it means we need an additional closing parenthesis to balance this one, and we increment our insertions.
- **Final Unmatched Handling**: After finishing the loop, if there are any unmatched openings, we multiply their count by 2, because each needs two closing parentheses.
- **Return Result**: Finally, we return the total insertions needed as our answer.

### Complexity:
- **Time Complexity**: O(n), where n is the length of the string `s`, since we make a single pass through the string.
- **Space Complexity**: O(1), we only use a fixed amount of space for counters.

This solution efficiently determines the minimum number of insertions required to balance the given parentheses string.

# 1544. Make The String Great

### Problem Description 
Given a string `s` of lower and upper case English letters.

A good string is a string which doesn't have two adjacent characters `s[i]` and `s[i + 1]` where:
`0 <= i <= s.length - 2`
`s[i]` is a lower-case letter and `s[i + 1]` is the same letter but in upper-case or vice-versa.

To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.

Return the string after making it good. The answer is guaranteed to be unique under the given constraints.

Notice that an empty string is also good.


Example 1:
Input: s = "leEeetcode"
Output: "leetcode"
Explanation: In the first step, either you choose i = 1 or i = 2, both will result "leEeetcode" to be reduced to "leetcode".


Example 2:
Input: s = "abBAcC"
Output: ""
Explanation: We have many possible scenarios, and all lead to the same answer. For example:
"abBAcC" --> "aAcC" --> "cC" --> ""
"abBAcC" --> "abBA" --> "aA" --> ""

Example 3:
Input: s = "s"
Output: "s"

Constraints:
`1 <= s.length <= 100`
`s` contains only lower and upper case English letters.

### Solution 
 To solve the given problem, we need to create a function that processes a string to remove adjacent pairs of characters that are the same, but differ in case (i.e., one is lowercase, and the other is the same letter in uppercase). We will continue this process until no such pairs remain, at which point we will return the resulting string.

### Approach:

1. **Use a Stack**: A stack data structure is well-suited for this task because it allows us to efficiently manage the characters as we iterate through the string.
   - For every character in the string, we will check if the stack is not empty and if the top character of the stack is the same as the current character but with a different case. If this condition holds, we will pop the top element from the stack (effectively removing both characters).
   - If the condition does not hold, we will push the current character onto the stack.

2. **Final String**: Once we finish processing all characters in the string, the stack will contain characters of the final "good" string. We convert the stack back into a string to return the result.

### Implementation:

Here is the implementation based on the outlined approach.



```python
class Solution:
    def makeGood(self, s: str) -> str:
        stack = []
        
        for char in s:
            if stack and stack[-1] != char and stack[-1].lower() == char.lower():
                stack.pop()  # Remove the last character as it forms a bad pair with the current character
            else:
                stack.append(char)  # Add the current character to the stack
        
        # Join the characters in the stack to form the resulting good string
        return ''.join(stack)

# Example usage:
# solution = Solution()
# print(solution.makeGood("leEeetcode"))  # Output: "leetcode"
# print(solution.makeGood("abBAcC"))      # Output: ""
# print(solution.makeGood("s"))            # Output: "s"

```

### Detailed Explanation:

1. **Stack Initialization**: We start by creating an empty stack that will hold the characters of the good string.

2. **Iterating through the String**: For each character in the input string `s`:
   - If the stack is not empty, and the last character in the stack is different from the current character (to ensure they are different letters) but matches the current character in the same case (i.e., lowercase vs uppercase), we pop the last character from the stack.
   - If these conditions are not met, we push the current character onto the stack.

3. **Building the Result**: After processing all characters, we construct the resulting string from the characters remaining in the stack. This is done using `''.join(stack)`, which creates a single string from the list of characters in the stack.

4. **Returning the Result**: Finally, we return the constructed string, which is guaranteed to be "good" based on the problem requirements.

This solution efficiently processes the string in O(n) time, where n is the length of the string, as each character is pushed and popped from the stack at most once. The space complexity is also O(n) in the worst case, where all characters are retained in the stack.

# 1598. Crawler Log Folder

### Problem Description 
The Leetcode file system keeps a log each time some user performs a change folder operation.

The operations are described below:
`"../"` : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).

`"./"` : Remain in the same folder.

`"x/"` : Move to the child folder named `x` (This folder is guaranteed to always exist).

You are given a list of strings `logs` where `logs[i]` is the operation performed by the user at the `ith` step.

The file system starts in the main folder, then the operations in `logs` are performed.

Return the minimum number of operations needed to go back to the main folder after the change folder operations.


Example 1:
Input: logs = ["d1/","d2/","../","d21/","./"]
Output: 2
Explanation: Use this change folder operation "../" 2 times and go back to the main folder.


Example 2:
Input: logs = ["d1/","d2/","./","d3/","../","d31/"]
Output: 3

Example 3:
Input: logs = ["d1/","../","../","../"]
Output: 0

Constraints:
`1 <= logs.length <= 103`
`2 <= logs[i].length <= 10`
`logs[i]` contains lowercase English letters, digits, `'.'`, and `'/'`.

`logs[i]` follows the format described in the statement.

Folder names consist of lowercase English letters and digits.

### Solution 
 To solve the problem of determining how many operations are needed to return to the main folder in a file system, we can utilize a simple counter approach. The operations given in the `logs` list will dictate our movement through the folders.

Hereâ€™s a step-by-step explanation of how we can approach this:

1. **Initialization**: Start with a counter for the depth of folders. We will initialize this counter to zero, which represents being in the main folder.

2. **Iterate through Logs**: Loop through each operation logged in the `logs` list.
   - If the log indicates moving to a child folder (i.e., it ends with a `/` and does not equal `../` or `./`), we increment the counter since we're going deeper into the folder structure.
   - If the log indicates moving up to the parent folder (`../`), we decrement the counter, but only if we are not already at the root (depth = 0).
   - If the log indicates remaining in the same folder (`./`), we do nothing since thereâ€™s no change in depth.

3. **Calculate Return Operations**: After processing all logs, the value of our counter will represent how many levels deep we are from the main folder. To return to the main folder, we need to perform operations equal to the counter's value.

4. **Return Result**: The result will be the final value of the counter which gives us the minimum number of operations needed to return to the main folder.

Here's the concrete implementation of this logic in Python, formatted to be directly executable in a LeetCode environment:



```python
class Solution:
    def minOperations(self, logs: List[str]) -> int:
        depth = 0
        
        for log in logs:
            if log == "../":
                if depth > 0:
                    depth -= 1
            elif log == "./":
                continue
            else:
                # If it's a directory change like "x/"
                depth += 1
        
        return depth

```

### Explanation of the Code:
- We define a class `Solution` and a method `minOperations` that takes a list of strings `logs`.
- The variable `depth` is initialized to zero, representing the main folder.
- We loop through each entry `log` in `logs`:
  - For `../`, we check if `depth` is greater than 0 before decrementing it.
  - For `./`, we do nothing since it has no effect on our position.
  - For any other string (indicating we are entering a directory), we simply increment the `depth`.
- Finally, we return the `depth`, which indicates how many operations are required to return to the main folder.

This solution runs in O(n) time complexity, where n is the length of the `logs` list, making it efficient and well-suited for the given constraints.

# 1673. Find the Most Competitive Subsequence

### Problem Description 
Given an integer array `nums` and a positive integer `k`, return the most competitive subsequence of `nums` of size `k`.

An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.

We define that a subsequence `a` is more competitive than a subsequence `b` (of the same length) if in the first position where `a` and `b` differ, subsequence `a` has a number less than the corresponding number in `b`. For example, `[1,3,4]` is more competitive than `[1,3,5]` because the first position they differ is at the final number, and `4` is less than `5`.


Example 1:
Input: nums = [3,5,2,6], k = 2
Output: [2,6]
Explanation: Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.


Example 2:
Input: nums = [2,4,3,3,5,4,9,6], k = 4
Output: [2,3,3,4]

Constraints:
`1 <= nums.length <= 105`
`0 <= nums[i] <= 109`
`1 <= k <= nums.length`

### Solution 
 To solve the problem of finding the most competitive subsequence of an integer array `nums` of size `k`, we can utilize a greedy algorithm with a stack (or a list in Python). The main idea is to maintain a stack that contains the current best candidates for our result while ensuring that the numbers remain in increasing order and the final length of the stack is `k`.

Here's a step-by-step breakdown of the approach:

1. **Using a Stack**: We'll use a stack to build the most competitive subsequence. As we traverse through the array, we will push elements onto the stack, but we must ensure that the stack only contains the most competitive elements.

2. **Maintain Size Constraint**: While pushing elements, if the current element is smaller than the top of the stack, and if we can still remove elements from the stack to make room for the current element, we will pop the top of the stack. This ensures that we are always keeping the smallest possible elements in the subsequence.

3. **Condition for Popping the Stack**: We will pop an element from the stack if:
   - The current element is smaller than the top of the stack.
   - Popping the top element will still allow us to have enough elements left in `nums` to form a subsequence of size `k`.

4. **Edge Cases**: After examining all elements, if the stack exceeds size `k`, we will slice it to get only the first `k` elements since we only need that many.

5. **Final Output**: The stack will contain the most competitive subsequence when the traversal is complete.

Here's the implementation following the described strategy:



```python
from typing import List

class Solution:
    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:
        stack = []
        n = len(nums)
        
        for i in range(n):
            while (stack and 
                   stack[-1] > nums[i] and 
                   len(stack) + (n - i) > k):
                stack.pop()
            stack.append(nums[i])
        
        # We slice the stack to ensure we have exactly k elements
        return stack[:k]

```

### Explanation of the Code:
- **Definitions**: We define the `mostCompetitive` function that takes a list `nums` and an integer `k`.
- **Initialize Stack**: An empty list `stack` is created to hold our competitive subsequence.
- **Loop through the Numbers**:
  - For each number in `nums`, we check if the top of the stack can be removed based on our conditions. If the current number is less than the one at the top of the stack, we pop it out, provided that popping does not prevent us from forming a subsequence of size `k`.
  - Then we append the current number to the stack.
- **Return the Result**: Finally, the first `k` elements of the stack are returned, which represents the most competitive subsequence.

### Complexity Analysis:
- **Time Complexity**: O(n), where n is the number of elements in `nums`, as we process each number at most twice (once when adding to the stack, and possibly once when removing).
- **Space Complexity**: O(k), for storing the resultant subsequence.

This implementation should work efficiently even for the upper limits of constraints provided (1 <= nums.length <= 10^5).

# 1703. Minimum Adjacent Swaps for K Consecutive Ones

### Problem Description 
You are given an integer array, `nums`, and an integer `k`. `nums` comprises of only `0`'s and `1`'s. In one move, you can choose two adjacent indices and swap their values.

Return the minimum number of moves required so that `nums` has `k` consecutive `1`'s.


Example 1:
Input: nums = [1,0,0,1,0,1], k = 2
Output: 1
Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's.


Example 2:
Input: nums = [1,0,0,0,0,0,1,1], k = 3
Output: 5
Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1].


Example 3:
Input: nums = [1,1,0,1], k = 2
Output: 0
Explanation: nums already has 2 consecutive 1's.


Constraints:
`1 <= nums.length <= 105`
`nums[i]` is `0` or `1`.

`1 <= k <= sum(nums)`

### Solution 
 To solve the problem of moving `1`s in the array to achieve `k` consecutive `1`s with the minimum number of swaps, we can use a sliding window approach. The intuition behind this method is to count how many `0`s we need to "pass" in order to group `1`s together, aiming to create a window of size `k` filled with `1`s.

### Detailed Explanation:

1. **Identify Positions of `1`s**: First, we collect the indices of all `1`s in the list. This helps us understand where the `1`s are currently situated and how far they are from where we want to cluster them.

2. **Calculate Moves for Every Window**: We then iterate through the collected indices of `1`s to calculate the number of moves needed to arrange them consecutively. For every possible starting position of a window of size `k`, we need to:
    - Count how many `0`s are between the current `1` positions as we try to move them into the window.
    - Use the formula to calculate how far each `1` would have to be moved to fit into the window of size `k`.

3. **Minimize Moves**: After calculating the required moves for every possible consecutive group of `1`s, we keep track of the minimal moves.

4. **Return Result**: Finally, we return the minimum calculated moves.

### Python Code Implementation:

Here is how you can implement this logic in Python according to LeetCode's format:



```python
class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        # Step 1: Collect positions of all '1's in nums
        ones_positions = [i for i, num in enumerate(nums) if num == 1]
        total_ones = len(ones_positions)
        
        # Step 2: Initialize required variables
        if total_ones < k:
            return -1  # not enough '1's
        
        # Step 3: Calculate the minimum moves required
        # Taking the '1's from the first k '1's as the target
        current_moves = 0
        # Starting with the moves needed to get the first k ones into position
        for i in range(k):
            current_moves += ones_positions[i] - ones_positions[0] - i
        
        min_moves = current_moves
        
        # Step 4: Sliding window over the list of positions of '1's
        for i in range(1, total_ones - k + 1):
            # Remove the first '1' from the current window and add the next '1' in the array of '1's
            current_moves += (ones_positions[i + k - 1] - ones_positions[i + k - 2]) * (k - 1) - (ones_positions[i + k - 1] - ones_positions[i - 1])
            min_moves = min(min_moves, current_moves)
        
        # Step 5: Return the minimum found moves
        return min_moves

# The above solution can be directly run on LeetCode after importing the required libraries:
# from typing import List

```

### Explanation of the Code:
- We first construct a list `ones_positions` to gather the indices of all `1`s in the array.
- By counting moves initially for the first `k` `1`s, we set our baseline. 
- We then use a sliding window approach to adjust the moves needed as we move the window to cover the next group of `k` `1`s.
- Finally, we check and return the minimum number of moves required to achieve the goal. 

This solution should work efficiently within the constraints, as we processing is linear with respect to the number of elements in the `nums` list.

